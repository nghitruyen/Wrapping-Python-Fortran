!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_mesh.f90
!! \brief This file includes m_mesh module.
!! \details The file includes only m_mesh module (see doc m_mesh module).

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module m_mesh
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_mesh.
!!
!! \details This module includes mesh, cross section and point structure and subroutine alloc/deallocation of the
!! cross section
module m_mesh
    use m_common
    use m_linear_algebra
    implicit none
    
    integer, parameter :: K_constant = 1
    integer, parameter :: K_powerlaw_h = 2
    integer, parameter :: strickler_type_constant = 1
    integer, parameter :: strickler_type_powerlaw_h = 2

    !> Structure of a cross section.
    type Crosssection
        
        !> Planar coordinates
        type(vec2d) :: coord
        !> Curvilinear abscissa
        real(rp) :: x
        !> Index of current level
        integer(ip) :: level
        !> Number of discretization levels
        integer(ip) :: nlevels
#ifdef FLOODPLAIN_MODEL
        !> Shape coefficient for floodplain
        real(rp) :: alphaFP
#endif
        !> Bathymetry height
        real(rp) :: bathy
        !> Distance between x(i-1/2) and x(i+1/2)
        real(rp) :: delta
        !> Distance between x(i-1) and x(i)
        real(rp) :: deltademi
        !> Slope
        real(rp) :: slope
        !> Array of levels heights
        real(rp), dimension(:), allocatable :: level_heights
        !> Array of levels widths
        real(rp), dimension(:), allocatable :: level_widths
        !> Array of displacements ! TODO DEPRECATED
        real(rp), dimension(:), allocatable :: y
        !> Array of Strickler parameters
        real(rp), dimension(:), allocatable :: strickler_params
        !> Array of polynoms coefficients for each level
        !> \details Each row corresponds to a level and each column to power of H (H^p, H^{p-1}, ..., H^0)
        real(rp), dimension(:, :), allocatable :: poly
        !> Array of cumulated flow area between levels 0 and k
        real(rp), dimension(:), allocatable :: area_cum
        !> Array of cumulated wetted perimeter between levels 0 and k
        real(rp), dimension(:), allocatable :: perim_cum
        !> Array of cumulated Pa between levels 0 and k
        real(rp), dimension(:), allocatable :: pa_cum

    end type Crosssection


    !> Structure of a segment.
    type Segment
                
        !> Index of first cross-section
        integer(ip) :: first_cs
        !> Index of last cross-section
        integer(ip) :: last_cs
        !> Index of downstream segment
        integer(ip) :: ds_seg
        !> Indices of upstream segments
        integer(ip), dimension(:), allocatable :: us_seg
        !> Index of downstream BC (only for a segment with no downstream segment)
        integer(ip) :: ds_bc
        !> Index of upstream BC (only for a segment with no upstream segments)
        integer(ip) :: us_bc

    end type Segment

    !> Structure of spatial field
    type SpatialField
        character(len=8) :: interp = "none"
        real(rp), dimension(:), allocatable  ::  x  !< Curvilinear abscissa array.
        real(rp), dimension(:), allocatable  ::  y  !< Flow array.
    end type


    !> Structure of a mesh.
    type Mesh
                
        !> Number of cross-sections
        integer(ip) :: ncs
        !> Number of segments
        integer(ip) :: nseg
        !> Array of cross-sections
        type(Crosssection), dimension(:), allocatable :: cs
        !> Array of segments
        type(Segment), dimension(:), allocatable :: seg
        
        type(SpatialField) :: bathy_field
        character(len=16) :: strickler_type = "constant"
        integer :: strickler_type_code = 1
        type(SpatialField), dimension(:), allocatable :: strickler_fields
    
!         character(len=lchar) :: file_name                                     !< Name of the mesh file.
! 
!         real(rp), dimension(:), allocatable :: dx                             !< Distance between cross section

!         real(rp) :: scal                                                        !< Scale (not used)

    end type Mesh


    !> Structure of point in mesh.
    !!
    !! \details Coordinates of the node belong to the mesh structure.
    type point_in_mesh

        type( vec2d ) :: coord !< Coordinates of the node.   

        integer(ip) :: indexi  !< Number of the node.   

    end type point_in_mesh
    
    
#ifndef CPP_ADJ
    ! Interfaces to routines and functions defined in base/geometry.f90
    interface
        subroutine compute_levels_poly(cs)
            import Crosssection
            implicit none
            type(Crosssection), intent(inout) :: cs
        end subroutine
        subroutine compute_levels_cum(cs)
            import Crosssection
            implicit none
            type(Crosssection), intent(inout) :: cs
        end subroutine
        subroutine update_level(cs, h)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
        end subroutine
        subroutine update_level_from_area(cs, area)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: area
        end subroutine
        function htoA(cs, h) result(A)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: A
        end function
        function htoA_noupdate(cs, h) result(A)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: A
        end function
        function htoP(cs, h) result(P)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: P
        end function
        function htoP_noupdate(cs, h) result(P)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: P
        end function
        function htoW(cs, h) result(W)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: W
        end function
        function htoW_noupdate(cs, h) result(W)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: W
        end function
        function Atoh(cs, A) result(h)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: A
            real(rp) :: h
        end function
        function Atoh_noupdate(cs, A) result(h)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: A
            real(rp) :: h
        end function
  !       subroutine height(cs, h, value)
  !           import Crosssection
  !           import rp
  !           implicit none
  !           type(Crosssection), intent(in) :: cs
  !           real(rp), intent(in) :: h
  !           real(rp), intent(out) :: value
  !       end subroutine
        subroutine width(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine depth_from_area(cs, area, h)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: area
            real(rp), intent(out) :: h      
        end subroutine
        subroutine area(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine perimeter(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine strickler(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine pressure(cs, h, gravity, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(in) :: gravity
            real(rp), intent(out) :: value
        end subroutine
        subroutine Sg(cs, csm1, csp1, h, gravity, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            type(Crosssection), intent(in) :: csm1
            type(Crosssection), intent(in) :: csp1
            real(rp), intent(in) :: h
            real(rp), intent(in) :: gravity
            real(rp), intent(out) :: value      
        end subroutine
        subroutine dPdZ(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine dKdZ(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine compute_all_levels_cum(msh)
            import Mesh
            implicit none
            type(Mesh), intent(inout) :: msh
        end subroutine
        subroutine update_all_levels(msh, h)
            import Mesh
            import rp
            implicit none
            type(Mesh), intent(inout) :: msh
            real(rp), dimension(msh%ncs), intent(in) :: h
        end subroutine
    end interface

    ! Interfaces to routines defined in base/apply_bathy_field.f90
    interface
        subroutine apply_bathy_field(msh, eps)
            import Mesh
            import rp
            implicit none
            type(Mesh), intent(inout) :: msh
            real(rp), intent(in) :: eps
        end subroutine
    end interface

    ! Interfaces to routines defined in base/apply_strickler_fields.f90
    interface
        subroutine apply_strickler_fields(msh)
            import Mesh
            import rp
            implicit none
            type(Mesh), intent(inout) :: msh
        end subroutine
    end interface
#endif


#ifndef CPP_ADJ  
    contains
  

    subroutine crosssection_initialise(cs, nlevels, shape_model)
        implicit none
        type(Crosssection), intent(inout) :: cs
        integer(ip), intent(in) :: nlevels
        character(len=lchar), intent(in), optional :: shape_model
        
        integer :: order
        
!         print *, "initialise Crosssection", loc(cs)
        if (present(shape_model)) then
            select case(shape_model)
                case("linear")
                    order = 1
                case("cubic_spline")
                    order = 3
                case default
                    call f90wrap_abort("Unknwon 'shape_model' "//trim(shape_model))
            end select
        else
            order = 1
        end if
        
        allocate(cs%level_heights(nlevels))
        cs%level_heights(:) = 0.0_rp
        allocate(cs%level_widths(nlevels))
        cs%level_widths(:) = 0.0_rp
        allocate(cs%y(nlevels))
        cs%y(:) = 0.0_rp
        allocate(cs%strickler_params(2))
        cs%strickler_params(:) = 0.0_rp
        allocate(cs%poly(order+1, nlevels))
        cs%poly(:, :) = 0.0_rp
        cs%nlevels = nlevels

        allocate(cs%area_cum(nlevels))
        cs%area_cum(:) = 0.0_rp
        allocate(cs%perim_cum(nlevels))
        cs%perim_cum(:) = 0.0_rp
        allocate(cs%pa_cum(nlevels))
        cs%pa_cum(:) = 0.0_rp
        
        cs%level = 0
#ifdef FLOODPLAIN_MODEL
        cs%alphaFP = 0.001
#endif
        
    
    end subroutine


    subroutine crosssection_finalise(cs)
        implicit none
        type(Crosssection), intent(inout) :: cs
        
        if (allocated(cs%level_heights)) deallocate(cs%level_heights)
        if (allocated(cs%level_widths)) deallocate(cs%level_widths)
        if (allocated(cs%poly)) deallocate(cs%poly)
        if (allocated(cs%area_cum)) deallocate(cs%area_cum)
        if (allocated(cs%perim_cum)) deallocate(cs%perim_cum)
        if (allocated(cs%pa_cum)) deallocate(cs%pa_cum)
        
    end subroutine
  

    subroutine set_levels(cs, heights, widths, shape_model)
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), dimension(:), intent(in) :: heights
        real(rp), dimension(:), intent(in) :: widths
        character(len=lchar), intent(in), optional :: shape_model
        
        integer :: nlevels
        integer :: order
        
        if (present(shape_model)) then
            select case(shape_model)
                case("linear")
                    order = 1
                case("cubic_spline")
                    order = 3
                case default
                    call f90wrap_abort("Unknwon 'shape_model' "//trim(shape_model))
            end select
        else
            order = 1
        end if
        
        nlevels = size(heights)
        
        allocate(cs%level_heights(nlevels))
        cs%level_heights(:) = heights(:)
        allocate(cs%level_widths(nlevels))
        cs%level_widths(:) = widths(:)
        allocate(cs%y(nlevels))
        cs%y(:) = 0.0_rp
        allocate(cs%strickler_params(2))
        cs%strickler_params(:) = 0.0_rp
        allocate(cs%poly(order+1, nlevels))
        cs%poly(:, :) = 0.0_rp
        cs%nlevels = nlevels

        allocate(cs%area_cum(nlevels))
        cs%area_cum(:) = 0.0_rp
        allocate(cs%perim_cum(nlevels))
        cs%perim_cum(:) = 0.0_rp
        allocate(cs%pa_cum(nlevels))
        cs%pa_cum(:) = 0.0_rp
        
        cs%level = 0
    
    end subroutine


    subroutine crosssection_copy(cs_src, cs_dst)
        implicit none
        type(Crosssection), intent(in) :: cs_src
        type(Crosssection), intent(inout) :: cs_dst
        
        call crosssection_finalise(cs_dst)
        
        ! Copy scalars
        cs_dst%coord%x = cs_src%coord%x
        cs_dst%coord%y = cs_src%coord%y
        cs_dst%x = cs_src%x
        cs_dst%level = cs_src%level
        cs_dst%nlevels = cs_src%nlevels
        cs_dst%bathy = cs_src%bathy
        cs_dst%delta = cs_src%delta
        cs_dst%deltademi = cs_src%deltademi
        cs_dst%slope = cs_src%slope
        
        ! Copy arrays
        if (allocated(cs_src%level_heights)) then
            allocate(cs_dst%level_heights(size(cs_src%level_heights)))
            cs_dst%level_heights(:) = cs_src%level_heights(:)
        end if
        if (allocated(cs_src%level_widths)) then
            allocate(cs_dst%level_widths(size(cs_src%level_widths)))
            cs_dst%level_widths(:) = cs_src%level_widths(:)
        end if
        if (allocated(cs_src%y)) then
            allocate(cs_dst%y(size(cs_src%y)))
            cs_dst%y(:) = cs_src%y(:)
        end if
        if (allocated(cs_src%strickler_params)) then
            allocate(cs_dst%strickler_params(size(cs_src%strickler_params)))
            cs_dst%strickler_params(:) = cs_src%strickler_params(:)
        end if
        if (allocated(cs_src%poly)) then
            allocate(cs_dst%poly(size(cs_src%poly, 1), size(cs_src%poly, 2)))
            cs_dst%poly(:, :) = cs_src%poly(:, :)
        end if
        if (allocated(cs_src%area_cum)) then
            allocate(cs_dst%area_cum(size(cs_src%area_cum)))
            cs_dst%area_cum(:) = cs_src%area_cum(:)
        end if
        if (allocated(cs_src%perim_cum)) then
            allocate(cs_dst%perim_cum(size(cs_src%perim_cum)))
            cs_dst%perim_cum(:) = cs_src%perim_cum(:)
        end if
        if (allocated(cs_src%pa_cum)) then
            allocate(cs_dst%pa_cum(size(cs_src%pa_cum)))
            cs_dst%pa_cum(:) = cs_src%pa_cum(:)
        end if
        
    end subroutine


    subroutine update_geometry(cs)
        implicit none
        type(Crosssection), intent(inout) :: cs
        
        call compute_levels_poly(cs)
        call compute_levels_cum(cs)
        
    end subroutine


    !> Allocate are cross section array.
    !! \param[out] var Array of the size of the number of cross section.
    !! \param[in] mesh Mesh structure.
    subroutine alloc_Crosssection(var, msh)
        implicit none

        type(Mesh), intent(in) :: msh                           

        real(rp), dimension(:), allocatable, intent(out) :: var   
        
        allocate( var( msh%ncs ) )   

        var(:)  =  0._rp 

    end subroutine alloc_Crosssection

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Increase or Decrease Allocated Mesh Array Memory
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
    !>  Increase or Decrease Allocated Mesh Array Memory
    !! \param[out] var Array of the size of the number of cross section.
    !! \param[in] new size of the new cross section.
    subroutine reallocate_Crosssection( var , new )

        implicit none

        type(Crosssection), dimension(:), allocatable, intent(inout) :: var

        integer(ip), intent(in) :: new

        integer(ip) :: old

        type(Crosssection), dimension(:), allocatable :: temp

        intrinsic move_alloc

        old = size(var)

        if      ( new == old ) then

            return

        else if ( new  < old ) then

            allocate( temp( new ) )

            temp( 1 : new ) = var( 1 : new )

            call move_alloc( temp , var )

        else

            allocate( temp( new ) )

            temp( 1 : old ) = var( : )

            call move_alloc( temp , var )

        end if

    end subroutine reallocate_Crosssection
  
  
    subroutine segment_initialise(seg, nus_segs)
        implicit none
        type(Segment), intent(inout) :: seg
        !> Number of upstream segments
        integer, intent(in) :: nus_segs
        
        allocate(seg%us_seg(nus_segs))
        seg%us_seg(:) = -1
    
    end subroutine


    subroutine segment_finalise(seg)
        implicit none
        type(Segment), intent(inout) :: seg
        
        if (allocated(seg%us_seg)) deallocate(seg%us_seg)
        
    end subroutine


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Deallocation of mesh structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
    !> Deallocation of mesh structure
    !! \param[inout] mesh Mesh structure.
    subroutine dealloc_mesh( msh )

        implicit none
        !> Mesh
        type(Mesh), intent(inout) :: msh
        
        ! Index of segment
        integer(ip) :: iseg


        if (allocated(msh%cs)) deallocate(msh%cs)
        if (allocated(msh%seg)) then
            do iseg = 1, size(msh%seg)
                call segment_finalise(msh%seg(iseg))
            end do
            deallocate(msh%seg)
        end if

    end subroutine dealloc_mesh



!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Allocation of a mesh structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
    !> Initialise a mesh
    !! \param[in,out] msh Instance of Mesh
    !! \param[in] ncs Number of cross-sections
    !! \param[in] nseg Number of segments
    subroutine mesh_initialise(msh, ncs, nseg)
        implicit none
        type(Mesh), intent(inout) :: msh                           
        integer, intent(in) :: ncs
        integer, intent(in), optional :: nseg
        
        allocate(msh%cs(ncs))
        msh%ncs = ncs
        if (present(nseg)) then
            allocate(msh%seg(nseg))
            msh%nseg = nseg
        end if

    end subroutine mesh_initialise


    subroutine setup_segment(msh, iseg, first_cs, ncs, us_seg, ds_seg)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in) :: iseg
        integer(ip), intent(in) :: first_cs
        integer(ip), intent(in) :: ncs
        integer(ip), dimension(:), intent(in) :: us_seg
        integer(ip), intent(in) :: ds_seg
        
        ! Iterator
        integer(ip) :: i
        ! Number of boundary conditions
        integer(ip) :: nbc
        
        msh%seg(iseg+1)%first_cs = first_cs + 1
        msh%seg(iseg+1)%last_cs = first_cs + ncs
        if (allocated(msh%seg(iseg+1)%us_seg)) deallocate(msh%seg(iseg+1)%us_seg)
        allocate(msh%seg(iseg+1)%us_seg(size(us_seg)))
        nbc = 0
        do i = 1, size(us_seg)
            if (us_seg(i) <= -1) then
                msh%seg(iseg+1)%us_seg(i) = 0
                nbc = nbc + 1
                msh%seg(iseg+1)%us_bc = nbc
            else
                msh%seg(iseg+1)%us_seg(i) = us_seg(i) + 1
            end if
        end do
        if (ds_seg <= -1) then
            msh%seg(iseg+1)%ds_seg = 0
            nbc = nbc + 1
            msh%seg(iseg+1)%ds_bc = nbc
        else
            msh%seg(iseg+1)%ds_seg = ds_seg + 1
        end if
        
    end subroutine


    subroutine setup_crosssection(msh, ics, nlevels)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in) :: ics
        integer(ip), intent(in) :: nlevels
        
        call crosssection_initialise(msh%cs(ics), nlevels)
        
    end subroutine


    subroutine update_geometries(msh)
        implicit none
        type(Mesh), intent(inout) :: msh
        
        ! Index of cross-section
        integer(ip) :: ics
        
        do ics = 1, msh%ncs
            call update_geometry(msh%cs(ics))
        end do
        
    end subroutine
    
    
    subroutine set_strickler_type(msh, strickler_type)
        implicit none
        type(Mesh), intent(inout) :: msh
        character(len=*), intent(in) :: strickler_type

        if (strickler_type == "constant") then
        
            msh%strickler_type_code = strickler_type_constant

        else if (strickler_type == "powerlaw_h") then
        
            msh%strickler_type_code = strickler_type_powerlaw_h
            
        else
        
            call abort_solver("Wrong Strickler type: "//strickler_type)
        
        end if
        msh%strickler_type = strickler_type
    
    end subroutine


    subroutine set_uniform_strickler_parameters(msh, strickler_params)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp), dimension(2), intent(in) :: strickler_params
        
        ! Index of cross-section
        integer(ip) :: ics
        
        do ics = 1, msh%ncs
            msh%cs(ics)%strickler_params(:) = strickler_params(:)
        end do
        
    end subroutine


    subroutine set_bathy_field_linear(msh, x, bathy)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp), dimension(:), intent(in) :: x
        real(rp), dimension(:), intent(in) :: bathy
        
        ! Index of cross-section
        integer(ip) :: ics
        
        
        ! TODO check x and bathy are of same size
        
        if (allocated(msh%bathy_field%x)) deallocate(msh%bathy_field%x)
        if (allocated(msh%bathy_field%y)) deallocate(msh%bathy_field%y)
        allocate(msh%bathy_field%x(size(x)))
        allocate(msh%bathy_field%y(size(x)))
        msh%bathy_field%interp = "linear"
        msh%bathy_field%x(:) = x(:)
        msh%bathy_field%y(:) = bathy(:)
        
    end subroutine


    subroutine set_strickler_fields_segment(msh, strickler_params)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp), dimension(:, :), intent(in) :: strickler_params
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        
        ! TODO check sizes
        if (msh%strickler_type_code == strickler_type_constant) then
            if(size(strickler_params, 1) /= 1) then
                call abort_solver("Shape of strickler_params must be (1,N) for K=constant")
            end if
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            if(size(strickler_params, 1) /= 2) then
                call abort_solver("Shape of strickler_params must be (2,N) for K=powerlaw(h)")
            end if
        else
            call abort_solver("Wrong strickler type for mesh: "//trim(msh%strickler_type))
        end if
        if(size(strickler_params, 2) /= msh%nseg) then
            call abort_solver("Shape of strickler_params must be (_,N) where N is the number of segments")
        end if
        
        if (allocated(msh%strickler_fields)) then
            do i = 1, size(msh%strickler_fields)
                if (allocated(msh%strickler_fields(i)%x)) deallocate(msh%strickler_fields(i)%x)
                if (allocated(msh%strickler_fields(i)%y)) deallocate(msh%strickler_fields(i)%y)
            end do
            deallocate(msh%strickler_fields)
        end if
        if (msh%strickler_type_code == strickler_type_constant) then
            allocate(msh%strickler_fields(1))
            allocate(msh%strickler_fields(1)%x(msh%nseg))
            allocate(msh%strickler_fields(1)%y(msh%nseg))
            msh%strickler_fields(1)%interp = "segment"
            msh%strickler_fields(1)%y(:) = strickler_params(1, :)
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            allocate(msh%strickler_fields(2))
            allocate(msh%strickler_fields(1)%x(msh%nseg))
            allocate(msh%strickler_fields(1)%y(msh%nseg))
            allocate(msh%strickler_fields(2)%x(msh%nseg))
            allocate(msh%strickler_fields(2)%y(msh%nseg))
            msh%strickler_fields(1)%interp = "segment"
            msh%strickler_fields(1)%y(:) = strickler_params(1, :)
            print *, "msh%strickler_fields(1)%y=", msh%strickler_fields(1)%y
            msh%strickler_fields(2)%interp = "segment"
            msh%strickler_fields(2)%y(:) = strickler_params(2, :)
        end if
        
        call apply_strickler_fields(msh)
        
    end subroutine


    subroutine set_strickler_fields_linear(msh, x, strickler_params)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp), dimension(:), intent(in) :: x
        real(rp), dimension(:, :), intent(in) :: strickler_params
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        
        
        ! TODO check sizes
        if (msh%strickler_type_code == strickler_type_constant) then
            if(size(strickler_params, 1) /= 1) then
                call abort_solver("Shape of strickler_params must be (1,N) for K=constant")
            end if
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            if(size(strickler_params, 1) /= 2) then
                call abort_solver("Shape of strickler_params must be (2,N) for K=powerlaw(h)")
            end if
        else
            call abort_solver("Wrong strickler type for mesh: "//trim(msh%strickler_type))
        end if
        
        if (allocated(msh%strickler_fields)) then
            do i = 1, size(msh%strickler_fields)
                if (allocated(msh%strickler_fields(i)%x)) deallocate(msh%strickler_fields(i)%x)
                if (allocated(msh%strickler_fields(i)%y)) deallocate(msh%strickler_fields(i)%y)
            end do
            deallocate(msh%strickler_fields)
        end if
        if (msh%strickler_type_code == strickler_type_constant) then
            allocate(msh%strickler_fields(1))
            allocate(msh%strickler_fields(1)%x(size(x)))
            allocate(msh%strickler_fields(1)%y(size(strickler_params, 2)))
            msh%strickler_fields(1)%interp = "linear"
            msh%strickler_fields(1)%x(:) = x(:)
            msh%strickler_fields(1)%y(:) = strickler_params(1, :)
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            allocate(msh%strickler_fields(2))
            allocate(msh%strickler_fields(1)%x(size(x)))
            allocate(msh%strickler_fields(1)%y(size(strickler_params, 2)))
            allocate(msh%strickler_fields(2)%x(size(x)))
            allocate(msh%strickler_fields(2)%y(size(strickler_params, 2)))
            msh%strickler_fields(1)%interp = "linear"
            msh%strickler_fields(1)%x(:) = x(:)
            msh%strickler_fields(1)%y(:) = strickler_params(1, :)
            msh%strickler_fields(2)%interp = "linear"
            msh%strickler_fields(2)%x(:) = x(:)
            msh%strickler_fields(2)%y(:) = strickler_params(2, :)
        end if
        
    end subroutine


    subroutine get_segment_curvilinear_abscissae(msh, iseg, x)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in) :: iseg
        real(rp), dimension(:), allocatable, intent(out) :: x
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        
        
        ! TODO check sizes
        allocate(x(10))
        x(:) = 1.0
        
    end subroutine


    !> @return global index (0-based) of segment's cross-section 
    subroutine get_segment_cs_index(msh, iseg, ics_seg, ics)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in) :: iseg
        integer(ip), intent(in) :: ics_seg
        integer(ip), intent(out) :: ics
        
        
        ics = msh%seg(iseg+1)%first_cs + ics_seg - 1
        
    end subroutine
#endif

end module m_mesh
