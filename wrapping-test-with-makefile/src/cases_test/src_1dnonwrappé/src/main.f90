!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file main.f90
!! \brief This file is the main of the program.


!>
!!@mainpage Document Title 
!!
!!@section Introduction
!!
!! This document describes the source code for the DassFlow1D software. This documentation is automatically generated by doxygene.
!!
!! Entry point of the program : \ref main.f90
!!

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main of the DassFlow
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Main of DassFlow
!!
!! \details 
!! It is in this part of software that the main variables declaration are done and that computation are done in function
!! of inputs parameters
!!

PROGRAM main

   USE m_common
   USE m_mesh
   USE m_linear_algebra
   USE m_linear_solver
   USE m_numeric
   USE m_time_screen

   #ifdef USE_ADJ
      USE m_adjoint
      USE m_minimization
   #endif


   USE m_model

   implicit none

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!     INITIALIZATION
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!======================================================================================================================!
!  Main variables declaration
!======================================================================================================================!

  integer(ip) :: ite_rerun

  type( msh )  ::  mesh

  type( unk )  ::  dof0 , dof

  real(rp)  ::  cost_model, x
  
  
  ! TEMP
  real(rp) :: GetWFromH

!======================================================================================================================!
!  Reading arguments passed on the command line
!======================================================================================================================!

   call reading_args

!======================================================================================================================!
!  Machine precision limits numbers
!======================================================================================================================!

   call Machine_Number_Limits

#ifndef HIDE_MACHINE_LIMITS
   call Print_Screen( 'number_limits' )
#endif

!======================================================================================================================!
!  Read the input.txt Initialization File
!======================================================================================================================!

   call Read_Input()

!======================================================================================================================!
!  Read or Create the mesh / Geometric Properties Calculation
!======================================================================================================================!

   call Mesh_Input( mesh )

!======================================================================================================================!
!  Update indices for the bathymetry model
!======================================================================================================================!

   bathy_first = bathy_first+2
   if (bathy_last > mesh%ncs) then
      print *, " [ ERROR ] bathy_last out of range"
      stop
   end if
   if (bathy_last < 0) then
      bathy_last = mesh%ncs+3+bathy_last
   else
      bathy_last = bathy_last+2
   end if

   !==============================================================================================!
   !  Create directories
   !==============================================================================================!
   call system('mkdir -p res')
   if (args(1) == 'grad') then
      call system('mkdir -p grad')
   else if (args(1) == 'min') then
      call system('mkdir -p min')
   end if
   
!======================================================================================================================!
!  Initialization of the linear solver (MUMPS, AGMG for the moment)
!======================================================================================================================!

   call Init_Linear_Solver( mesh )

!======================================================================================================================!
!  Model Variables Allocation in Memory
!======================================================================================================================!

   call alloc_dof( dof0 , mesh )
   call alloc_dof( dof  , mesh )
   
!======================================================================================================================!
!  Model Variables Initialization (Using m_user_data.f90 file provided in the /bin directory)
!======================================================================================================================!

   call Initial( dof0 , mesh, dof )

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!     BEGINNING TIME LOOP
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!   #if defined USE_SW_MONO || USE_SW_MULTI || USE_NS_MULTIFLUID

      select case( args(1) )

         case default

            print *, "Wrong simulation mode"
            
         case( 'run' )

            call Time_Init(1_ip)

            call Print_Screen( 'start_direct' )
            
            var_chg = .false.

            call run_model( mesh , dof0 , dof , cost_model )

            call Print_Screen( 'end_direct' )

            call Time_End(1_ip)

            call Time_Screen( mesh )

            call Print_Screen( 'cost' , cost_model )

#ifdef USE_ADJ
            

            case( 'testadj' )

               if (var_chg) then
                  call Print_Screen('background_error_covariance')
                  call background_error_covariance_matrix(mesh)
               end if
               ! call obs_error_cov_matrix(mesh) ! not implemented yet, aims at replacing the 'weights' of obs ?

               call Print_Screen( 'start_testadj' )

               call test_adjoint( mesh , dof0 , dof , args(2) )

               call Print_Screen( 'end_testadj' )

            case( 'grad' )

               if (var_chg) then
                  call Print_Screen('background_error_covariance')
                  call background_error_covariance_matrix(mesh)
               end if
               ! call obs_error_cov_matrix(mesh) ! not implemented yet, aims at replacing the 'weights' of obs ?

               call Print_Screen( 'start_grad_cost' )

               call calc_grad_cost( mesh , dof0 , dof )

               call Print_Screen( 'end_grad_cost' )

            case( 'min' )

               if (var_chg) then
                  call Print_Screen('background_error_covariance')
                  call background_error_covariance_matrix(mesh)
               end if
               ! call obs_error_cov_matrix(mesh) ! not implemented yet, aims at replacing the 'weights' of obs ?

               call Print_Screen( 'start_minimize' )
               
               call minimize_cost( mesh , dof0 , dof )               

               call Print_Screen( 'end_minimize' )

            case( 'rerun' )

               read(args(2), *) ite_rerun
               
               call Print_Screen( 'start_rerun', real(ite_rerun, rp) )
               
               call rerun_model( mesh , dof0 , dof, ite_rerun )

               call Print_Screen( 'end_rerun', real(ite_rerun, rp) )
               
               
            case( 'testW' )
            
                ie = mesh%ncs+1
                do i = 1, size(mesh%crosssection(ie)%height)
                  print *, i, mesh%crosssection(ie)%height(i), bathy_cell(ie), &
                              GetWFromH(mesh, mesh%crosssection(ie)%height(i)-bathy_cell(ie), ie), &
                              mesh%crosssection(ie)%surfacewidth(i)
                end do
         
            case( 'debug' )
            
                open(72, file="bathy_failure.txt")
                read(72, *) 
                do ie = 1, mesh%ncs+4
                  read(72, *) x, bathy_cell(ie)
                end do
                close(72)
                
                open(72, file="hydrograph_failure.txt")
                read(72, *)
                read(72, *)
                read(72, *)
                read(72, *)
                do ie = 1, size(bc%hyd%t)
                  read(72,*) bc%hyd%t(ie), bc%hyd%q(ie)
                end do
                close(72)
                

                call Time_Init(1_ip)

                call Print_Screen( 'start_direct' )

                call run_model( mesh , dof0 , dof , cost_model )

                call Print_Screen( 'end_direct' )

#endif

      end select

!   #else

!      call Test( mesh , dof0 , dof , cost_model )

!   #endif

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!     ENDING TIME LOOP ; DEALLOCATION NOW ...
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   call dealloc_model
   call dealloc_dof( dof0 )
   call dealloc_dof( dof  )
   call dealloc_mesh( mesh )

END PROGRAM main
