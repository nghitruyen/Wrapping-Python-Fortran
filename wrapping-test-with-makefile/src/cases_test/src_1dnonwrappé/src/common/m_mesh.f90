!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_mesh.f90
!! \brief This file includes m_mesh module.
!! \details The file includes only m_mesh module (see doc m_mesh module).

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module m_mesh
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_mesh.
!!
!! \details This module includes mesh, cross section and point structure and subroutine alloc/deallocation of the
!! cross section
MODULE m_mesh

   USE m_common
   USE m_linear_algebra

   implicit none


   !> Structure of a cross section.
   !!
   !! \details This structure include all cross section parameters (coordinates of the cross section, number of 
   !! layers/couples, elevations/width, ...). Moreover, additional computed parameters are saved in this structure
   !! to avoid to compute again this parameter (surface area, partial perimeter, ...).
   TYPE CrossSectionType

      type(vec2d)  ::  coord                                !< Node coordinates

      real(rp) :: x                                         !< Curvilinear abscissa

      integer(ip)  ::  nc                                   !< Number of couples/layers (heigth and water surface width)

      real(rp) :: elevation                                 !< Elevation of cross section

      real(rp) :: delta                                     !< Distance between \f$x_{i-1/2}\f$ and \f$x_{i+1/2}\f$ (not define for \f$x_0\f$ and \f$x_N\f$)

      real(rp) :: deltademi                                 !< Distance between \f$x_{i-1}\f$ and \f$x_i\f$ (not define for \f$x_0\f$ and \f$x_N\f$)

      real(rp) :: chainage                                  !< sum of all the delta up to the cross-section
      
      real(rp) :: slope                                     !< Slope of cross section 
   
      real(rp), dimension(:), allocatable  ::  height       !< Array of height

      real(rp), dimension(:), allocatable  ::  surfacewidth !< Array of surface width

      real(rp), dimension(:), allocatable  ::  y            !< Array of gap
   
      real(rp), dimension(:), allocatable  ::  trapAreaSum  !< Array of sum of trapezoids areas (\f$s_1 - s_0\f$,\f$s_2-s_0\f$, ...)
   
      real(rp), dimension(:), allocatable  ::  surfaceArea  !< Array of surface area (\f$s_0\f$,\f$s_1\f$, ...)
      
! DEPRECATED
!       real(rp), dimension(:), allocatable  ::  surfaceAreaSum  !< Array of surface area (\f$S_0=s_0\f$, \f$S_1=s_0+s_1\f$, ...)
      
      real(rp), dimension(:), allocatable  ::  intsurfaceAreaSum  !<Array of integration of \f$z_b\f$ to \f$H_i\f$ of \f$S\f$ : \f$\int_{z_b}^{H_i} S(z) dz\f$

      real(rp), dimension(:), allocatable  ::  perimeter  !< Array of perimeter (\f$pr_0\f$,\f$pr_1\f$, ...)

      real(rp), dimension(:), allocatable  ::  perimeterp1  !< Array of perimeter1 (\f$pr_{10}\f$,\f$pr_{11}\f$, ...)

      real(rp), dimension(:), allocatable  ::  perimeterp2  !< Array of perimeter2 (\f$pr_{20}\f$,\f$pr_{21}\f$, ...)

      real(rp), dimension(:), allocatable  ::  alpha1  !<Array of  alpha1 (\f$\alpha_{10}\f$,\f$\alpha_{11}\f$, ...)

      real(rp), dimension(:), allocatable  ::  alpha2  !<Array of alpha2 (\f$\alpha_{20}\f$,\f$\alpha_{21}\f$, ...)
      
! DEPRECATED
!       real(rp), dimension(:), allocatable  ::  perimeterSum  !<Array of perimeter sum (\f$pr_0=pr_0\f$, \f$pr_1=pr_0+pr_1\f$, ...)
   
      real(rp), dimension(:), allocatable  ::  trapPerimSum  !< Array of sum of trapezoids perimeters (\f$pr_1 - pr_0\f$,\f$pr_2-pr_0\f$, ...)

      real(rp), dimension(:), allocatable  ::  wl     !< Array of the w for the cross section \f$i-1\f$ (see pressure term) 

      real(rp), dimension(:), allocatable  ::  wr     !< Array of the w for the cross section \f$i+1\f$ (see pressure term)

      real(rp), dimension(:), allocatable  ::  zint   !< Array of height minus elevation

   END TYPE CrossSectionType


   !> Structure of the mesh.
   !!
   !! \details This structure include the number of mesh nodes (or cross section),
   !! the cross section structure (array), the name of the mesh and the distance between cross section (array).
   TYPE msh
            
      integer(ip)  ::  ncs                                                    !< Number of nodes.                                              

      type( CrossSectionType ), dimension(:), allocatable  ::  CrossSection   !< Node structure.
   
      character(len=lchar)  ::  file_name                                     !< Name of the mesh file.

      real(rp), dimension(:), allocatable  ::  dx                             !< Distance between cross section

      real(rp) :: scal                                                        !< Scale (not used)

   END TYPE msh


   !> Structure of point in mesh.
   !!
   !! \details Coordinates of the node belong to the mesh structure.
   TYPE point_in_mesh

      type( vec2d )  ::  coord !< Coordinates of the node.   

      integer(ip)  ::  indexi  !< Number of the node.   

   END TYPE point_in_mesh



CONTAINS


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Deallocation of mesh structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
   !> Allocate are cross section array.
   !! \param[out] var Array of the size of the number of cross section.
   !! \param[in] mesh Mesh structure.
   SUBROUTINE alloc_CrossSection( var , mesh )

      implicit none

      type( msh ), intent(in)  ::  mesh                           

      real(rp), dimension(:), allocatable, intent(out)  ::  var   
      
      allocate( var( mesh%ncs ) )   

      var(:)  =  0._rp 

   END SUBROUTINE alloc_CrossSection

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Increase or Decrease Allocated Mesh Array Memory
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
   !>  Increase or Decrease Allocated Mesh Array Memory
   !! \param[out] var Array of the size of the number of cross section.
   !! \param[in] new size of the new cross section.
   SUBROUTINE reallocate_CrossSection( var , new )

      implicit none

      type( CrossSectionType ), dimension(:), allocatable, intent(inout)  ::  var

      integer(ip), intent(in)  ::  new

      integer(ip)  ::  old

      type( CrossSectionType ), dimension(:), allocatable  ::  temp

      intrinsic move_alloc

      old = size(var)

      if      ( new == old ) then

         return

      else if ( new  < old ) then

         allocate( temp( new ) )

         temp( 1 : new ) = var( 1 : new )

         call move_alloc( temp , var )

      else

         allocate( temp( new ) )

         temp( 1 : old ) = var( : )

         call move_alloc( temp , var )

      end if

   END SUBROUTINE reallocate_CrossSection


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Deallocation of mesh structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
   !> Deallocation of mesh structure
   !! \param[inout] mesh Mesh structure.
   SUBROUTINE dealloc_mesh( mesh )

      implicit none

      type( msh ), intent(inout)  ::  mesh

      if ( allocated( mesh%CrossSection  ) ) deallocate( mesh%CrossSection  )
      if ( allocated( mesh%dx ) )            deallocate( mesh%dx )

   END SUBROUTINE dealloc_mesh



END MODULE m_mesh
