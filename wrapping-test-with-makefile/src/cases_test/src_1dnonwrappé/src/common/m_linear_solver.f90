!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_linear_solver.f90
!! \brief This file includes m_linear_solver module.
!! \details The file includes only m_linear_solver module (see doc m_linear_solver module).


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module controlling Internal and External Solvers
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_linear_solver.
!!
!! \details It is in this module that linear solver (mumps is defined and DGTSV) are defined.
MODULE m_linear_solver

   USE m_common
   USE m_mesh
   USE m_linear_algebra
   USE m_model

   implicit none

   include 'dmumps_struc.h'

   type( dmumps_struc )  ::  mumps_par !> Structure of MUMPS




CONTAINS


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main Subroutine to Initialize Solver(s)
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Solve AX=Y with mumps solver
   !!
   !! \details This subroutine solve the system AX=Y for sparse matrix. The matrix A is defined thanks to vector
   !! A (elements of A), IRN(indexes i of the element of the matrix A) and JCN (indexes j of the matrix A). Size of A 
   !! is given by N and the number of none zero element. Y is defined thanks to RHS.
   !!
   !! Exemple for the matrix:\n
   !! \f$A=\left(\begin{array}{ccc}
   !! a_{11}\\
   !! & a_{22} & a_{23}\\
   !! a_{31} &  & a_{33}
   !! \end{array}\right)   \f$ and \f$x^T=(x_1,x_2,x_3)\f$
   !!    - N=3.
   !!    - NZ=5.
   !!    - IRN[1:NZ] = [2,3,2,1,3].
   !!    - JCN[1:NZ] = [3,1,2,1,3].
   !!    - A  [1:NZ] = [\f$a23\f$,\f$a31\f$,\f$a22\f$,\f$a11\f$,\f$a33\f$].
   !!    - RHS[1:NZ] = [\f$x_1\f$,\f$x_2\f$,\f$x_3\f$].
   !! \author INRIA
   SUBROUTINE Init_Linear_Solver( mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in)  ::  mesh

      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      integer(ip)  ::  iL , iR,n,ie,jl

      !================================================================================================================!
      !  Begin Subroutine
      !================================================================================================================!

      #if defined USE_MUMPS

         mumps_par%JOB   = - 1  ! 
         mumps_par%SYM   =   0
         mumps_par%PAR   =  1

         call DMUMPS( mumps_par )

      #endif

      #if defined USE_SW_MONO && USE_MUMPS

         mumps_par%N   =  (mesh%ncs)*2
         mumps_par%NZ  =  2+(mesh%ncs-1)*8


         allocate(mumps_par%IRN( mumps_par%NZ ))
         allocate(mumps_par%JCN( mumps_par%NZ ))
         allocate(mumps_par%A  ( mumps_par%NZ ))
         allocate(mumps_par%RHS( mumps_par%N  ))




         n=mesh%ncs
         mumps_par%IRN(1)=1
         mumps_par%JCN(1)=1
         do jl=1,mesh%ncs-1
            mumps_par%IRN(jl*8-6)=2*jl
            mumps_par%JCN(jl*8-6)=2*jl+1
               
            mumps_par%IRN(jl*8-5)=2*jl
            mumps_par%JCN(jl*8-5)=2*jl+2
               
            mumps_par%IRN(jl*8-4)=2*jl
            mumps_par%JCN(jl*8-4)=2*jl-1
               
            mumps_par%IRN(jl*8-3)=2*jl
            mumps_par%JCN(jl*8-3)=2*jl
               
            mumps_par%IRN(jl*8-2)=2*jl+1
            mumps_par%JCN(jl*8-2)=2*jl+1
               
            mumps_par%IRN(jl*8-1)=2*jl+1
            mumps_par%JCN(jl*8-1)=2*jl+2
               
            mumps_par%IRN(jl*8)=2*jl+1
            mumps_par%JCN(jl*8)=2*jl-1
               
            mumps_par%IRN(jl*8+1)=2*jl+1
            mumps_par%JCN(jl*8+1)=2*jl
               
         end do
         mumps_par%IRN((n-1)*8+2)=2*n
         mumps_par%JCN((n-1)*8+2)=2*n  

         !mumps_par%IRN((n-1)*8+3)=2*n-2
         !mumps_par%JCN((n-1)*8+3)=2*n-2
         
      #endif



   END SUBROUTINE Init_Linear_Solver


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main Subroutine to Initialize Solver(s)
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!




   !> Solve AX=Y with DGTSV solver, with A tridiagonal matrix,by Gaussian elimination with partial pivoting.
   !!
   !! \details Note that the equation  A**T*X = B  may be solved by interchanging the order of the arguments DU and DL.
   !! \param[in] n The order of the matrix A.  N >= 0.
   !! \param[in] NRHS The number of right hand sides, i.e., the number of columns of the matrix B.  NRHS >= 0.
   !! \param[inout] DL  On entry, DL must contain the (n-1) sub-diagonal elements of A.
   !! On exit, DL is overwritten by the (n-2) elements of the second super-diagonal of the upper triangular matrix U
   !! from the LU factorization of A, in DL(1), ..., DL(n-2).
   !! \param[inout] D On entry, D must contain the diagonal elements of A.
   !! On exit, D is overwritten by the n diagonal elements of U.
   !! \param[inout] DU On entry, DU must contain the (n-1) super-diagonal elements of A.
   !! On exit, DU is overwritten by the (n-1) elements of the first super-diagonal of U.
   !! \param[inout] B On entry, the N by NRHS matrix of right hand side matrix B. On exit, if INFO = 0, the N by 
   !!NRHS solution matrix X.
   !! \param[in] LDB The leading dimension of the array B.  LDB >= max(1,N).
   !! \param[out] INFO If INFO:
   !!    - =  0: successful exit
   !!    - =< 0: if INFO = -i, the i-th argument had an illegal value
   !!    - >  0: if INFO = i, U(i,i) is exactly zero, and the solution  has not been computed.  The factorization 
   !! has not been completed unless i = N.
   
   SUBROUTINE DGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )
!
!  -- LAPACK routine (version 3.3.1) --
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
!  -- April 2011                                                      --
!
!     .. Scalar Arguments ..
      INTEGER            INFO, LDB, N, NRHS
!     ..
!     .. Array Arguments ..
      DOUBLE PRECISION   B( LDB, * ), D( * ), DL( * ), DU( * )
!     ..
!
!  Purpose
!  =======
!
!  DGTSV  solves the equation
!
!     A*X = B,
!
!  where A is an n by n tridiagonal matrix, by Gaussian elimination with
!  partial pivoting.
!
!  Note that the equation  A**T*X = B  may be solved by interchanging the
!  order of the arguments DU and DL.
!
!  Arguments
!  =========
!
!  N       (input) INTEGER
!          The order of the matrix A.  N >= 0.
!
!  NRHS    (input) INTEGER
!          The number of right hand sides, i.e., the number of columns
!          of the matrix B.  NRHS >= 0.
!
!  DL      (input/output) DOUBLE PRECISION array, dimension (N-1)
!          On entry, DL must contain the (n-1) sub-diagonal elements of
!          A.
!
!          On exit, DL is overwritten by the (n-2) elements of the
!          second super-diagonal of the upper triangular matrix U from
!          the LU factorization of A, in DL(1), ..., DL(n-2).
!
!  D       (input/output) DOUBLE PRECISION array, dimension (N)
!          On entry, D must contain the diagonal elements of A.
!
!          On exit, D is overwritten by the n diagonal elements of U.
!
!  DU      (input/output) DOUBLE PRECISION array, dimension (N-1)
!          On entry, DU must contain the (n-1) super-diagonal elements
!          of A.
!
!          On exit, DU is overwritten by the (n-1) elements of the first
!          super-diagonal of U.
!
!  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
!          On entry, the N by NRHS matrix of right hand side matrix B.
!          On exit, if INFO = 0, the N by NRHS solution matrix X.
!
!  LDB     (input) INTEGER
!          The leading dimension of the array B.  LDB >= max(1,N).
!
!  INFO    (output) INTEGER
!          = 0: successful exit
!          < 0: if INFO = -i, the i-th argument had an illegal value
!          > 0: if INFO = i, U(i,i) is exactly zero, and the solution
!               has not been computed.  The factorization has not been
!               completed unless i = N.
!
!  =====================================================================
!
!     .. Parameters ..
      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D+0 )
!     ..
!     .. Local Scalars ..
      INTEGER            I, J
      DOUBLE PRECISION   FACT, TEMP
!     ..
!     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX
!     ..
!     .. External Subroutines ..
      EXTERNAL           XERBLA
!     ..
!     .. Executable Statements ..
!
      INFO = 0
      IF( N.LT.0 ) THEN
         INFO = -1
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -7
      END IF
      IF( INFO.NE.0 ) THEN
         !CALL XERBLA( 'DGTSV ', -INFO )
         WRITE(*,*) ' INFO : ', INFO
         RETURN
      END IF
!
      IF( N.EQ.0 ) RETURN
!
      IF( NRHS.EQ.1 ) THEN
         DO 10 I = 1, N - 2
            IF( ABS( D( I ) ).GE.ABS( DL( I ) ) ) THEN
!
!              No row interchange required
!
               IF( D( I ).NE.ZERO ) THEN
                  FACT = DL( I ) / D( I )
                  D( I+1 ) = D( I+1 ) - FACT*DU( I )
                  B( I+1, 1 ) = B( I+1, 1 ) - FACT*B( I, 1 )
               ELSE
                  INFO = I
                  RETURN
               END IF
               DL( I ) = ZERO
            ELSE
!
!              Interchange rows I and I+1
!
               FACT = D( I ) / DL( I )
               D( I ) = DL( I )
               TEMP = D( I+1 )
               D( I+1 ) = DU( I ) - FACT*TEMP
               DL( I ) = DU( I+1 )
               DU( I+1 ) = -FACT*DL( I )
               DU( I ) = TEMP
               TEMP = B( I, 1 )
               B( I, 1 ) = B( I+1, 1 )
               B( I+1, 1 ) = TEMP - FACT*B( I+1, 1 )
            END IF
   10    CONTINUE
         IF( N.GT.1 ) THEN
            I = N - 1
            IF( ABS( D( I ) ).GE.ABS( DL( I ) ) ) THEN
               IF( D( I ).NE.ZERO ) THEN
                  FACT = DL( I ) / D( I )
                  D( I+1 ) = D( I+1 ) - FACT*DU( I )
                  B( I+1, 1 ) = B( I+1, 1 ) - FACT*B( I, 1 )
               ELSE
                  INFO = I
                  RETURN
               END IF
            ELSE
               FACT = D( I ) / DL( I )
               D( I ) = DL( I )
               TEMP = D( I+1 )
               D( I+1 ) = DU( I ) - FACT*TEMP
               DU( I ) = TEMP
               TEMP = B( I, 1 )
               B( I, 1 ) = B( I+1, 1 )
               B( I+1, 1 ) = TEMP - FACT*B( I+1, 1 )
            END IF
         END IF
         IF( D( N ).EQ.ZERO ) THEN
            INFO = N
            RETURN
         END IF
      ELSE
         DO 40 I = 1, N - 2
            IF( ABS( D( I ) ).GE.ABS( DL( I ) ) ) THEN
!
!              No row interchange required
!
               IF( D( I ).NE.ZERO ) THEN
                  FACT = DL( I ) / D( I )
                  D( I+1 ) = D( I+1 ) - FACT*DU( I )
                  DO 20 J = 1, NRHS
                     B( I+1, J ) = B( I+1, J ) - FACT*B( I, J )
   20             CONTINUE
               ELSE
                  INFO = I
                  RETURN
               END IF
               DL( I ) = ZERO
            ELSE
!
!              Interchange rows I and I+1
!
               FACT = D( I ) / DL( I )
               D( I ) = DL( I )
               TEMP = D( I+1 )
               D( I+1 ) = DU( I ) - FACT*TEMP
               DL( I ) = DU( I+1 )
               DU( I+1 ) = -FACT*DL( I )
               DU( I ) = TEMP
               DO 30 J = 1, NRHS
                  TEMP = B( I, J )
                  B( I, J ) = B( I+1, J )
                  B( I+1, J ) = TEMP - FACT*B( I+1, J )
   30          CONTINUE
            END IF
   40    CONTINUE
         IF( N.GT.1 ) THEN
            I = N - 1
            IF( ABS( D( I ) ).GE.ABS( DL( I ) ) ) THEN
               IF( D( I ).NE.ZERO ) THEN
                  FACT = DL( I ) / D( I )
                  D( I+1 ) = D( I+1 ) - FACT*DU( I )
                  DO 50 J = 1, NRHS
                     B( I+1, J ) = B( I+1, J ) - FACT*B( I, J )
   50             CONTINUE
               ELSE
                  INFO = I
                  RETURN
               END IF
            ELSE
               FACT = D( I ) / DL( I )
               D( I ) = DL( I )
               TEMP = D( I+1 )
               D( I+1 ) = DU( I ) - FACT*TEMP
               DU( I ) = TEMP
               DO 60 J = 1, NRHS
                  TEMP = B( I, J )
                  B( I, J ) = B( I+1, J )
                  B( I+1, J ) = TEMP - FACT*B( I+1, J )
   60          CONTINUE
            END IF
         END IF
         IF( D( N ).EQ.ZERO ) THEN
            INFO = N
            RETURN
         END IF
      END IF
!
!     Back solve with the matrix U from the factorization.
!
      IF( NRHS.LE.2 ) THEN
         J = 1
   70    CONTINUE
         B( N, J ) = B( N, J ) / D( N )
         IF( N.GT.1 )      B( N-1, J ) = ( B( N-1, J )-DU( N-1 )*B( N, J ) ) / D( N-1 )
         DO 80 I = N - 2, 1, -1
            B( I, J ) = ( B( I, J )-DU( I )*B( I+1, J )-DL( I )*&
                       B( I+2, J ) ) / D( I )
   80    CONTINUE
         IF( J.LT.NRHS ) THEN
            J = J + 1
            GO TO 70
         END IF
      ELSE
         DO 100 J = 1, NRHS
            B( N, J ) = B( N, J ) / D( N )
            IF( N.GT.1 )         B( N-1, J ) = ( B( N-1, J )-DU( N-1 )*B( N, J ) ) / D( N-1 )
            DO 90 I = N - 2, 1, -1
               B( I, J ) = ( B( I, J )-DU( I )*B( I+1, J )-DL( I )*B( I+2, J ) ) / D( I )
   90       CONTINUE
  100    CONTINUE
      END IF
!
      RETURN
!
!     End of DGTSV
!
      END
END MODULE m_linear_solver
