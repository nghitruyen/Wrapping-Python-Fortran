!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file geometry.f90
!! \brief This file includes all the geometry routine computation (transformation \f$s\leftrightarrow h\f$, perimeter, ...).


!> Update the unknowns \f$h\f$ from cross section geometry and \f$s\f$.
!! \details Algorithm used:\n
!! For each node:\n
!!    - if \f$s_i<=0\f$:
!!       - \f$h_i=0\f$ 
!!    - if \f$s_i<=s_i^0\f$:
!!       - \f$h_i=\frac{s_i}{w_i^0}\f$
!!    - if \f$s_i>S_i^0\f$:
!!       - Find \f$m\f$
!!       - if \f$w_i^{m+1}=w_i^{m}\f$:
!!          - \f$h_i=H_i^m-z_bi+h'\f$ with \f$h'= \frac{(s_i-s_i^m)}{w_i^m}\f$
!!       - else: 
!!          - \f$h_i=H_i^m-z_bi+h'\f$ with \f$h'=-\frac{w_i^m-A}{w_i^{m+1}-w_i^m}(H_i^{m+1}-H_i^m)\f$
!!            with \f$A = \sqrt{ (w_i^m)^2+2 \frac{w_i^{m+1}-w_i^m}{H_i^{m+1}-H_i^m}(s_i-s_i^m)}\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[inout] dof  Unknowns of the model.
SUBROUTINE SurfaceToHeight( mesh,dof )
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

   type( msh ), intent(in)  ::  mesh   
   type( unk ), intent(inout)  ::  dof

   integer(ip) :: ic
   real(rp) :: square 
   real(rp) :: s0
   integer(ip) :: m
   integer(ip) :: m_max
   integer(ip) :: findmsurface
   
   do ic=1,mesh%ncs+4

      !Case 1 : s = 0 (no water) -> h = 0
      if ((dof%s(ic).le.0.0_rp)) then 
            dof%h(ic)=0.0_rp
      
      else 
   
         ! Compute s0
         s0 = (mesh%crosssection(ic)%height(1) - bathy_cell(ic)) * mesh%crosssection(ic)%surfacewidth(1)

         !Case 2 : Only rectangular area is wet (s<=s_0 or m =0)
         if (dof%s(ic).le.s0) then
            dof%h(ic)=dof%s(ic)/mesh%crosssection(ic)%surfacewidth(1) ! h= s/w_0

         !Case 3 : s> s_0 or m>0
         else
        
            m=findMSurface(mesh,dof%s(ic),ic) !return m
            m_max = size(mesh%crosssection(ic)%surfacewidth)

            !Case 3_0 : if m > m_max (rectangular geometry)
            if (m >= m_max) then

! DEPRECATED
!                dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
!                   (dof%s(ic) - mesh%crosssection(ic)%surfaceareasum(m_max))/mesh%crosssection(ic)%surfacewidth(m_max)!(s-s_m)/w_m
               dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
                  (dof%s(ic) - s0 - mesh%crosssection(ic)%trapAreaSum(m_max))/mesh%crosssection(ic)%surfacewidth(m_max)!(s-s_m)/w_m
            
            !Case 3_1 : if w_m+1=w_m (rectangular geometry)
            else if ((mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m)).le.(0.0000001)) then
               !h=H_m-z_b+hprime_m
               !hprime_m=(s-s_m)/w_m
! DEPRECATED
!                dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
!                   (dof%s(ic)- mesh%crosssection(ic)%surfaceareasum(m))/mesh%crosssection(ic)%surfacewidth(m)!(s-s_m)/w_m
               dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
                  (dof%s(ic) - s0 - mesh%crosssection(ic)%trapAreaSum(m))/mesh%crosssection(ic)%surfacewidth(m)!(s-s_m)/w_m

            !Case 3_2 : w_m+1 != w_m (trapezium geometry)
            else 
               !h=H_m+hprime_m
               !hprime_m=-((w_m-square)/(w_{m+1}-w_m))*(H_{m+1}-H_m)
               ! with square = sqrt( w_m^2+2*((w_{m+1}-w_m)/(H_{m+1}-H_m))*(s-s_m))

! DEPRECATED
!                square=sqrt(mesh%crosssection(ic)%surfacewidth(m)**2+&                                  !sqrt(w_m^2+
!                   two*((mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m))/ & !2*((w_{m+1}-w_m)/
!                   (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m)))* &               !(H_{m+1}-H_m))*
!                   (dof%s(ic)- mesh%crosssection(ic)%surfaceareasum(m)))                                 !(s-s_m))
               square=sqrt(mesh%crosssection(ic)%surfacewidth(m)**2+&                                  !sqrt(w_m^2+
                  two*((mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m))/ & !2*((w_{m+1}-w_m)/
                  (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m)))* &               !(H_{m+1}-H_m))*
                  (dof%s(ic) - s0 - mesh%crosssection(ic)%trapAreaSum(m)))                                 !(s-s_m))

               dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)-&                                !H_m-
                  (( mesh%crosssection(ic)%surfacewidth(m)-square)/&                                   !((w_m-square)/
                  (mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m)))* &   !(w_{m+1}-w_m))*
                  (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m))                   !(H_{m+1}-H_m)
            endif

         end if
      end if      
   end do
END SUBROUTINE SurfaceToHeight

!> Update the unknown \f$h_i\f$ from cross section geometry,\f$m_i\f$ and \f$s_i\f$.
!! \details Algorithm used:\n
!!  if \f$s_i<=0\f$:
!!    - \f$h_i=0\f$ 
!!
!!  if \f$s_i<=s_i^0\f$:
!!    - \f$h_i=\frac{s_i}{w_i^0}\f$
!!
!!  if \f$s_i>S_i^0\f$:
!!    - Find \f$m\f$
!!    - if \f$w_i^{m+1}=w_i^{m}\f$:
!!       - \f$h_i=H_i^m-z_bi+h'\f$ with \f$h'= \frac{(s_i-s_i^m)}{w_i^m}\f$
!!    - else: 
!!       - \f$h_i=H_i^m-z_bi+h'\f$ with \f$h'=-\frac{w_i^m-A}{w_i^{m+1}-w_i^m}(H_i^{m+1}-H_i^m)\f$
!!       with \f$A = \sqrt{ (w_i^m)^2+2 \frac{w_i^{m+1}-w_i^m}{H_i^{m+1}-H_i^m}(s_i-s_i^m)}\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[inout] dof  Unknowns of the model.
!! \param[in] crossSection Number of the cross section.
!! \param[inout] mvector  value of \f$m\f$.
SUBROUTINE SurfaceToHeightCrossSection( mesh,dof,crossSection,mvector)
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

   type( msh ), intent(in)     ::  mesh
   type( unk ), intent(inout)  ::  dof
   integer(ip), intent(in)     :: crossSection
   integer(ip), dimension(mesh%ncs+4), intent(in)     ::mvector

   integer(ip) :: ic
   real(rp) :: square
   real(rp) :: s0
   integer(ip) :: m
   integer(ip) :: m_max
   
   real(rp) :: StoH

      ic=crossSection

      !Case 1 : s = 0 (no water) -> h = 0
      if ((dof%s(ic).le.0.0_rp)) then 
            dof%h(ic)=0.0_rp
      
      else 
   
         ! Compute s0
         s0 = (mesh%crosssection(ic)%height(1) - bathy_cell(ic)) * mesh%crosssection(ic)%surfacewidth(1)

         !Case 2 : Only rectangular area is wet (s<=s_0 or m =0)
         if (dof%s(ic).le.s0) then
            dof%h(ic)=dof%s(ic)/mesh%crosssection(ic)%surfacewidth(1) ! h= s/w_0
!             print *, "case2", ic, dof%h(ic)

         !Case 3 : s> s_0 or m>0
         else
        
            m=mvector(ic) !return m
            m_max = size(mesh%crosssection(ic)%surfacewidth)

            !Case 3_0 : if m>=m_max (rectangular geometry)
            if (m >= m_max) then
               
! DEPRECATED
!                dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
!                   (dof%s(ic)- mesh%crosssection(ic)%surfaceareasum(m_max))/mesh%crosssection(ic)%surfacewidth(m_max)!(s-s_m)/w_m
               dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
                  (dof%s(ic) - s0 - mesh%crosssection(ic)%trapAreaSum(m_max))/mesh%crosssection(ic)%surfacewidth(m_max)!(s-s_m)/w_m
            
!                print *, "case3_0", ic, dof%h(ic)
            !Case 3_1 : if w_m+1=w_m (rectangular geometry)
            !if (mesh%crosssection(ic)%surfacewidth(m+1).eq.mesh%crosssection(ic)%surfacewidth(m)) then
            else if (abs(mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m)).le.(0.0000001)) then
               !h=H_m-z_b+hprime_m
               !hprime_m=(s-s_m)/w_m
               !dof%h(ic)=mesh%crosssection(ic)%height(m)-mesh%crosssection(ic)%elevation+&                  !h=H_m-z_b+
!                dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
!                   (dof%s(ic)- mesh%crosssection(ic)%surfaceareasum(m))/mesh%crosssection(ic)%surfacewidth(m)!(s-s_m)/w_m
               dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
                  (dof%s(ic) - s0 - mesh%crosssection(ic)%trapAreaSum(m))/mesh%crosssection(ic)%surfacewidth(m)!(s-s_m)/w_m
!                print *, "case3_1", ic, dof%h(ic)

            !Case 3_2 : w_m+1 != w_m (trapezium geometry)
            else 
               !h=H_m+hprime_m
               !hprime_m=-((w_m-square)/(w_{m+1}-w_m))*(H_{m+1}-H_m)
               ! with square = sqrt( w_m^2+2*((w_{m+1}-w_m)/(H_{m+1}-H_m))*(s-s_m))

! DEPRECATED
!                square=sqrt(mesh%crosssection(ic)%surfacewidth(m)**2+&                                  !sqrt(w_m^2+
!                   two*((mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m))/ & !2*((w_{m+1}-w_m)/
!                   (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m)))* &               !(H_{m+1}-H_m))*
!                   (dof%s(ic)- mesh%crosssection(ic)%surfaceareasum(m)))                                 !(s-s_m))
               square=sqrt(mesh%crosssection(ic)%surfacewidth(m)**2+&                                  !sqrt(w_m^2+
                  two*((mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m))/ & !2*((w_{m+1}-w_m)/
                  (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m)))* &               !(H_{m+1}-H_m))*
                  (dof%s(ic) - s0 - mesh%crosssection(ic)%trapAreaSum(m)))                                 !(s-s_m))

               !dof%h(ic)=mesh%crosssection(ic)%height(m)-mesh%crosssection(ic)%elevation-&               !H_m-
               dof%h(ic)=mesh%crosssection(ic)%height(m)-bathy_cell(ic)-&               !H_m-
                  (( mesh%crosssection(ic)%surfacewidth(m)-square)/&                                   !((w_m-square)/
                  (mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m)))* &   !(w_{m+1}-w_m))*
                  (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m))                   !(H_{m+1}-H_m)
!                print *, "case3_2", ic, dof%h(ic), dof%s(ic), mesh%crosssection(ic)%surfacewidth(m), mesh%crosssection(ic)%surfacewidth(m+1)
!                print *, "StoH:", StoH(mesh, ic, dof%S(ic))
!                print *, "bathy:", bathy_cell(ic), mesh%CrossSection(ic)%elevation
!                print *, "Z:", mesh%crosssection(ic)%height(:)
!                print *, "W:", mesh%crosssection(ic)%surfacewidth(:)
!                print *, "A:", mesh%crosssection(ic)%trapAreaSum(:) + s0
!                print *, "m=", m
               if (dof%h(ic) < -0.1_rp) then
                  print *, "dof%h(ic) < -0.1_rp", dof%h(ic), ic
                  stop 1
               end if
            endif

         end if
      end if

END SUBROUTINE SurfaceToHeightCrossSection

!> Determine all value of \f$m\f$ given cross-sections and a wet surface \f$s\f$.
!! \details Algorithm used:\n
!!  For each node \f$i\f$:
!!    - Find \f$m\f$ such that \f$s_i^{m-1}<=s_i<s_i^m\f$ 
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] dof Unknowns of the model.
!! \param[inout] mvector \f$m\f$ vector to update.
SUBROUTINE UpdateMVector(mesh,dof,mvector)
   USE m_mesh
   USE m_model
   USE m_common

   implicit none
   
   type( msh ), intent(in)  ::  mesh
   type( unk ), intent(in)  ::  dof
   integer(ip), dimension(mesh%ncs+4),intent(inout)  ::  mvector 
   
   real(rp) :: s0
   integer(ip):: ic

   do ic=1,mesh%ncs+4
      mvector(ic)=1
! DEPRECATED
!       do while ((mesh%crosssection(ic)%surfaceareasum(mvector(ic))&
!                .le.dof%s(ic)))!.or.(Flood)) ! while s_m < s   
!          mvector(ic)=mvector(ic)+1                                               ! m=m+1
!          if (mvector(ic) > size(mesh%crosssection(ic)%surfaceareasum)) exit
!       end do
      s0 = (mesh%crosssection(ic)%height(1) - bathy_cell(ic)) * mesh%crosssection(ic)%surfacewidth(1)
      do while ((mesh%crosssection(ic)%trapAreaSum(mvector(ic)) <= dof%s(ic) - s0)) ! while s_m < s   
         mvector(ic)=mvector(ic)+1                                               ! m=m+1
         if (mvector(ic) > size(mesh%crosssection(ic)%trapAreaSum)) exit
      end do
      mvector(ic)=mvector(ic)-1
   end do

END SUBROUTINE UpdateMVector


!> Determine the value of \f$m\f$ given a cross-section (mesh + index \f$i\f$ of the cross-section) and a wet surface \f$s\f$.
!! \details Algorithm used:\n
!!  For a node \f$i\f$:
!!    - Find \f$m\f$ such that \f$s_i^{m-1}<=s_i<s_i^m\f$ 
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] surface Wet surface.
!! \param[in] ic Index of the cross section.
!! \return \f$m\f$ update
integer(kind=ip) FUNCTION findMSurface(mesh,surface,ic)

   USE m_mesh
   USE m_model
   implicit none
   
   type( msh ), intent(in)  ::  mesh
   real(rp),intent(in) :: surface
   integer(ip),intent(in) ::ic
   
   real(rp) :: s0
   
   findMSurface=1

! DEPRECATED
! TODO : Modifier la condition pour eviter la boucle infinie (verifier que k surfaceareasum(k) existe)
!    do while ((mesh%crosssection(ic)%surfaceareasum(findMSurface).le.surface))!.or.(Flood)) ! while s_m < s 
!         findMSurface=findMSurface+1                                               ! m=m+1    
!         if (findMSurface > size(mesh%crosssection(ic)%surfaceareasum)) exit
!    end do
   s0 = (mesh%crosssection(ic)%height(1) - bathy_cell(ic)) * mesh%crosssection(ic)%surfacewidth(1)
   do while ((mesh%crosssection(ic)%trapAreaSum(findMSurface).le.surface - s0)) ! while s_m < s 
        findMSurface=findMSurface+1                                               ! m=m+1    
        if (findMSurface > size(mesh%crosssection(ic)%trapAreaSum)) exit
   end do
   findMSurface=findMSurface-1
END FUNCTION findMSurface


!> Determine the value of \f$m\f$ given a cross-section (mesh + index \f$i\f$ of the cross-section) and a wet surface \f$s\f$.
!! \details Algorithm used:\n
!!  For a node \f$i\f$:
!!    - Find \f$m\f$ such that \f$s_i^{m-1}<=s_i<s_i^m\f$ 
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] dof Unknowns of the model.
!! \param[in] ic Number of the cross section.
!! \param[inout] mvector \f$m\f$ update
SUBROUTINE UpdateMVectorElement(mesh,dof,ic,mvector)
   USE m_mesh
   USE m_model
   USE m_common

   implicit none
   
   type( msh ), intent(in)  ::  mesh
   type( unk ), intent(in)  ::  dof
   integer(ip), intent(in)  ::  ic
   integer(ip), dimension(mesh%ncs+4),intent(inout)  ::  mvector 
   
   real(rp) :: s0
   
   mvector(ic)=1
!    do while ((mesh%crosssection(ic)%surfaceareasum(mvector(ic))&
!       .le.dof%s(ic)))!.or.(Flood)) ! while s_m < s   
!       mvector(ic)=mvector(indexcrossSection)+1                                               ! m=m+1
!       if (mvector(ic) > size(mesh%crosssection(ic)%surfaceareasum)) exit
!    end do
   s0 = (mesh%crosssection(ic)%height(1) - bathy_cell(ic)) * mesh%crosssection(ic)%surfacewidth(1)
   do while ((mesh%crosssection(ic)%trapAreaSum(mvector(ic)) <= dof%s(ic) - s0)) ! while s_m < s   
      mvector(ic)=mvector(ic)+1                                               ! m=m+1
      if (mvector(ic) > size(mesh%crosssection(ic)%trapAreaSum)) exit
   end do
   mvector(ic)=mvector(ic)-1

END SUBROUTINE UpdateMVectorElement

!> Determine the value of \f$m\f$ given a cross-section (mesh + index \f$i\f$ of the cross-section) and a water height \f$h\f$.
!! \details Algorithm used:\n
!!  For a node \f$i\f$:
!!    - Find \f$m\f$ such that \f$h_i^{m-1}<=h_i<h_i^m\f$ 
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] height Water height.
!! \param[in] ic Number of the cross section.
!! \return \f$m\f$ update
integer(kind=ip) FUNCTION findMHeight(mesh,height,ic)
   USE m_mesh
   USE m_model

   implicit none
   
   type( msh ), intent(in)  ::  mesh
   real(rp),intent(in) :: height
   integer(ip),intent(in) ::ic
   
   real(rp) :: zb
   
   findMHeight=1

! TODO : Modifier la condition pour eviter la boucle infinie (verifier que k surfaceareasum(k) existe)
   !zb=mesh%crosssection(indexcrossSection)%elevation
   !zb=bathy_cell(indexcrossSection)
   do while (mesh%crosssection(ic)%Height(findMHeight).le.&
            (height+bathy_cell(ic))) ! while H_m < h 
      findMHeight=findMHeight+1                                                          ! m=m+1
      if (findMHeight > size(mesh%crosssection(ic)%Height)) exit
   end do
   findMHeight=findMHeight-1
END FUNCTION findMHeight


!> Update the unknown \f$h_i\f$ from cross section geometry,\f$m_i\f$ and \f$s_i\f$.
!! \details Algorithm used:\n
!!  if \f$s_i<=0\f$:
!!    - \f$h_i=0\f$ 
!!
!!  if \f$s_i<=s_i^0\f$:
!!    - \f$h_i=\frac{s_i}{w_i^0}\f$
!!
!!  if \f$s_i>S_i^0\f$:
!!    - Find \f$m\f$
!!    - if \f$w_i^{m+1}=w_i^{m}\f$:
!!       - \f$h_i=H_i^m-z_bi+h'\f$ with \f$h'= \frac{(s_i-s_i^m)}{w_i^m}\f$
!!    - else: 
!!       - \f$h_i=H_i^m-z_bi+h'\f$ with \f$h'=-\frac{w_i^m-A}{w_i^{m+1}-w_i^m}(H_i^{m+1}-H_i^m)\f$
!!       with \f$A = \sqrt{ (w_i^m)^2+2 \frac{w_i^{m+1}-w_i^m}{H_i^{m+1}-H_i^m}(s_i-s_i^m)}\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] ic  Number of the cross section.
!! \param[in] surface Water surface.
!! \return Value of the unknow \f$h\f$.
real (kind=rp) FUNCTION StoH( mesh,ic, surface )
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

   type( msh ), intent(in)     :: mesh
   integer(ip), intent(in)     :: ic
   real(rp), intent(in)     :: surface

   real(rp) :: s0
   real(rp) :: square
   integer(ip) :: m
   integer(ip) :: m_max
   integer(ip) :: findmSurface
      

      !Case 1 : s = 0 (no water) -> h = 0
      if ((surface.le.0.0_rp)) then 
            StoH=0.0_rp
      
      else 
   
         ! Compute s0
         s0 = (mesh%crosssection(ic)%height(1) - bathy_cell(ic)) * mesh%crosssection(ic)%surfacewidth(1)

         !Case 2 : Only rectangular area is wet (s<=s_0 or m =0)
         if (surface.le.s0) then
            StoH=surface/mesh%crosssection(ic)%surfacewidth(1) ! h= s/w_0

         !Case 3 : s> s_0 or m>0
         else
            m=findmSurface(mesh,surface,ic)!return m
            m_max = size(mesh%crosssection(ic)%surfacewidth)

            !Case 3_0 : if m > m_max (rectangular geometry)
            if (m >= m_max) then

! DEPRECATED
!                StoH=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
!                   (surface- mesh%crosssection(ic)%surfaceareasum(m_max))/mesh%crosssection(ic)%surfacewidth(m_max)!(s-s_m)/w_m
               StoH = mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
                     (surface - s0 - mesh%crosssection(ic)%trapAreaSum(m_max))/&
                     mesh%crosssection(ic)%surfacewidth(m_max)!(s-s_m)/w_m
            
            !Case 3_1 : if w_m+1=w_m (rectangular geometry)
            !if (mesh%crosssection(ic)%surfacewidth(m+1).eq.mesh%crosssection(ic)%surfacewidth(m)) then
            else if (abs(mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m)).le.(0.0000001)) then
               !h=H_m-z_b+hprime_m
               !hprime_m=(s-s_m)/w_m
               !dof%h(ic)=mesh%crosssection(ic)%height(m)-mesh%crosssection(ic)%elevation+&                  !h=H_m-z_b+
! DEPRECATED
!                StoH=mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
!                   (surface- mesh%crosssection(ic)%surfaceareasum(m))/mesh%crosssection(ic)%surfacewidth(m)!(s-s_m)/w_m
               StoH = mesh%crosssection(ic)%height(m)-bathy_cell(ic)+&                                   !h=H_m-z_b+
                      (surface - s0 - mesh%crosssection(ic)%trapAreaSum(m))/&
                      mesh%crosssection(ic)%surfacewidth(m)!(s-s_m)/w_m

            !Case 3_2 : w_m+1 != w_m (trapezium geometry)
            else 
               !h=H_m+hprime_m
               !hprime_m=-((w_m-square)/(w_{m+1}-w_m))*(H_{m+1}-H_m)
               ! with square = sqrt( w_m^2+2*((w_{m+1}-w_m)/(H_{m+1}-H_m))*(s-s_m))

! DEPRECATED
!                square=sqrt(mesh%crosssection(ic)%surfacewidth(m)**2+&                                  !sqrt(w_m^2+
!                   two*((mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m))/ & !2*((w_{m+1}-w_m)/
!                   (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m)))* &               !(H_{m+1}-H_m))*
!                   (surface- mesh%crosssection(ic)%surfaceareasum(m)))                                 !(s-s_m))
               square=sqrt(mesh%crosssection(ic)%surfacewidth(m)**2+&                                  !sqrt(w_m^2+
                  two*((mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m))/ & !2*((w_{m+1}-w_m)/
                  (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m)))* &               !(H_{m+1}-H_m))*
                  (surface - s0 - mesh%crosssection(ic)%trapAreaSum(m)))                                 !(s-s_m))

               !dof%h(ic)=mesh%crosssection(ic)%height(m)-mesh%crosssection(ic)%elevation-&               !H_m-
               StoH=mesh%crosssection(ic)%height(m)-bathy_cell(ic)-&               !H_m-
                  (( mesh%crosssection(ic)%surfacewidth(m)-square)/&                                   !((w_m-square)/
                  (mesh%crosssection(ic)%surfacewidth(m+1)-mesh%crosssection(ic)%surfacewidth(m)))* &   !(w_{m+1}-w_m))*
                  (mesh%crosssection(ic)%height(m+1)-mesh%crosssection(ic)%height(m))                   !(H_{m+1}-H_m)
            endif

         end if
      end if

END FUNCTION StoH



!> Return the value of the unknown \f$s\f$ from number of the cross section geometry \f$i\f$ and \f$h\f$ value.
!! \details Algorithm used:\n
!!  if \f$h<=0\f$:
!!    - \f$s=0\f$ 
!!
!!  if \f$h<=h_i^0\f$:
!!    - \f$s=h w_i^0\f$
!!
!!  if \f$h>h_i^0\f$:
!!    - Find \f$m\f$
!!    -\f$s=s_i^m+s'\f$ with \f$s'=\frac{1}{2}(2w_i^m+(\sqrt{(Pe1_i^m)^2-(H_i^{m+1}-H_i^{m})^2}+
!! \sqrt{(Pe2_i^m)^2-(H_i^{m+1}-H_i^{m})^2})(\frac{h+z_bi-H_i^m}{H_i^{m+1}-H_i^{m}}))(h+z_bi-H_i^m)\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] ic  Number of the cross section.
!! \param[in] height Water height.
!! \return Value of the unknow \f$s\f$.
real (kind=rp) FUNCTION HtoS( mesh,ic, height )
   USE m_mesh
   USE m_model
   implicit none

   type( msh ), intent(in)  ::  mesh
   integer(ip),intent(in) :: ic
   real(rp),intent(in) :: height

   integer(ip) :: findmHeight   
   integer(ip) :: m
   integer(ip) :: m_max
   real(rp) :: s0

   !Temporary variable
   real(rp) :: wmp1,wm     !Corresponding to W_{m}
   real(rp) :: Pe1m,Pe2m   !Corresponding to Pe1_{m} and Pe2_{m}
   real(rp) :: Hmp1,Hm     !Corresponding to H_{m+1} and H_{m}
   real(rp) :: zb          !Corresponding to z_b
   real(rp) :: ainterp     !Interpolation factor

   HtoS=0.0_rp

   !Case 1 : height lower than elevation
   !if (((height-mesh%crosssection(ic)%elevation).le.0.0_rp)) then
   if (height.le.0.0_rp) then 
         HtoS=0.0_rp
   
   else 
      !Case 2 : h< (H_0-z_b)
      !if (height.le.(mesh%crosssection(ic)%height(1)-mesh%crosssection(ic)%elevation)) then
      if (height.le.(mesh%crosssection(ic)%height(1)-bathy_cell(ic))) then
      
         HtoS=(height)*mesh%crosssection(ic)%surfacewidth(1) !S=h*w_0
!          print *, "case_2", HtoS
         
      else
      
         m=findmHeight(mesh,height,ic)
         m_max=size(mesh%crosssection(ic)%height)
   
         ! Compute s0
         s0 = (mesh%crosssection(ic)%height(1) - bathy_cell(ic)) * mesh%crosssection(ic)%surfacewidth(1)
!          print *, "S0", mesh%crosssection(ic)%height(1), bathy_cell(ic), mesh%crosssection(ic)%surfacewidth(1)

         !Case 3_0 : if m > m_max (rectangular geometry)
         if (m >= m_max) then
            Hm =mesh%crosssection(ic)%height(m_max)
            wm =mesh%crosssection(ic)%surfacewidth(m_max)
            zb =bathy_cell(ic)
            HtoS=mesh%crosssection(ic)%trapAreaSum(m_max) + s0 + (height+zb-Hm)*wm
!             print *, "case_3_0", HtoS, mesh%crosssection(ic)%trapAreaSum(m), s0
         !Case 3_1 : trapezoidal geometry
         else
! DEPRECATED
!             wm   =mesh%crosssection(ic)%surfacewidth(m)
!             Pe1m =mesh%CrossSection(ic)%perimeterp1(m+1)
!             Pe2m =mesh%CrossSection(ic)%perimeterp2(m+1)
!             Hm = mesh%crosssection(ic)%height(m)
!             Hmp1 = mesh%crosssection(ic)%height(m+1)
!             zb = bathy_cell(ic)
! 
!             HtoS =  mesh%crosssection(ic)%trapAreaSum(m) + s0 +   &
!                  demi*(height+zb-Hm)* &
!                  ( two*wm + ( sqrt(Pe1m**2-(Hmp1-Hm)**2) + sqrt(Pe2m**2-(Hmp1-Hm)**2) )*  &   
!                  ((height+zb-Hm)/(Hmp1-Hm)))
!             print *, "case_3_1", HtoS, mesh%crosssection(ic)%trapAreaSum(m), s0
            wm   =mesh%crosssection(ic)%surfacewidth(m)
            wmp1 =mesh%crosssection(ic)%surfacewidth(m+1)
!             dw = (height+zb-Hm)/(Hmp1-Hm) * (wmp1 + wm)
!             Pe1m =mesh%CrossSection(ic)%perimeterp1(m+1)
!             Pe2m =mesh%CrossSection(ic)%perimeterp2(m+1)
            Hm = mesh%crosssection(ic)%height(m)
            Hmp1 = mesh%crosssection(ic)%height(m+1)
            zb = bathy_cell(ic)

            HtoS =  mesh%crosssection(ic)%trapAreaSum(m) + s0 +   &
                    demi*(height+zb-Hm)*((height+zb-Hm)/(Hmp1-Hm)*(wmp1-wm)+two*wm)
!             print *, "case_3_1", HtoS, mesh%crosssection(ic)%trapAreaSum(m), s0
!             print *, "dw=", (height+zb-Hm)/(Hmp1-Hm) * (wmp1 - wm)
!             print *, "dz=", height+zb-Hm
!             print *, "w=", 0.5 * (wm + (height+zb-Hm)/(Hmp1-Hm) * (wmp1 - wm) + wm)
!             print *, "dA=", (height+zb-Hm) * 0.5 * (wm + (height+zb-Hm)/(Hmp1-Hm) * (wmp1 - wm) + wm)
            
          end if
      end if
   end if
END FUNCTION HtoS



!> Return interface value of water surface \f$s\f$ from water elevation \f$H=h+z_b\f$ defined to the interface. 
!! \details This function computes the value to the equivalent surface to the cell \f$i_l\f$ and \f$i_r\f$
!! and return the mean value.
!! \param[in] mesh  Mesh of the model.
!! \param[in] ic  Number of the cross section left \f$i_l\f$.
!! \param[in] icp  Number of the cross section right \f$i_r\f$.
!! \param[in] height Water elevation  \f$H=h+z_b\f$.
!! \return Value of the unknow \f$s\f$ to the interface between \f$i_l\f$ and \f$i_r\f$.
real (kind=rp) FUNCTION HtoSInterface( mesh,ic,icp, height )
   USE m_model
   USE m_common
   USE m_mesh
   type( msh ), intent(in)  ::  mesh
   integer(ip),intent(in) :: ic,icp
   real(rp), intent(in) :: height

   real(rp) :: HtoS  
   real(rp) :: slp,srp

   HtoSInterface=0.0_rp
   Slp=HtoS(mesh,ic ,height-bathy_cell(ic))
   Srp=HtoS(mesh,icp,height-bathy_cell(icp))
   HtoSInterface=0.5_rp*(srp+slp)
END FUNCTION HtoSInterface


!> Return interface value of water surface \f$s\f$ from water surface defined to the interface. 
!! \details This function computes the value to the equivalent surface to the cell \f$i_l\f$ and \f$i_r\f$
!! and return the mean value.
!! \param[in] mesh  Mesh of the model.
!! \param[in] ic  Number of the cross section left \f$i_l\f$.
!! \param[in] icp  Number of the cross section right \f$i_r\f$.
!! \param[in] height Water height  \f$h\f$.
!! \return Value of the unknow \f$s\f$ to the interface between \f$i_l\f$ and \f$i_r\f$.
real (kind=rp) FUNCTION HtoSInterface_h( mesh,ic,icp, height )
   USE m_model
   USE m_common
   USE m_mesh
   type( msh ), intent(in)  ::  mesh
   integer(ip),intent(in) :: ic,icp
   real(rp), intent(in) :: height

   real(rp) :: HtoS  
   real(rp) :: slp,srp

   Slp=HtoS(mesh,ic ,height)
   Srp=HtoS(mesh,icp,height)
   HtoSInterface_h=0.5_rp*(srp+slp)

END FUNCTION HtoSInterface_h


!> Return the index \f$i\f$ of the cross section the nearest of a point \f$(x,y)\f$.
!! \details This function return the index \f$i\f$ of the cross section the nearest of a point \f$(x,y)\f$.
!! For all points of mesh, the function computes the distance with reference points and return the index of the 
!! the point with the lowest distance value.
!! \param[in] mesh  Mesh of the model.
!! \param[in] point   \f$(x,y)\f$ point to compare.
!! \return Index \f$i\f$ of the cross section the nearest of the point \f$(x,y)\f$.
FUNCTION search_nearest_cross_section( mesh , point ) RESULT( indexi )

   USE m_mesh
   implicit none

   type( msh ), intent(in)  ::  mesh
   type( vec2d ), intent(in)  ::  point

   integer(ip)  ::  indexi , temp_indexi
   real(rp)    :: xL,yL,xR,yR
   real(rp)    :: distanceTemp,distance

   indexi = -1

   distance=hugem

   do temp_indexi = 3,mesh%ncs+2

      xL=point%x
      yL=point%y
      xR=mesh%CrossSection(temp_indexi)%coord%x
      yR=mesh%CrossSection(temp_indexi)%coord%y
      distanceTemp=sqrt((xR-xL)**2+(yR-yL)**2) !Compute the distance with the point

      
      if (distanceTemp.le.0._rp) then !If point=mesh%crosssection(i)%coord 
         indexi=temp_indexi           !   so index =i and exit function
         exit

      else if (distanceTemp.le.distance) then !If distance < distanceTemp
         distance=distanceTemp                ! Get new distanceTemp
         indexi=temp_indexi                   ! Get index i

      endif

   end do

END FUNCTION search_nearest_cross_section


!> Return the value of \f$w\f$ (water surface width) from mesh, water height \f$h\f$ and index of cross-section \f$i\f$.
!! \details This function return the index \f$i\f$ of the cross section the nearest of a point \f$(x,y)\f$.
!! For all points of mesh, the function computes the distance with reference points and return the index of the 
!! the point with the lowest distance value.
!! \details Algorithm used:\n
!!  if \f$h<=0\f$:
!!    - \f$w=w_i^0\f$ 
!!
!!  if \f$h<=h_i^0\f$:
!!    - \f$w=w_i^0\f$ 
!!
!!  if \f$h>h_i^0\f$:
!!    - Find \f$m\f$
!!    - \f$w=w_i^m+\alpha_1(h+z_bi-H_i^m)+\alpha_2(h+z_bi-H_i^m)\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] height Water height \f$h\f$.
!! \param[in] indexie Indexe \f$i\f$ of the cross section considerated.
!! \return The value of \f$w\f$ (water surface width)
Function GetWFromH(mesh,height,indexie) result (width)
   USE m_mesh
   USE m_model
   implicit none

   type( msh ), intent(in)  ::  mesh
   real(rp), intent (in) :: height
   integer(ip), intent (in) :: indexie


   integer(ip) :: findmHeight   
   integer(ip) :: m
   integer(ip) :: m_max
   real(rp) :: width,wm,alpha1,alpha2,Hm,zb

   !Case 1 : height lower than elevation
   if (height.le.0.0_rp) then 
         width=mesh%crosssection(indexie)%surfacewidth(1)
         
         if (width < 1e-12_rp) then
            print *, "WRONG WIDTH (case 1)", width
         end if
   
   else 
      !Case 2 : h< (H_0-z_b)
      if (height.le.(mesh%crosssection(indexie)%height(1)-bathy_cell(indexie))) then
         width= mesh%crosssection(indexie)%surfacewidth(1) !w=w_0
         
         if (width < 1e-12_rp) then
            print *, "WRONG WIDTH (case 2)", width
         end if

      !Case 3 : s> s_0 or m>0
      else
         m=findmHeight(mesh,height,indexie)
         m_max = size(mesh%crosssection(indexie)%surfacewidth)
         
         !Case 3_0 : if m > m_max (rectangular geometry)
         if (m >= m_max) then
            wm =mesh%crosssection(indexie)%surfacewidth(m)
            width=wm
            if (width < 1e-12_rp) then
                print *, "WRONG WIDTH (case 3-0)", width
                print *, "**indexie=", indexie
            end if
         !Case 3_1 and 3_2 : if m < m_max
         else
            !w=w_{m}+alpha1(H_{m}-h)+ alpha2(H_{m}-h)
            wm    =mesh%crosssection(indexie)%surfacewidth(m)
            alpha1=mesh%CrossSection(indexie)%alpha1(m+1)
            alpha2=mesh%CrossSection(indexie)%alpha2(m+1)
            Hm    =mesh%crosssection(indexie)%height(m)
            !zb    =mesh%CrossSection(indexie)%elevation
            zb    =bathy_cell(indexie)
            
            width=wm+alpha1*(height+zb-Hm)+alpha2*(height+zb-Hm)
            if (width < 1e-12_rp) then
                print *, "WRONG WIDTH (case 3-1)", width
                print *, "**indexie=", indexie
                print *, "**alpha=", alpha1, alpha2
                print *, "**wm,Hm=", wm, Hm
                print *, "**height+zb-Hm=", height+zb-Hm
            end if
         end if
      end if
   end if


end function GetWFromH


!> Return the value of perimeter \f$pe\f$ from mesh, water height \f$h\f$ and index of cross-section \f$i\f$.
!! \details 
!! Algorithm used:\n
!!  if \f$h<=0\f$:
!!    - \f$pe=0\f$ 
!!
!!  if \f$h<=h_i^0\f$:
!!    - \f$pe=w_i^0+2h\f$ 
!!
!!  if \f$h>h_i^0\f$:
!!    - Find \f$m\f$
!!    - \f$pe=pe_i^m+\sqrt{(\frac{w_i^{m+1}}{2}-(\frac{1}{2}w_i^{m}-y_i^{m}))^2+(H_i^{m+1}-H_i^{m})^2}
!!\frac{(h_i+z_bi-H_i^m)}{H_i^{m+1}-H_i^m}+\sqrt{(\frac{w_i^{m+1}}{2}-(\frac{1}{2}w_i^{m}+y_i^{m}))^2+(H_i^{m+1}-H_i^{m})^2}
!!\frac{(h_i+z_bi-H_i^m)}{H_i^{m+1}-H_i^m}\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] height Water height \f$h\f$.
!! \param[in] indexie Indexe \f$i\f$ of the cross section considerated.
!! \param[in] mvector Vector \f$m\f$.
!! \return The value of \f$pe\f$ (perimeter)
Function PerimeterFromH(mesh,height,indexie,mvector) result (perimeter)
   USE m_mesh
   USE m_model
   implicit none

   type( msh ), intent(in)  ::  mesh
   real(rp), intent (in) :: height
   integer(ip), intent (in) :: indexie
   integer(ip), dimension(mesh%ncs+4),intent(in)  ::  mvector 

   real(rp) :: perimeter0
   integer(ip) :: m, m_max
   real(rp) :: perimeter,wm,wmp1,ym,Hm,HmP1,zb

   !Case 1 : height lower than elevation
   if (height.le.0.0_rp) then 
         perimeter=0._rp
   
   else 
      !Case 2 : h< (H_0-z_b)
      if (height.le.(mesh%crosssection(indexie)%height(1)-bathy_cell(indexie))) then

         perimeter= two*(height)+mesh%crosssection(indexie)%surfacewidth(1) !pe=w_0+2*h
         
      else
         m=mvector(indexie)
         m_max=size(mesh%crosssection(indexie)%surfacewidth)
         
         ! Compute perimeter0
         perimeter0 = two * (mesh%crosssection(indexie)%height(1)-bathy_cell(indexie)) + &
                      mesh%crosssection(indexie)%surfacewidth(1)
         
         
         if (m==m_max) then
            Hm    =mesh%crosssection(indexie)%height(m)
            zb    =bathy_cell(indexie)
! DEPRECATED
!             perimeter=mesh%crosssection(indexie)%perimeterSum(m)
            perimeter=mesh%crosssection(indexie)%trapPerimSum(m) + perimeter0
            perimeter=perimeter+2.0 * (height+zb-Hm)
         else
            wm    =mesh%crosssection(indexie)%surfacewidth(m)
            wmp1  =mesh%crosssection(indexie)%surfacewidth(m+1)
            ym    =mesh%crosssection(indexie)%y(m)-mesh%crosssection(indexie)%y(m+1)
            Hm    =mesh%crosssection(indexie)%height(m)
            HmP1  =mesh%crosssection(indexie)%height(m+1)
            !zb    =mesh%crosssection(indexie)%elevation
            zb    =bathy_cell(indexie)
! DEPRECATED
            !             perimeter=mesh%crosssection(indexie)%perimeterSum(m)

            perimeter=mesh%crosssection(indexie)%trapPerimSum(m) + perimeter0

            !See doc Pe(h)
            perimeter=perimeter+&
                      sqrt((demi*wmp1-(demi*wm-ym))**2+(Hmp1-hm)**2)*((height+zb-Hm)/(Hmp1-Hm))+&
                      sqrt((demi*wmp1-(demi*wm+ym))**2+(Hmp1-hm)**2)*((height+zb-Hm)/(Hmp1-Hm))
         end if
         !<NOADJ
!           if (perimeter < 1e-12) then
! 
!             print *, "perimeter <= 0"
!             print *, indexie, m, mesh%crosssection(indexie)%trapPerimSum(m), perimeter0
!             print *, height + zb, Hm
!             print *, mesh%crosssection(indexie)%height(1:m)
!             read(*,*)
!             
!           end if
         !>NOADJ
         
      end if
   end if

end function PerimeterFromH


!> Return the value of perimeter \f$pe\f$ from mesh, water height \f$h\f$ and index of cross-section \f$i\f$.
!! \details 
!! Algorithm used:\n
!!  if \f$h<=0\f$:
!!    - \f$pe=0\f$ 
!!
!!  if \f$h<=h_i^0\f$:
!!    - \f$pe=w_i^0+2h\f$ 
!!
!!  if \f$h>h_i^0\f$:
!!    - Find \f$m\f$
!!    - \f$pe=pe_i^m+\sqrt{(\frac{w_i^{m+1}}{2}-(\frac{1}{2}w_i^{m}-y_i^{m}))^2+(H_i^{m+1}-H_i^{m})^2}
!!\frac{(h_i+z_bi-H_i^m)}{H_i^{m+1}-H_i^m}+\sqrt{(\frac{w_i^{m+1}}{2}-(\frac{1}{2}w_i^{m}+y_i^{m}))^2+(H_i^{m+1}-H_i^{m})^2}
!!\frac{(h_i+z_bi-H_i^m)}{H_i^{m+1}-H_i^m}\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] height Water height \f$h\f$.
!! \param[in] indexie Indexe \f$i\f$ of the cross section considerated.
!! \param[in] mvector Vector \f$m\f$.
!! \return The value of \f$pe\f$ (perimeter)
subroutine Perimeters3FromH(mesh,height,indexie,mvector, perimeters)
   USE m_mesh
   USE m_model
   implicit none

   type( msh ), intent(in)  ::  mesh
   real(rp), intent (in) :: height
   integer(ip), intent (in) :: indexie
   integer(ip), dimension(mesh%ncs+4),intent(in)  ::  mvector 

   real(rp) :: perimeter0
   integer(ip) :: m, m_max
   real(rp) :: perimeter,wm,wmp1,ym,Hm,HmP1,zb
   real(rp), dimension(3) :: perimeters

   !Case 1 : height lower than elevation
   if (height.le.0.0_rp) then 
         perimeters(:)=0._rp
   
   else 
      !Case 2 : h< (H_0-z_b)
      if (height.le.(mesh%crosssection(indexie)%height(1)-bathy_cell(indexie))) then

         perimeters(1)= two*(height)+mesh%crosssection(indexie)%surfacewidth(1) !pe=w_0+2*h
         perimeters(2:3) = 0.0
         
      else
         m=mvector(indexie)
         m_max=size(mesh%crosssection(indexie)%surfacewidth)
         
         ! Compute perimeter0
         perimeter0 = two * (mesh%crosssection(indexie)%height(1)-bathy_cell(indexie)) + &
                      mesh%crosssection(indexie)%surfacewidth(1)
         
         
         if (m==m_max) then
            Hm    =mesh%crosssection(indexie)%height(m)
            zb    =bathy_cell(indexie)
! DEPRECATED
!             perimeter=mesh%crosssection(indexie)%perimeterSum(m)
!             perimeter=mesh%crosssection(indexie)%trapPerimSum(m) + perimeter0
!             perimeter=perimeter+2.0 * (height+zb-Hm)
            perimeters(1) = perimeter0 + mesh%crosssection(indexie)%trapPerimSum(2)
            perimeters(2) = mesh%crosssection(indexie)%trapPerimSum(3) - mesh%crosssection(indexie)%trapPerimSum(2)
            perimeters(3) = mesh%crosssection(indexie)%trapPerimSum(4) - mesh%crosssection(indexie)%trapPerimSum(3) + &
                            2.0 * (height+zb-Hm)
            
         else
         
            wm    =mesh%crosssection(indexie)%surfacewidth(m)
            wmp1  =mesh%crosssection(indexie)%surfacewidth(m+1)
            ym    =mesh%crosssection(indexie)%y(m)-mesh%crosssection(indexie)%y(m+1)
            Hm    =mesh%crosssection(indexie)%height(m)
            HmP1  =mesh%crosssection(indexie)%height(m+1)
            zb    =bathy_cell(indexie)
            
            if (m == 1) then
               perimeters(1) = perimeter0 + mesh%crosssection(indexie)%trapPerimSum(1) + &
                               sqrt((demi*wmp1-(demi*wm-ym))**2+(Hmp1-hm)**2)*((height+zb-Hm)/(Hmp1-Hm))+&
                               sqrt((demi*wmp1-(demi*wm+ym))**2+(Hmp1-hm)**2)*((height+zb-Hm)/(Hmp1-Hm))
            else if (m == 2) then
            
               perimeters(1) = perimeter0 + mesh%crosssection(indexie)%trapPerimSum(2)
               perimeters(2) = sqrt((demi*wmp1-(demi*wm-ym))**2+(Hmp1-hm)**2)*((height+zb-Hm)/(Hmp1-Hm))+&
                               sqrt((demi*wmp1-(demi*wm+ym))**2+(Hmp1-hm)**2)*((height+zb-Hm)/(Hmp1-Hm))
               perimeters(3) = 0.0_rp
               
            else
            
               perimeters(1) = perimeter0 + mesh%crosssection(indexie)%trapPerimSum(2)
               perimeters(2) = mesh%crosssection(indexie)%trapPerimSum(3) - mesh%crosssection(indexie)%trapPerimSum(2)
               perimeters(3) = sqrt((demi*wmp1-(demi*wm-ym))**2+(Hmp1-hm)**2)*((height+zb-Hm)/(Hmp1-Hm))+&
                               sqrt((demi*wmp1-(demi*wm+ym))**2+(Hmp1-hm)**2)*((height+zb-Hm)/(Hmp1-Hm))
                               
            end if
            
         end if
         
      end if
   end if

end subroutine Perimeters3FromH


!> Return the value of \f$\frac{\partial w}{\partial Z}\f$ from mesh, water height \f$h\f$ and index of cross-section \f$i\f$.
!! \details 
!! \details Algorithm used: TO DO\n
!!  if \f$h<=0\f$:
!!    - \f$w=w_i^0\f$ 
!!
!!  if \f$h<=h_i^0\f$:
!!    - \f$w=w_i^0\f$ 
!!
!!  if \f$h>h_i^0\f$:
!!    - Find \f$m\f$
!!    - \f$w=w_i^m+\alpha_1(h+z_bi-H_i^m)+\alpha_2(h+z_bi-H_i^m)\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] height Water height \f$h\f$.
!! \param[in] indexie Indexe \f$i\f$ of the cross section considerated.
!! \return The value of \f$\frac{\partial w}{\partial Z}\f$ (derivative of the width with respect to the elevation)
Function dWdZFromH(mesh,height,indexie) result (dWdZ)
  USE m_mesh
  USE m_model
  implicit none

  type( msh ), intent(in)  ::  mesh
  real(rp), intent (in) :: height
  integer(ip), intent (in) :: indexie
  
  integer(ip) :: findmHeight   
  integer(ip) :: m
  integer(ip) :: m_max
  real(rp) :: alpha1,alpha2
  real(rp) :: dWdZ

  !Case 1 : h <= H0
  if (height.le.(mesh%crosssection(indexie)%height(1)-bathy_cell(indexie))) then 
     dWdZ = 0._rp
     
  !Case 2 : h > H0
  else 
     m=findmHeight(mesh,height,indexie)
     m_max = size(mesh%crosssection(indexie)%surfacewidth)
     
     !Case 2_0 : if m > m_max (rectangular geometry)
     if (m >= m_max) then
        dWdZ = 0._rp
     !Case 2_1
     else
        alpha1=mesh%CrossSection(indexie)%alpha1(m+1)
        alpha2=mesh%CrossSection(indexie)%alpha2(m+1)
        dWdZ = alpha1 + alpha2
     end if

  end if

 end function dWdZFromH




!> Return the value of \f$\frac{\partial pe}{\partial Z}\f$ from mesh, water height \f$h\f$ and index of cross-section \f$i\f$.
!! \details 
!! Algorithm used:\n TODO
!!  if \f$h<=0\f$:
!!    - \f$pe=0\f$ 
!!
!!  if \f$h<=h_i^0\f$:
!!    - \f$pe=w_i^0+2h\f$ 
!!
!!  if \f$h>h_i^0\f$:
!!    - Find \f$m\f$
!!    - \f$pe=pe_i^m+\sqrt{(\frac{w_i^{m+1}}{2}-(\frac{1}{2}w_i^{m}-y_i^{m}))^2+(H_i^{m+1}-H_i^{m})^2}
!!\frac{(h_i+z_bi-H_i^m)}{H_i^{m+1}-H_i^m}+\sqrt{(\frac{w_i^{m+1}}{2}-(\frac{1}{2}w_i^{m}+y_i^{m}))^2+(H_i^{m+1}-H_i^{m})^2}
!!\frac{(h_i+z_bi-H_i^m)}{H_i^{m+1}-H_i^m}\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] height Water height \f$h\f$.
!! \param[in] indexie Indexe \f$i\f$ of the cross section considerated.
!! \param[in] mvector Vector \f$m\f$.
!! \return The value of \f$pe\f$ (perimeter)
Function dPdZFromH(mesh,height,indexie,mvector) result (dPdZ)
   USE m_mesh
   USE m_model
   implicit none

   type( msh ), intent(in)  ::  mesh
   real(rp), intent (in) :: height
   integer(ip), intent (in) :: indexie
   integer(ip), dimension(mesh%ncs+4),intent(in)  ::  mvector 


   integer(ip) :: m, m_max
   real(rp) :: dPdZ,wm,wmp1,ym,Hm,HmP1

   !Case 1 : height lower than elevation
   if (height.le.0.0_rp) then 
         dPdZ = 0._rp
   
   else 
      !Case 2 : h< (H_0-z_b)
      if (height.lt.(mesh%crosssection(indexie)%height(1)-bathy_cell(indexie))) then
         dPdZ = 2.0_rp
         
      else
         m=mvector(indexie)
         m_max=size(mesh%crosssection(indexie)%surfacewidth)
         
         if (m==m_max) then
            dPdZ = 2.0_rp
         else
            wm    =mesh%crosssection(indexie)%surfacewidth(m)
            wmp1  =mesh%crosssection(indexie)%surfacewidth(m+1)
            ym    =mesh%crosssection(indexie)%y(m)-mesh%crosssection(indexie)%y(m+1)
            Hm    =mesh%crosssection(indexie)%height(m)
            HmP1  =mesh%crosssection(indexie)%height(m+1)

            !See doc Pe(h)
            dPdZ = two * sqrt((demi*wmp1-(demi*wm-ym))**2+(Hmp1-hm)**2) / (Hmp1-Hm)
                      
         end if
      end if
   end if


 end function dPdZFromH



 

!> Return the distance between two points \f$(x_l,y_l)\f$ and \f$(x_r,y_r)\f$.
!! \details 
!! Compute the distance \f$d\f$  between this two points ( \f$d=\sqrt{(x_r-x_l)^2+(y_r-y_l)^2}\f$)
!! \param[in] xl Coordinate \f$x\f$ of the first point.
!! \param[in] yl Coordinate \f$y\f$ of the first point.
!! \param[in] xr Coordinate \f$x\f$ of the second point.
!! \param[in] yr Coordinate \f$y\f$ of the second point.
!! \return Distance between the two points \f$(x_l,y_l)\f$ and \f$(x_r,y_r)\f$.
Function distanceBetweenToPoint(xL,yL,xR,yR) result (distance)
   USE m_mesh
   implicit none

   real(rp), intent (in) :: xL,yL,xR,yR
   real(rp) :: distance 
   distance=sqrt((xR-xL)**2+(yR-yL)**2)
end function distanceBetweenToPoint



