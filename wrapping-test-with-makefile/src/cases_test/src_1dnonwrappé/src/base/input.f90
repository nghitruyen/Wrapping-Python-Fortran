!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file input.f90
!! \brief This file includes subroutine which read DassFlow mesh file and input.txt.
!! \details The subroutine considerates in this file are read_input(), mesh_input() and read_dass_mesh().

! #define KH_FULLY_DISTRIBUTED


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Read Input Variables ( Reading input.txt and Filling namelist )
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Read input variables (reading input.txt and filling namelist ). 
!!
!! \details This subroutines read the input.txt file and keep input.txt value in the namelist.
!! 
SUBROUTINE Read_Input()

   #if defined USE_SW_MONO || USE_SW_MULTI || USE_NS_MULTIFLUID

      USE m_model

   #else

      USE m_user_test

   #endif

   implicit none

   !===================================================================================================================!
   !
   !===================================================================================================================!

   call Default_values

   !===================================================================================================================!
   !
   !===================================================================================================================!

   call Print_Screen('read_input')


   write(buffer,'(A)') "sed -e '/^!/d;/^$/d;s/!.*//g;s/[ \t]//g' input.txt > input.post"

   call system( buffer )

   open(10,file='input.post',form='formatted',status='old')

   read(10,nml=list_input)

   close(10)
   
   ! BACKWARD COMPATIBILITY
   if (len_trim(regul_type) > 0) then
      if (regul_type == "iterative") then
         print *, "[ WARNING ] regul_type='iterative' in input.txt is deprecated."
         print *, "            Use 'var_chg=True' instead"
         var_chg = .true.
      else
         write(*,*) "[ ERROR ] regul_type must be 'iterative' in input.txt for backward compatibility"
         stop
      end if
   end if
   
   if (alpha > -9999.0_rp) then
      print *, "[ WARNING ] alpha and beta for Strickler in input.txt is deprecated."
      print *, "            Use file 'strickler_params.txt' instead"
   end if
      
   
END SUBROUTINE



 !**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Read parameters defining the Strickler coefficient
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Read parameters defining the Strickler coefficient
!!
!! \details This subroutine reads the manning_params.txt file and fills the K_params variable
 !!
 SUBROUTINE read_strickler_params(mesh)
   USE m_model
   USE m_mesh
   USE m_common
   
   implicit none

   type( msh ), intent(in)  ::  mesh
   type( vec2d )  ::  pt_s, pt_e
   integer(ip) :: search_nearest_cross_section
   real(rp) :: alphaK, betaK
   integer(ip) :: cs_save


   inquire( file = 'strickler_params.txt' , exist = file_exist(1) )
   
   if ( file_exist(1) ) then
      open(10,file='strickler_params.txt',status='old')
      read(10,*)   ! comment
      read(10,*) K_params%nb_diff_K_reachs ! nb of reachs with differents Manning parameters
      i = K_params%nb_diff_K_reachs
      read(10,*)   ! comment
      read(10,*) K_params%nb_K_params  ! nb of parameters defining the Strickler coeff K
      if( K_model == 'K(h)' ) then
         allocate(K_params%alpha(mesh%ncs+4))
         allocate(K_params%beta(mesh%ncs+4))
      else if( K_model == 'Einstein3' ) then
         allocate(K_params%coeffs(3, mesh%ncs+4))
      end if
      allocate(K_params%cs_start(i))
      allocate(K_params%cs_end(i))
      read(10,*)   ! comment
      ! read params
      cs_save = 0
      do j = 1,i
         read(10,*) pt_s%x, pt_s%y, pt_e%x, pt_e%y, alphaK, betaK ! a voir si faut mettre un if pour alpha, beta ???
         ! Get cross-sections indexes corresponding to the (x,y) points
         K_params%cs_start(j) = search_nearest_cross_section( mesh , pt_s )
         if (cs_save == K_params%cs_start(j)) K_params%cs_start(j) = K_params%cs_start(j) + 1
         K_params%cs_end(j) = search_nearest_cross_section( mesh , pt_e )
         cs_save = K_params%cs_end(j)
         if( K_model == 'K(h)' ) then
            K_params%alpha(K_params%cs_start(j)) = alphaK
            K_params%beta(K_params%cs_start(j)) = betaK
         end if
      end do

      close(10)
      
   else
   
      if (alpha < -9999.0_rp + 1e-2) then
      
         write(*,*) "[ ERROR ] file 'strickler_params.txt' not found"
         stop
        
      end if
      if( K_model == 'K(h)' ) then
         allocate(K_params%alpha(mesh%ncs+4))
         allocate(K_params%beta(mesh%ncs+4))
      end if
      
#ifdef KH_FULLY_DISTRIBUTED
      allocate(K_params%cs_start(mesh%ncs))
      allocate(K_params%cs_end(mesh%ncs))
      K_params%nb_diff_K_reachs = mesh%ncs
      do i = 1, mesh%ncs
        K_params%cs_start(i) = 2 + i
        K_params%cs_end(i) = 2 + i
        K_params%alpha(K_params%cs_start(i)) = alpha
        K_params%beta(K_params%cs_start(i)) = beta
      end do
#else
      allocate(K_params%cs_start(1))
      allocate(K_params%cs_end(1))
      
      K_params%nb_diff_K_reachs = 1
      K_params%cs_start(1) = 3
      K_params%cs_end(1) = mesh%ncs+2
      K_params%alpha(K_params%cs_start(1)) = alpha
      K_params%beta(K_params%cs_start(1)) = beta
#endif
      
   end if

 END SUBROUTINE read_strickler_params


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main Mesh Creation Subroutine
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Main mesh creation Subroutine. 
!!
!! \details This subroutine read mesh defined by user (only Dassflow format avaible for this time).
!! \param[inout] mesh Mesh of the model.
SUBROUTINE Mesh_Input( mesh )

   USE m_common
   USE m_mesh
   USE m_time_screen

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(inout)  ::  mesh

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!

   integer :: status

!======================================================================================================================!
!  Calling appropriate Subroutine
!======================================================================================================================!
   
   call Read_Dass_Mesh( mesh, status )
   if (status /= 0) then
      print *, "[ ERROR ] Errors detected in mesh"
      stop
   end if



END SUBROUTINE Mesh_Input


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Mesh reader in Dassflow format
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!


!> Mesh reader in Dassflow format
!!
!! \details This subroutine read mesh defined by user  in the Dassflow format.
!! \param[inout] mesh Mesh of the model.
SUBROUTINE Read_Dass_Mesh( mesh, status )

   USE m_common
   USE m_mesh
   USE m_model
   USE m_time_screen

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   type( msh ), intent(out)  ::  mesh
   integer :: status

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   integer(ip)  ::  neighb(4) , n1 , n2 , nc_bc , nb_grp_in , nb_grp_out , num_grp , bc_number, nc_to_read

   real(rp)  ::  ghost_cell_bathy
   real(rp)  ::  last_slope

   character(6)  ::  bc_type

   !===================================================================================================================!
   !  Begin Subroutine
   !===================================================================================================================!

   status = 0
   
   call Print_Screen( 'start_mesh' )

   if ((addPointsW.ne.0).or.(addPointsE.ne.0).or.(remesh.ne.0)) then
      mesh%file_name=trim(mesh_name)//'_used'
   else
      mesh%file_name = mesh_name
   endif

  
   open(10,file=mesh%file_name,status='old')

   !===================================================================================================================!
   !  Reading header
   !===================================================================================================================!

   read(10,*)  !Read first line (comment)
   read(10,*) mesh%ncs , mesh%scal

   allocate( mesh%CrossSection( mesh%ncs+4 ) )
   allocate( bathy_cell( mesh%ncs+4 ) )
   allocate( tflux1(mesh%ncs+4))
   allocate( tflux2(mesh%ncs+4))
   tflux1(:) = 0._rp
   tflux2(:) = 0._rp


   !===================================================================================================================!
   !  Reading cross section 
   !===================================================================================================================!

   read(10,*)
   do i = 1,mesh%ncs
      !Get Cross-section definition
      read(10,*)  k ,&                                   ! Number of Cross section
                  mesh%CrossSection(k+2)%coord%x , &     ! Coordinates x 
                  mesh%CrossSection(k+2)%coord%y , &     ! Coordinates y
                  mesh%CrossSection(k+2)%elevation, &    ! Elevation
                  mesh%CrossSection(k+2)%nc              ! Number of triple

      if (crosssection_extrapolation == "constant") then
         nc_to_read = mesh%CrossSection(k+2)%nc
      else if (crosssection_extrapolation == "linear") then
         mesh%CrossSection(k+2)%nc=mesh%CrossSection(k+2)%nc+1
         nc_to_read = mesh%CrossSection(k+2)%nc-1
      else if (crosssection_extrapolation == "linear_builtin1") then
         mesh%CrossSection(k+2)%nc=mesh%CrossSection(k+2)%nc+1
         nc_to_read = mesh%CrossSection(k+2)%nc-1
      else
         write(*,*) "[ ERROR ] 'crosssection_extrapolation' must be 'constant' or 'linear1'"
         status = -1
      end if
      allocate(mesh%CrossSection(k+2)%height(mesh%CrossSection(k+2)%nc))         ! Allocate height
      allocate(mesh%CrossSection(k+2)%surfacewidth(mesh%CrossSection(k+2)%nc))   ! Allocate surfaceWidth
      allocate(mesh%CrossSection(k+2)%y(mesh%CrossSection(k+2)%nc))              ! Allocate gap

      !Get triplet ( Height, Surface width and gap)
      do j=1,nc_to_read
         read(10,*)  mesh%CrossSection(k+2)%height(j),&           !Height
                     mesh%CrossSection(k+2)%surfacewidth(j),&     !Surface width
                     mesh%CrossSection(k+2)%y(j)                  !Gap
                     
         !=============================================================================================================!
         ! CHECK-UP : Ensure that surfce width is positive
         !=============================================================================================================!
         if (mesh%CrossSection(k+2)%surfacewidth(j) < 1e-12_rp) then
             write(*,*) '[ ERROR ] width ', j, 'for crosssection ', k, 'is negative or zero'
             status = -2
          end if
                     
         !=============================================================================================================!
         ! CHECK-UP : Ensure that elevation are in increasing order
         !=============================================================================================================!
         if (j == 1) then
            if (mesh%CrossSection(k+2)%height(j) < mesh%CrossSection(k+2)%elevation + 1e-12) then
              write(*,*) '[ ERROR ] height ', j, 'for crosssection ', k, 'is lower than or equal to bottom elevation'
              status = -3
            end if
         else
            if (mesh%CrossSection(k+2)%height(j) < mesh%CrossSection(k+2)%height(j-1) + 1e-12) then
              write(*,*) '[ ERROR ] height ', j, 'for crosssection ', k, 'is lower than or equal to previous elevation'
              status = -3
            end if
         end if
      end do

      j=mesh%CrossSection(k+2)%nc
      if (crosssection_extrapolation == "linear") then
         mesh%CrossSection(k+2)%height(j)=mesh%CrossSection(k+2)%height(j-1)+100._rp
         last_slope = (mesh%CrossSection(k+2)%surfacewidth(j-1) - mesh%CrossSection(k+2)%surfacewidth(j-2)) / &
                      (mesh%CrossSection(k+2)%height(j-1) - mesh%CrossSection(k+2)%height(j-2))
         mesh%CrossSection(k+2)%surfacewidth(j) = mesh%CrossSection(k+2)%surfacewidth(j-1) + 100._rp * last_slope
         mesh%CrossSection(k+2)%y(j)=mesh%CrossSection(k+2)%y(j-1)
      else if (crosssection_extrapolation == "linear_builtin1") then
         mesh%CrossSection(k+2)%height(j)=mesh%CrossSection(k+2)%height(j-1)+100._rp
         mesh%CrossSection(k+2)%surfacewidth(j)=mesh%CrossSection(k+2)%surfacewidth(j-1)+100000._rp
         mesh%CrossSection(k+2)%y(j)=mesh%CrossSection(k+2)%y(j-1)
      end if

   end do

   !Set gap 1 to 0
   mesh%CrossSection(3)%y(1)=zero


   !Fill gost cell (W_boundary)
   do i=1,2
      mesh%CrossSection(i)%coord%x  =mesh%CrossSection(3)%coord%x  
      mesh%CrossSection(i)%coord%y  =mesh%CrossSection(3)%coord%y 
      mesh%CrossSection(i)%elevation=mesh%CrossSection(3)%elevation
      mesh%CrossSection(i)%nc       =mesh%CrossSection(3)%nc
      allocate(mesh%CrossSection(i)%height(mesh%CrossSection(i)%nc))
      allocate(mesh%CrossSection(i)%surfacewidth(mesh%CrossSection(i)%nc))
      allocate(mesh%CrossSection(i)%y(mesh%CrossSection(i)%nc))
      do j=1,mesh%CrossSection(i)%nc
         mesh%CrossSection(i)%height(j)      =mesh%CrossSection(3)%height(j)
         mesh%CrossSection(i)%surfacewidth(j)=mesh%CrossSection(3)%surfacewidth(j)
         mesh%CrossSection(i)%y(j)           =mesh%CrossSection(3)%y(j)
      end do
   end do

   !Fill gost cell (E_boundary)
   do i=mesh%ncs+3,mesh%ncs+4
      mesh%CrossSection(i)%coord%x  =mesh%CrossSection(mesh%ncs+2)%coord%x  
      mesh%CrossSection(i)%coord%y  =mesh%CrossSection(mesh%ncs+2)%coord%y 
      mesh%CrossSection(i)%elevation=mesh%CrossSection(mesh%ncs+2)%elevation
      mesh%CrossSection(i)%nc       =mesh%CrossSection(mesh%ncs+2)%nc
      allocate(mesh%CrossSection(i)%height(mesh%CrossSection(i)%nc))
      allocate(mesh%CrossSection(i)%surfacewidth(mesh%CrossSection(i)%nc))
      allocate(mesh%CrossSection(i)%y(mesh%CrossSection(i)%nc))
      do j=1,mesh%CrossSection(i)%nc
         mesh%CrossSection(i)%height(j)      =mesh%CrossSection(mesh%ncs+2)%height(j)
         mesh%CrossSection(i)%surfacewidth(j)=mesh%CrossSection(mesh%ncs+2)%surfacewidth(j)
         mesh%CrossSection(i)%y(j)           =mesh%CrossSection(mesh%ncs+2)%y(j)
      end do
   end do

   !Fill bathy_cell
   do i=1,mesh%ncs+4
      bathy_cell(i)=mesh%CrossSection(i)%elevation
   end do


   !===================================================================================================================!
   !  Finishing Subroutine
   !===================================================================================================================!

   
   close(10)
   
   if (status /= 0) return

   call Print_Screen( 'end_mesh' )

END SUBROUTINE Read_Dass_Mesh



