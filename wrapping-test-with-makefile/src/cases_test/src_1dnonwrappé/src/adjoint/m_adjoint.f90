!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_adjoint.f90
!! \brief This file includes m_adjoint module.
!! \details The file includes only m_adjoint module (see doc m_adjoint module)

! #define DEBUG

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module using Tapenade generated Output Files in /tap directory
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_adjoint.
!!
!! \details This module using Tapenade generated output files in /tap directory.
MODULE m_adjoint

   USE m_common
   USE m_linear_algebra
   USE m_mesh
   USE m_random
   USE m_time_screen

   USE m_tap_vars

   #ifdef USE_SW_MONO
      USE m_model
   #endif

   implicit none

   type( unk )  ::  dof0_diff                                   !< Initial unknowns (type unk) (differential).
   type( unk )  ::  dof0_back                                   !< Initial unknowns (type unk) (adjoint).

   type( unk )  ::  dof_diff                                    !< Unknows (type unk) (differential).
   type( unk )  ::  dof_back                                    !< Unknows (type unk) (adjoint).

   type( msh )  ::  mesh_diff                                   !< Mesh (type msh) (differential).
   type( msh )  ::  mesh_back                                   !< Mesh (type msh) (adjoint).

   real(rp), dimension(:), allocatable  ::  control             !< Control vector.
   real(rp), dimension(:), allocatable  ::  control_back        !< Adjoint control vector.
   real(rp), dimension(:), allocatable  ::  control_diff        !< Perturbation control vector.
   real(rp), dimension(:), allocatable  ::  control_perturb     !< Perturbated control vector.
   real(rp), dimension(:), allocatable  ::  control_perturb_back!< Adjoint of perturbated control vector.
   real(rp), dimension(:), allocatable  ::  control_lbound      !< Lower bounds vector.
   real(rp), dimension(:), allocatable  ::  control_ubound      !< Upper bounds vector.

   real(rp)  ::  cost                                           !< Cost function.
   real(rp)  ::  cost_back                                      !< Adjoint cost function.
   real(rp)  ::  cost_diff                                      !< Perturbation cost function.
   real(rp)  ::  cost_perturb                                   !< Perturbated cost function.

   integer(ip)  ::  ic                                          !< Control vector index.

   integer(ip)  ::  ite_min                                     !< Iteration of minimization procedure.

   integer(ip)  ::  nb_vars_in_control                          !< Number of variables in the control vector.

   integer(ip), dimension(100)  ::  dim_vars_in_control         !< Dimension of each variable in the control vector.

   logical :: normalize_gradJ_and_J           !< if True, the minimization routine does not see the true cost and its gradient, but a normalized (with the first guess infos) version, with the accordingly changed control vector


CONTAINS


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute Direct Model considering :
!     - input  : control vector ( control )
!     - output : cost function  ( cost    )
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Compute direct model. 
   !!
   !! \details The direct model is computed from the control vector and return the cost function.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   !! \param[inout] dof Unknowns.
   SUBROUTINE model_direct( mesh , dof0 , dof )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0
      type( unk ), intent(inout)  ::  dof

      !================================================================================================================!
      !  Read control vectror
      !================================================================================================================!

      call read_control( dof0 , mesh )

      !================================================================================================================!
      !  Calling direct model
      !================================================================================================================!

      #ifdef USE_SW_MONO
         call run_model( mesh , dof0 , dof , cost )
      #endif

   END SUBROUTINE model_direct


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute Direct Model considering :
!     - input  : perturbated control vector ( control_perturb )
!     - output : perturbated cost function  ( cost_perturb    )
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Compute direct model. 
   !!
   !! \details The direct model is computed from the perturbated control vector and return the perturbated cost function.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   !! \param[inout] dof Unknowns.
   SUBROUTINE model_direct_perturb( mesh , dof0 , dof )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0
      type( unk ), intent(inout)  ::  dof

      !================================================================================================================!
      !  Read perturbated control vector
      !================================================================================================================!

      call read_control_perturb( dof0 , mesh )

      !================================================================================================================!
      !  Calling direct model
      !================================================================================================================!

      call Time_Init(1_ip)

      #ifdef USE_SW_MONO
         call run_model( mesh , dof0 , dof , cost_perturb )
      #endif

      call Time_End(1_ip)

   END SUBROUTINE model_direct_perturb


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute Tangent Linear Model considering :
!     - input  : control vector / perturbation control vector ( control / control_diff )
!     - output : cost function  / perturbation cost           ( cost    / cost_diff    )
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Compute tangent linear model. 
   !!
   !! \details The tangent linear model is computed from the perturbated control vector and control vector.
   !! The cost function and the perturbated cost function is returned.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   !! \param[inout] dof Unknowns.
   SUBROUTINE linear_tangent_model( mesh , dof0 , dof )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0
      type( unk ), intent(inout)  ::  dof

      !================================================================================================================!
      !  Read control vector
      !================================================================================================================!
      
      call read_control( dof0 , mesh )

      !================================================================================================================!
      !  Read perturbation control vector
      !================================================================================================================!

      call read_control_diff( dof0_diff , mesh )
      
      !================================================================================================================!
      !  Calling linear tangent model
      !================================================================================================================!

      call Time_Init(1_ip)

      #ifdef USE_SW_MONO
         call run_model_diff( mesh, dof0 , dof0_diff , dof , dof_diff , cost , cost_diff )
      #endif

      call Time_End(1_ip)

   END SUBROUTINE linear_tangent_model


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute Adjoint Model considering :
!     - input  :         control vector / adjoint cost function ( control      / cost_back )
!     - output : adjoint control vector /         cost function ( control_back / cost      )
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Compute adjoint model. 
   !!
   !! \details The adjoint model is computed from the perturbated control vector and control vector.
   !! The adjoint cost function and the adjoint perturbated cost function is returned.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   !! \param[inout] dof Unknowns.
   SUBROUTINE adjoint_model( mesh , dof0 , dof )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0
      type( unk ), intent(inout)  ::  dof

      character(30) filename_test ! TMP pour afficher les valeurs intermediaires du controle
      
      
      real :: START_TIME, END_TIME


      !================================================================================================================!
      !  Read control vector
      !================================================================================================================!

      call read_control( dof0 , mesh )

      !================================================================================================================!
      !  Calling adjoint model
      !================================================================================================================!

      call Time_Init(1_ip)

#ifdef USE_SW_MONO

         dof_back%s(:) = 0._rp
         dof_back%q(:) = 0._rp
         dof_back%h(:) = 0._rp

         bathy_cell_back(:) = 0._rp
         
!          CALL CPU_TIME(START_TIME)
         call run_model_back( mesh , dof0 , dof0_back , dof , dof_back , cost , cost_back )
!          CALL CPU_TIME(END_TIME)
!          print *, "adjoint_model:time=", END_TIME-START_TIME, " seconds"
         
#endif

      call Time_End(1_ip)

      !================================================================================================================!
      !  Filling control_back vector (cost gradient vector)
      !================================================================================================================!
      call write_control_back( dof0_back , mesh )
      
   END SUBROUTINE adjoint_model


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Calc cost function gradient using Adjoint Model
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Compute cost function gradient using adjoint model. 
   !!
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   !! \param[inout] dof Unknowns.
   SUBROUTINE calc_grad_cost( mesh , dof0 , dof )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0
      type( unk ), intent(inout)  ::  dof

      !================================================================================================================!
      !  Initialization
      !================================================================================================================!

      call alloc_back_vars( dof0_back, dof_back , mesh ) ! Ici

      call write_control( dof0 , mesh )

      verbose  =  -1

      cost_back  =  1._rp

      !================================================================================================================!
      !  Calc cost function gradient using Adjoint Model
      !================================================================================================================!

      call adjoint_model( mesh , dof0 , dof )

      !================================================================================================================!
      !  Output in proper Files the Gradient of the Cost Function
      !================================================================================================================!

      call output_control_back( mesh )

   END SUBROUTINE calc_grad_cost


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Testing Adjoint :
!
!        0 : all
!        1 : two direct run
!        2 : gradient test on tangent linear
!        3 : gradient test on adjoint
!        4 : scalar product
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Done test of the adjoint. 
   !!
   !! \details In function of an argument this subroutine tests adjoint.
   !! If argument is equal to:
   !!    - 0 : all test are done.
   !!    - 1 : two direct run.
   !!    - 2 : gradient test on tangent linear.
   !!    - 3 : gradient test on adjoint.
   !!    - 4 : scalar product. 
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   !! \param[inout] dof Unknowns.
   !! \param[in] arg argument of the test.
   SUBROUTINE test_adjoint( mesh , dof0 , dof , arg )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0
      type( unk ), intent(inout)  ::  dof

      character(len=*), intent(in)  ::  arg
      character(10) ::  namefile
      character(50)  ::  filename
      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      integer(ip)  ::  test_type

      real(rp)  ::  eps , scal1 , scal2

      !================================================================================================================!
      !  Initialization
      !================================================================================================================!

      call alloc_diff_vars( dof0_diff , dof_diff , mesh )
      call alloc_back_vars( dof0_back , dof_back , mesh )

      !================================================================================================================!
      !  Gradient Direction
      !================================================================================================================!

      call write_control     ( dof0 , mesh ) ! Definition of variable control ( k)
      call write_control_diff( dof0 , mesh ) ! Definition of variable control_diff (\delta k)

      allocate( control_perturb ( size( control ) ) )
      allocate( control_back    ( size( control ) ) )

      !================================================================================================================!
      !  Direct Test (2 run that should return the same p_Y result)
      !================================================================================================================!

      read(arg,*) test_type

      verbose  =  -1
      
      if ( test_type == 0 .or. test_type == 1 ) then

         call model_direct( mesh , dof0 , dof )

         call Print_Screen( 'cost' , cost )

         call model_direct( mesh , dof0 , dof )

         call Print_Screen( 'cost' , cost )


      end if

      !================================================================================================================!
      !  Tangent Gradient Test
      !================================================================================================================!

      if ( test_type == 0 .or. test_type == 2 ) then

         call Print_Screen( 'tangent_gradient_test' )

         open(80,file='time_step_serie_for_adjoint.bin',form='unformatted',status='replace')       
         open(20,file='tangent_gradient_test.txt',status='replace',form='formatted')

         fix_time_step_serie = 1

         call linear_tangent_model( mesh , dof0 , dof )

         close(80)
         call Print_Screen( 'cost'      , cost      )
         call Print_Screen( 'cost_diff' , cost_diff )

         eps = 1.0_rp
         
         write(6,*)
         write(6,'(A)') '--------------------------------------------------------------------------------'
         write(6,'(A,TR21,A,TR6,A)') ' eps' , 'cost_perturb_diff' , 'relative error'
         write(6,'(A)') '--------------------------------------------------------------------------------'
         write(6,*)

         write(20,*)
         write(20,'(A)') '--------------------------------------------------------------------------------'
         write(20,'(A,A,A,A,A,A)') ' \alpha  ' ,' deriv_j(k) ' ,'j(k)', 'j(k+\alpha\delta k) ', '(j(k+\alpha\delta k) -j(k))/\alpha  ' , 'abs(1-I_alpha) '
         write(20,'(A)') '--------------------------------------------------------------------------------'
         write(20,*)

         do while( eps >= 1.d-8 )
         
            control_perturb(:)  =  control(:)  +  eps * control_diff(:)

            open(80,file='time_step_serie_for_adjoint.bin',form='unformatted',status='old')

            fix_time_step_serie = 2

            call model_direct_perturb( mesh , dof0 , dof )

            write(6,'(3ES23.15)') eps , &
                  ( cost_perturb - cost ) / eps, &
                  abs( one -  ( cost_perturb - cost ) / ( eps * cost_diff ) )
            write(20,'(6ES23.15)') eps , &
                  cost_diff, &
                  cost, &
                  cost_perturb,&
                  ( cost_perturb - cost ) / eps, &
                  abs( one -  ( cost_perturb - cost ) / ( eps * cost_diff ) )

            namefile='controlper'
            write(filename,'(A,"_",ES7.1)') namefile , eps
            open(21,file=trim(filename)//'.dat',status='replace',form='formatted')
            do i = 1,size(control)
               write(21,'(2ES23.15)') control(i), control_perturb(i)
            end do
            close(21)
            close(80)

            eps = 0.1_rp * eps

         end do

         !if ( test_type == 2 ) call End_MPI
         close(20)
      end if

      !================================================================================================================!
      !  Backward Gradient Test
      !================================================================================================================!

      if ( test_type == 0 .or. test_type == 3 ) then

         call Print_Screen( 'backward_gradient_test' )
!          read(*,*)

         open(80,file='time_step_serie_for_adjoint.bin',form='unformatted',status='replace')

         fix_time_step_serie = 1

         cost_back  =  one
         
         call adjoint_model( mesh , dof0 , dof )

         cost_diff  =  sum( control_diff(:) * control_back(:) )

         close(80)

         write(6,*)

         call Print_Screen( 'cost'      , cost      )
         call Print_Screen( 'cost_diff' , cost_diff )
!          read(*,*)

         eps = 1._rp


         write(6,*)
         write(6,'(A)') '--------------------------------------------------------------------------------'
         write(6,'(A,TR21,A,TR6,A)') ' eps' , 'cost_perturb_diff' , 'relative error'
         write(6,'(A)') '--------------------------------------------------------------------------------'
         write(6,*)


         do while( eps >= 1.d-8 )

            control_perturb(:)  =  control(:)  +  eps * control_diff(:)

            open(80,file='time_step_serie_for_adjoint.bin',form='unformatted',status='old')

            fix_time_step_serie = 2
            
            call model_direct_perturb( mesh , dof0 , dof )
            
            write(6,'(3ES23.15)') eps , &
               ( cost_perturb - cost ) / eps, &
               abs( one -  ( cost_perturb - cost ) / ( eps * cost_diff ) )

            close(80)
            
!             read(*,*)

            eps = 0.1_rp * eps

         end do

         !if ( test_type == 3 ) call End_MPI

      end if

      !================================================================================================================!
      !  Backward Scalar Product Test
      !================================================================================================================!

      if ( test_type == 0 .or. test_type == 4 ) then

         fix_time_step_serie = 0

         call Print_Screen( 'backward_scalar_product_test' )

         call linear_tangent_model( mesh , dof0 , dof )

         call Print_Screen( 'cost'      , cost      )
         call Print_Screen( 'cost_diff' , cost_diff )

         cost_back  =  cost_diff

         scal1  =  cost_back * cost_diff
         
         call adjoint_model( mesh , dof0 , dof )

         call Print_Screen( 'cost'      , cost      )
         call Print_Screen( 'cost_back' , cost_back )

         scal2 = sum( control_diff(:) * control_back(:) )

         !if ( proc == 0 ) 
         write(6,'(A,2ES22.15)') ' scal1 = ' , scal1
         !if ( proc == 0 ) 
         write(6,'(A,2ES22.15)') ' scal2 = ' , scal2
         !if ( proc == 0 ) 
         write(6,'(A,2ES22.15)') ' relative error = '  , abs( ( scal2 - scal1 ) / scal1 )

         !if ( test_type == 4 ) call End_MPI

      end if

   END SUBROUTINE test_adjoint


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Filling the Model Input Control Vector
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Filling the model input control vector. 
   !!
   !! \details Add to the control vector k variable. In the end of this function the vector k is created.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   SUBROUTINE write_control( dof0 , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0

      !================================================================================================================!
      !  Filling desired Control Vector (with c_ in input.txt)
      !================================================================================================================!

      nb_vars_in_control = 0

      ic = 1
! var_chg = .false.
#ifdef USE_SW_MONO
      if ( var_chg ) then
         if ( c_manning == 1    ) then
            select case ( K_model )
            case ( 'K(h)' )
               call var_2_control(alpha_K_chg, K_params%nb_diff_K_reachs, 0)
               call var_2_control(beta_K_chg, K_params%nb_diff_K_reachs, 0)
            case default
               print*, 'K model not taken into account'
               stop
            end select
         end if
            
         if ( c_bathy   == 1    ) then
            if (.not. allocated(bathy_points_chg)) then
               print *, "Bathymetry points must be set for c_bathy=1"
               stop 3
            end if
            call var_2_control( bathy_points_chg, nb_bathy_control_pts, 0 )
         else if ( c_bathy   == 3    ) then
            call var_2_control( bathy_cell_chg, nb_bathy_control_pts, 0 )
         else if (c_bathy /= 0) then
            print *, "c_bathy must be 1 or 3 for change of variable"
            stop 3
         end if
            
         if ( c_hydrograph == 1 ) call var_2_control( qin_chg , size( bc%hyd%q(:) ) , 0 )

         if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call var_2_control( qlat_chg , size( bc%hyd_lat%q ) , 0 )

      else
         if ( c_manning == 1 ) call K_params_2_control()
         
!          if ( c_bathy   == 1 ) call var_2_control( bathy_cell , mesh%ncs+4 , 0                 )
         if ( c_bathy   == 1 ) then
            if (.not. allocated(bathy_points)) then
               print *, "Bathymetry points must be set for c_bathy=1"
               stop 3
            end if
            call var_2_control( bathy_points , size(bathy_points) , 0                 )
         end if
         if ( c_bathy   == 2 ) call var_2_control( bathy_cell(zb_cs_1:zb_cs_2) , zb_cs_2 - zb_cs_1 + 1 , 0                 )
         !          if ( c_bathy   == 3 ) call var_2_control(bathy_cell(bathy_first:bathy_last:bathy_step), (bathy_last-bathy_first)/bathy_step +1, 0)
         if ( c_bathy   == 3 ) call bathy_2_control(bathy_cell, mesh%ncs+4 , 0                 )
         
         if ( c_ic      == 1 ) call var_2_control( dof0%s     , mesh%ncs+4 , 0                 ) ! Add to the control vector, vector dof0%s
         if ( c_ic      == 1 ) call var_2_control( dof0%q     , mesh%ncs+4 , 0                 ) ! Add to the control vector, vector dof0%q
      
         if ( c_hydrograph == 1 ) then

           call var_2_control( bc%hyd%q(:) , size( bc%hyd%q(:) ) , 1 ) ! Add to the control vector, vector bc%hyd%q(:)
           
           !Hyd lat
           if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call var_2_control( bc%hyd_lat%q , size( bc%hyd_lat%q ) , 1 )
           
         endif

         ! For Fourier serie
         if ( c_hydrograph == 2 ) then
            call var_2_control_scal( bc%hyd_FS%a0  , 1  )                     ! Add to the control vector scalar bc%hyd_FS%a0
            call var_2_control( bc%hyd_FS%a(:) , size( bc%hyd_FS%a(:) ) , 1 ) ! Add to the control vector, vector bc%hyd_FS%a(:)
            call var_2_control( bc%hyd_FS%b(:) , size( bc%hyd_FS%b(:) ) , 1 ) ! Add to the control vector, vector bc%hyd_FS%b(:)
         end if


         if  ( c_ratcurve == 1 ) then
            call var_2_control( bc%rat%q(:) , size( bc%rat%q(:) ) , 1 ) ! Add to the control vector, vector bc%rat%q(:)
         end if

         if  ( c_ratcurve == 2) then
            call var_2_control_scal( alpha_ratcurve  , 1  ) ! Add to the control vector scalar alpha_ratcurve
            call var_2_control_scal( beta_ratcurve   , 1  ) ! Add to the control vector scalar beta_ratcurve
         end if
      
      end if
      
      open(85,file='min/control_vector.txt')
      write(85,'(A)') 'Control parameters'
      if (c_hydrograph == 1 ) write(85,'(A,I3.3,A)') 'Qin at Ntimes =  ',size( bc%hyd%q(:)),'            ; Inflow Hydrograph '
      if (c_manning == 1 ) write(85,'(A,I3.3,A)') 'Ks on Nreaches =  ',K_params%nb_diff_K_reachs,'            ; Spatialized Strickler Roughness Power Law K(h)=ah^b '
      if (c_bathy > 0 ) write(85,'(A,I3.3,A)') 'Bathymetry Nx =  ', size(bathy_cell),'            ; Bathymetry '
      !to do: ajouter bathy
      close(85)
      
      
#endif


   CONTAINS

      !>  Filling the model input control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (array) of dimension n.
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] n Size of the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE var_2_control( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob

         real(rp), dimension(n), intent(in)  ::  var

         !=============================================================================================================!
         !
         !=============================================================================================================!

         nb_vars_in_control  =  nb_vars_in_control  +  1

         call alloc_or_larger_r( control , ic + n - 1 )

         control( ic : ic + n - 1 )  =  var( 1 : n )

         ic = ic + n

         dim_vars_in_control( nb_vars_in_control )  =  n        

       END SUBROUTINE var_2_control
       

       !>  Fill the control vector with the parameters defining the Strickler coefficient K
       !! \details .
       SUBROUTINE K_params_2_control()
         implicit none
         
         select case ( K_model )
            
         case ( 'K(h)' )
            call alloc_or_larger_r( control , ic + 2*K_params%nb_diff_K_reachs - 1 )
            ! alpha
            nb_vars_in_control  =  nb_vars_in_control  +  1
            do i=1,K_params%nb_diff_K_reachs
               control(ic) = K_params%alpha(K_params%cs_start(i))
               ic = ic + 1
            end do
            dim_vars_in_control( nb_vars_in_control )  =  K_params%nb_diff_K_reachs         
            ! beta
            nb_vars_in_control  =  nb_vars_in_control  +  1
            do i=1,K_params%nb_diff_K_reachs
               control(ic) = K_params%beta(K_params%cs_start(i))
               ic = ic + 1
            end do
            dim_vars_in_control( nb_vars_in_control )  =  K_params%nb_diff_K_reachs
            
         case default
            ! do nothing
         end select
            
       END SUBROUTINE K_params_2_control
       

      !>  Filling the model input control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (array) of dimension n.
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] n Size of the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE bathy_2_control( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob

         real(rp), dimension(n), intent(in)  ::  var

         nb_vars_in_control  =  nb_vars_in_control  +  1
                     
         call alloc_or_larger_r( control , ic + nb_bathy_control_pts - 1 )
         if (allocated(bathy_points)) then
            do i = 1, size(bathy_points)
               control(ic+i-1)  =  var(bathy_indices(i))
            end do
         else 
            control(ic:ic+nb_bathy_control_pts-1)  =  var(bathy_first:bathy_last:bathy_step)
         end if
         ic = ic + nb_bathy_control_pts
         dim_vars_in_control( nb_vars_in_control )  =  nb_bathy_control_pts
               
      END SUBROUTINE bathy_2_control

      !>  Filling the model input control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (scalar).
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE var_2_control_scal( var , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  data_glob

         real(rp),  intent(in)  ::  var

         !=============================================================================================================!
         !
         !=============================================================================================================!

         nb_vars_in_control  =  nb_vars_in_control  +  1

         call alloc_or_larger_r(control,ic)

         control(ic)= var
            
         ic = ic + 1

         dim_vars_in_control(nb_vars_in_control) = 1         
            

      END SUBROUTINE var_2_control_scal


   END SUBROUTINE write_control



!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Filling the Model Input Perturbation Control Vector
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Filling the model input perturbation control vector. 
   !!
   !! \details Add to the control vector k variable. In the end of this function the vector k is created.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   SUBROUTINE write_control_diff( dof0 , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( unk ), intent(in)  ::  dof0
      type( msh ), intent(in)  ::  mesh

      !================================================================================================================!
      !  Filling input control vector ( control )
      !================================================================================================================!

      ic = 1

#ifdef USE_SW_MONO
      if ( var_chg ) then
         if ( c_manning == 1    ) then
            select case ( K_model )
            case ( 'K(h)' )
               call var_2_control_diff(eps_manning, alpha_K_chg, K_params%nb_diff_K_reachs, 0)
               call var_2_control_diff(eps_manning, beta_K_chg, K_params%nb_diff_K_reachs, 0)
            case default
               print*, 'K model not taken into account'
               stop
            end select
         end if
         
         if ( c_bathy   == 1    ) call var_2_control_diff( eps_bathy, bathy_points_chg, nb_bathy_control_pts, 0 )
         
         if ( c_bathy   == 3    ) call var_2_control_diff( eps_bathy, bathy_cell_chg, nb_bathy_control_pts, 0 )
         
         if ( c_hydrograph == 1 ) call var_2_control_diff( eps_hydrograph, qin_chg , size( qin_chg ) , 0 )
         
         if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call var_2_control_diff(eps_hydrograph, qlat_chg , size( qlat_chg ) , 0 )
         

      else

         if ( c_manning == 1 ) call K_params_2_control_diff( eps_manning )

         if ( c_bathy   == 1 ) call var_2_control_diff( eps_bathy, bathy_points , mesh%ncs+4 , 0                 )
         if ( c_bathy   == 2 ) call var_2_control_diff( eps_bathy, bathy_cell(zb_cs_1 : zb_cs_2) , zb_cs_2 - zb_cs_1 + 1 , 0                 )
         
         if ( c_bathy   == 3 ) call bathy_2_control_diff( eps_bathy, bathy_cell , mesh%ncs+4 , 0                 )
         if ( c_ic      == 1 ) call var_2_control_diff( eps_ic, dof0%s     , mesh%ncs+4 , 0                 )
         if ( c_ic      == 1 ) call var_2_control_diff( eps_ic, dof0%q     , mesh%ncs+4 , 0                 )


         if ( c_hydrograph == 1 ) then
            call var_2_control_diff( eps_hydrograph, bc%hyd%q(:) , size( bc%hyd%q(:) ) , 1 )
         end if


         if ( c_hydrograph == 2 ) then
            call var_2_control_scal_diff( eps_hydrograph, bc%hyd_FS%a0 , 1 )
            call var_2_control_diff( eps_hydrograph, bc%hyd_FS%a(:) , size( bc%hyd_FS%a(:) ) , 1 )
            call var_2_control_diff( eps_hydrograph, bc%hyd_FS%b(:) , size( bc%hyd_FS%b(:) ) , 1 )
         end if

         if ( c_ratcurve == 1 ) then
            call var_2_control_diff( eps_ratcurve, bc%rat%q(:) , size( bc%rat%q(:) ) , 1 )
         end if

         if ( c_ratcurve == 2 ) then
            call var_2_control_scal_diff( eps_ratcurve, alpha_ratcurve , 1 )
            call var_2_control_scal_diff( eps_ratcurve, beta_ratcurve  , 1 )
         end if
      end if
#endif


   CONTAINS

      !>  Filling the model input perturbation control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (array) of dimension n.
     !! \param[in] eps_var fraction of the var being used for var_diff
          !! \param[in] var Array to append to the control vector.
      !! \param[in] n Size of the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE var_2_control_diff( eps_var, var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob
         real(rp), intent(in)  ::  eps_var
         real(rp), dimension(n), intent(in)  ::  var

         !=============================================================================================================!
         ! Local variables
         !=============================================================================================================!

         integer(ip)  ::  n_k
         real(rp), dimension(n)  ::  rn

         !=============================================================================================================!
         !
         !=============================================================================================================!

!          call init_random_seed

         call alloc_or_larger_r( control_diff , ic + n - 1 )
         call random_number( rn )

         if ( maxval( abs( var ) ) > 1e-15 ) then
            control_diff( ic : ic + n - 1 )  =  ( -1._rp + 2._rp * rn ( 1 : n ) ) * eps_var * var( 1 : n )
         else
            control_diff( ic : ic + n - 1 )  =  ( -1._rp + 2._rp * rn ( 1 : n ) ) * eps_var
         end if

         ic = ic + n

       END SUBROUTINE var_2_control_diff

       
       !>  Filling the model input perturbation control vector. 
      !!
      !! \details .
      SUBROUTINE K_params_2_control_diff( eps_var )

         implicit none

         real(rp), intent(in) :: eps_var
         real(rp), dimension(K_params%nb_diff_K_reachs)  ::  rn

         call random_number( rn )
               
         select case ( K_model )
            
         case ( 'K(h)' )
            call alloc_or_larger_r( control_diff , ic + 2*K_params%nb_diff_K_reachs - 1 )
            do i=1,K_params%nb_diff_K_reachs
               control_diff(ic) = (-1._rp + 2._rp * rn (i)) * eps_var * K_params%alpha(K_params%cs_start(i))
               ic = ic + 1
            end do
            ! beta
            do i=1,K_params%nb_diff_K_reachs
               control_diff(ic) = (-1._rp + 2._rp * rn (i)) * eps_var * K_params%beta(K_params%cs_start(i))
               ic = ic + 1
            end do
            
         case default
            ! do nothing
         end select

      END SUBROUTINE K_params_2_control_diff

      
      !>  Filling the model input perturbation control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (array) of dimension n.
      !! \param[in] eps_var fraction of the var being used for var_diff
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] n Size of the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE bathy_2_control_diff( eps_var, var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob
         real(rp), intent(in) :: eps_var
         real(rp), dimension(n), intent(in)  ::  var
         
         !=============================================================================================================!
         !
         !=============================================================================================================!

         real(rp), dimension(n)  ::  rn
                     
               call alloc_or_larger_r( control_diff , ic + nb_bathy_control_pts - 1 )
               call random_number( rn )

               control_diff( ic:ic+nb_bathy_control_pts-1 ) = ( -1._rp + 2._rp * rn (bathy_first:bathy_last:bathy_step) ) * &
                    eps_var * var(bathy_first:bathy_last:bathy_step)

               ic = ic + nb_bathy_control_pts
               

      END SUBROUTINE bathy_2_control_diff


      !>  Filling the model input perturbation control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (scalar).
      !! \param[in] eps_var fraction of the var being used for var_diff
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE var_2_control_scal_diff( eps_var, var , data_glob )

         implicit none

         !=======================================================================================!
         !  Interface Variables
         !=======================================================================================!

         integer(ip), intent(in)  ::  data_glob
         real(rp), intent(in) :: eps_var
         real(rp), intent(in)  ::  var

         !========================================================================================!
         !   Local Variables
         !========================================================================================!

         real(rp), dimension(1)  ::  rn

         !========================================================================================!
         !
         !========================================================================================!

         call init_random_seed

         call alloc_or_larger_r( control_diff , ic )

         call random_number( rn )

         control_diff(ic)  =  ( -1._rp + 2._rp * rn (1) ) * eps_var * var

         ic = ic + 1


      END SUBROUTINE var_2_control_scal_diff

   END SUBROUTINE write_control_diff


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Filling the Model Output Adjoint Control Vector
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Filling the model input adjoint control vector. 
   !!
   !! \details Add to the control vector k variable. In the end of this function the vector k is created.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   SUBROUTINE write_control_back( dof0 , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( unk ), intent(in)  ::  dof0
      type( msh ), intent(in)  ::  mesh

      !================================================================================================================!
      !  Filling input control vector ( control )
      !================================================================================================================!

      ic = 1

#ifdef USE_SW_MONO
      if ( var_chg ) then
         if ( c_manning == 1    ) then
            select case ( K_model )
            case ( 'K(h)' )
               call var_2_control_back(alpha_K_chg_back, K_params%nb_diff_K_reachs, 0)
               call var_2_control_back(beta_K_chg_back, K_params%nb_diff_K_reachs, 0)
            case default
               print*, 'K model not taken into account'
               stop
            end select
         end if
         
         if ( c_bathy   == 1    ) call var_2_control_back( bathy_points_chg_back, nb_bathy_control_pts, 0 )
         
         if ( c_bathy   == 3    ) call var_2_control_back( bathy_cell_chg_back, nb_bathy_control_pts, 0 )
         
         if ( c_hydrograph == 1 ) call var_2_control_back( qin_chg_back , size( bc%hyd%q(:) ) , 0 )
         
         if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call var_2_control_back( qlat_chg_back , size( bc_back%hyd_lat%q ) , 0 )

      else
         if ( c_manning == 1 ) call K_params_2_control_back( )
         
!          if ( c_bathy   == 1 ) call var_2_control_back( bathy_cell_back , mesh%ncs+4 , 0                 )
         if ( c_bathy   == 1 ) then
            if (.not. allocated(bathy_points)) then
               print *, "Bathymetry points must be set for c_bathy=1"
               stop 3
            end if
            call var_2_control_back( bathy_points_back , size(bathy_points) , 0                 )
         end if
         if ( c_bathy   == 2 ) call var_2_control_back( bathy_cell_back(zb_cs_1 : zb_cs_2) , zb_cs_2 - zb_cs_1 + 1 , 0                 )
         !       if ( c_bathy   == 3 ) call var_2_control_back( bathy_cell_back(bathy_first:bathy_last:bathy_step), (bathy_last-bathy_first)/bathy_step +1, 0)
         if ( c_bathy   == 3 ) call bathy_2_control_back( bathy_cell_back , mesh%ncs+4 , 0                 )
         
         if ( c_ic      == 1 ) call var_2_control_back( dof0_back%s     , mesh%ncs+4 , 0                 )
         if ( c_ic      == 1 ) call var_2_control_back( dof0_back%q     , mesh%ncs+4 , 0                 )

         if ( c_hydrograph == 1 ) then
           call var_2_control_back( bc_back%hyd%q(:) , size( bc_back%hyd%q(:) ) , 1 )

           !Hyd lat
           if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call var_2_control_back( bc_back%hyd_lat%q , size( bc_back%hyd_lat%q ) , 1 )

         endif
         
         if ( c_hydrograph == 2 ) then
            call var_2_control_scal_back( bc_back%hyd_FS%a0 , 1 )
            call var_2_control_back( bc_back%hyd_FS%a(:) , size( bc_back%hyd_FS%a(:) ) , 1 )
            call var_2_control_back( bc_back%hyd_FS%b(:) , size( bc_back%hyd_FS%b(:) ) , 1 )
         end if


         if    ( c_ratcurve == 1 ) then
            call var_2_control_back( bc_back%rat%q(:) , size( bc_back%rat%q(:) ) , 1 )
         end if

         if    ( c_ratcurve == 2 ) then
            call var_2_control_scal_back( alpha_ratcurve_back , 1 )
            call var_2_control_scal_back( beta_ratcurve_back  , 1 )
         end if
      end if
#endif


   CONTAINS

      !>  Filling the model input adjoint control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (array) of dimension n.
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] n Size of the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE var_2_control_back( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob

         real(rp), dimension(n), intent(in)  ::  var

         call alloc_or_larger_r( control_back , ic + n - 1 )
         control_back( ic : ic + n - 1 )  =  var( 1 : n )
         ic = ic + n
         

       END SUBROUTINE var_2_control_back

      !>  Filling the model input adjoint control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (array) of dimension n.
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] n Size of the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE K_params_2_control_back( )

         implicit none
         
         select case ( K_model )
            
         case ( 'K(h)' )
            call alloc_or_larger_r( control_back , ic + 2*K_params%nb_diff_K_reachs - 1 )
            do i=1,K_params%nb_diff_K_reachs
               control_back(ic) = K_params_back%alpha(K_params%cs_start(i))
               ic = ic + 1
            end do
            ! beta
            do i=1,K_params%nb_diff_K_reachs
               control_back(ic) = K_params_back%beta(K_params%cs_start(i))
               ic = ic + 1
            end do

         case default
            ! do nothing
         end select

       END SUBROUTINE K_params_2_control_back
       

      !>  Filling the model input adjoint control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (array) of dimension n.
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] n Size of the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE bathy_2_control_back( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob

         real(rp), dimension(n), intent(in)  ::  var

         
         call alloc_or_larger_r( control_back , ic + nb_bathy_control_pts - 1 )
         control_back(ic:ic+nb_bathy_control_pts-1)  =  var(bathy_first:bathy_last:bathy_step)
         ic = ic + nb_bathy_control_pts

      END SUBROUTINE bathy_2_control_back


      !>  Filling the model input adjoint control vector. 
      !!
      !! \details This subroutine add to the control vector the variable var (scalar).
      !! \param[inout] var Array to append to the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE var_2_control_scal_back( var ,  data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  data_glob

         real(rp), intent(in)  ::  var

         call alloc_or_larger_r( control_back , ic )

         control_back( ic  )  =  var

         ic = ic + 1

      END SUBROUTINE var_2_control_scal_back


   END SUBROUTINE write_control_back


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Filling the Model Boundaries Control Vector
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Filling the model input adjoint control vector. 
   !!
   !! \details Add to the control vector k variable. In the end of this function the vector k is created.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   SUBROUTINE write_control_bounds( dof0 , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( unk ), intent(in)  ::  dof0
      type( msh ), intent(in)  ::  mesh

      !================================================================================================================!
      !  Filling input control vector ( control )
      !================================================================================================================!

      ic = 1

#ifdef USE_SW_MONO

      if ( var_chg ) then
         print*, 'Change of variable not working with bounds'
         allocate(control_lbound(size(control)))
         allocate(control_ubound(size(control)))
         control_lbound(:) = 0.0_rp
         control_ubound(:) = 0.0_rp
         return
      end if

      if ( c_manning == 1 ) then 
         call var_2_control_scal_bounds( alpha_lbound, alpha_ubound, 1 )
         call var_2_control_scal_bounds( beta_lbound, beta_ubound, 1 )
      else if ( c_manning == 2 ) then 
         call var_2_control_scal_bounds( alpha_lbound, alpha_ubound, 1 )
      endif       
         
      if ( c_bathy   == 1 ) then
        write(6,*) "Bounds not implemented for c_bathy==1"
        stop
      endif
      if ( c_bathy   == 2 ) then
        write(6,*) "Bounds not implemented for c_bathy==1"
        stop
      endif
!       if ( c_bathy   == 3 ) call var_2_control_bounds( bathy_cell_bounds(bathy_first:bathy_last:bathy_step), (bathy_last-bathy_first)/bathy_step +1, 0)
      if ( c_bathy   == 3 ) call bathy_2_control_bounds( bathy_lbound, bathy_ubound, bathy_cell, bathy_delta, &
                                                         mesh%ncs+4 , 0)
      if ( c_ic      == 1 ) then  !call var_2_control_bounds( dof0_bounds%s     , mesh%ncs+4 , 0                 )
        write(6,*) "Bounds not implemented for c_ic==1"
        stop
      endif
      if ( c_ic      == 1 ) then  !call var_2_control_bounds( dof0_bounds%q     , mesh%ncs+4 , 0                 )
        write(6,*) "Bounds not implemented for c_ic==1"
        stop
      endif

      if ( c_hydrograph == 1 ) then
         !print*,'hydrograph_lbound',hydrograph_lbound
         call var_2_control_bounds( hydrograph_lbound, hydrograph_ubound, size( bc%hyd%q(:) ) , 1 )
      end if

      if ( c_hydrograph == 2 ) then
         call var_2_control_bounds( 0.0_rp, 0.0_rp, size( bc%hyd%q(:) ) , 1 )
!         write(6,*) "Bounds not implemented for c_hydrograph==2"
!         stop
      endif

      if    ( c_ratcurve == 1 ) then
!          call var_2_control_bounds( bc_bounds%rat%q(:) , size( bc_bounds%rat%q(:) ) , 1 )
        write(6,*) "Bounds not implemented for c_ratcurve==1"
        stop
      end if

      if    ( c_ratcurve == 2 ) then
         call var_2_control_scal_bounds( alpha_ratcurve_lbound, alpha_ratcurve_ubound, 1 )
         call var_2_control_scal_bounds( beta_ratcurve_lbound, beta_ratcurve_ubound, 1 )
      end if

      #endif


   CONTAINS

      !>  Filling the model input control bounds vectors. 
      !!
      !! \details This subroutine adds to the control bounds vectors the bounds for a variable array of dimension n.
      !! \param[in] lb Lower bound to append to the control lower-bounds vectors.
      !! \param[in] ub Upper bound to append to the control upper-bounds vectors.
      !! \param[in] n Number of components in the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE var_2_control_bounds( lb, ub, n, data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob

         real(rp), intent(in)  ::  lb
         real(rp), intent(in)  ::  ub

         call alloc_or_larger_r( control_lbound , ic + n - 1 )
         call alloc_or_larger_r( control_ubound , ic + n - 1 )

         control_lbound( ic : ic + n - 1 )  =  lb
         control_ubound( ic : ic + n - 1 )  =  ub

         ic = ic + n
         

      END SUBROUTINE var_2_control_bounds

      !>  Filling the model input control bounds vectors. 
      !!
      !! \details This subroutine adds to the control bounds vectors the bounds for the bathymetry.
      !! \param[in] lb Lower bound to append to the control lower-bounds vectors.
      !! \param[in] ub Upper bound to append to the control upper-bounds vectors.
      !! \param[in] var Array of initial values of bathymetry.
      !! \param[in] delta Admissible delta around initial values of bathymetry.
      !! \param[in] n Size of the control vector.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE bathy_2_control_bounds( lb, ub, var, delta, n, data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob

         real(rp), intent(in)  ::  lb
         real(rp), intent(in)  ::  ub
         real(rp), intent(in)  ::  delta
         real(rp), dimension(n), intent(in)  ::  var
         

         call alloc_or_larger_r( control_lbound , ic + nb_bathy_control_pts - 1 )
         call alloc_or_larger_r( control_ubound , ic + nb_bathy_control_pts - 1 )
         if (delta > 1e-6) then
            control_lbound(ic:ic+nb_bathy_control_pts-1)  =  var(bathy_first:bathy_last) - 0.5 * delta
            control_ubound(ic:ic+nb_bathy_control_pts-1)  =  var(bathy_first:bathy_last) + 0.5 * delta
         else
            control_lbound(ic:ic+nb_bathy_control_pts-1)  =  lb
            control_lbound(ic:ic+nb_bathy_control_pts-1)  =  ub
         end if
         ic = ic + nb_bathy_control_pts                        

      END SUBROUTINE bathy_2_control_bounds


      !>  Append boundaries for a scalar component of the control vector to the array of control boundaries
      !!
      !! \param[in] lb Lower bound for the scalar component of the control vector
      !! \param[in] ub Upper bound for the scalar component of the control vector
      !! \param[in] data_glob Unused variable.
      SUBROUTINE var_2_control_scal_bounds( lb, ub, data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  data_glob

         real(rp), intent(in)  ::  lb
         real(rp), intent(in)  ::  ub

         call alloc_or_larger_r( control_lbound , ic )
         call alloc_or_larger_r( control_ubound , ic )

         control_lbound( ic  )  =  lb
         control_ubound( ic  )  =  ub

         ic = ic + 1

      END SUBROUTINE var_2_control_scal_bounds


   END SUBROUTINE write_control_bounds


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Reading the Model Input Control Vector
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Reading the model input control vector. 
   !!
   !! \details This subroutine reads the input control vector k variable.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   SUBROUTINE read_control( dof0 , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( unk ), intent(inout)  ::  dof0
      type( msh ), intent(in   )  ::  mesh

      !================================================================================================================!
      !  Filling input control vector ( control )
      !================================================================================================================!

      ic = 1
      
      #ifdef USE_SW_MONO

         if ( var_chg ) then
            if ( c_manning == 1    ) then
               select case ( K_model )
               case ( 'K(h)' )
                  call control_2_var(alpha_K_chg, K_params%nb_diff_K_reachs, 0)
                  call control_2_var(beta_K_chg, K_params%nb_diff_K_reachs, 0)
               case default
                  print*, 'K model not taken into account'
                  stop
               end select

               !Friction parameters forced to be positive
                !print*, K_params%alpha,K_params%beta
!               do i=1,size(K_params%alpha)
!		  if(K_params%alpha(i)<alpha_eps) K_params%alpha(i)=-K_params%alpha(i)
!               end do
!               do i=1,size(K_params%beta)
!		  if(K_params%beta(i)<beta_eps) K_params%beta(i)=-K_params%beta(i)
!               end do
            end if
            
            if ( c_bathy == 1      ) call control_2_var(bathy_points_chg, nb_bathy_control_pts, 0)
            if ( c_bathy == 3      ) call control_2_var(bathy_cell_chg, nb_bathy_control_pts, 0)
            
            if ( c_hydrograph == 1 ) then
                call control_2_var(qin_chg, size(bc%hyd%q), 0)
                ! Q is forced to be positive for M1QN3 that do not take bounds (TO DO PAG : if M1QN3=true then...)

                do i=1,size(bc%hyd%q)
                    if (bc%hyd%q(i)<qeps) bc%hyd%q(i)=qeps
                end do
            end if
            
            
            if ( lat_inflow == '1' .and. c_hydrograph == 1 ) then
                call control_2_var(qlat_chg, size(bc%hyd_lat%q), 0)

                !do i=1,size(bc%hyd_lat%q(:,1))
		 ! do j=1,size(bc%hyd_lat%q(1,:))
                  !  if (bc%hyd_lat%q(i,j)<10.0) bc%hyd_lat%q(i,j)=10.0
               ! end do
              ! enddo
            end if
            
         else
            ! Strickler
            if ( c_manning == 1 ) call control_2_K_params( )
            ! Bathy
!             if ( c_bathy   == 1 ) call control_2_var( bathy_cell , mesh%ncs+4 , 0 )
            if ( c_bathy   == 1 ) then
                if (.not. allocated(bathy_points)) then
                  print *, "Bathymetry points must be set for c_bathy=1"
                  stop 3
                end if
                call control_2_var( bathy_points , size(bathy_points) , 0                 )
            end if
            if ( c_bathy   == 2 ) call control_2_var( bathy_cell(zb_cs_1 : zb_cs_2) , zb_cs_2 - zb_cs_1 + 1 , 0 )
            if ( c_bathy   == 3 ) call control_2_bathy( bathy_cell, mesh%ncs+4 , dof0 )
            if ( c_ic      == 1 ) call control_2_var( dof0%s     , mesh%ncs+4 , 0 )
            if ( c_ic      == 1 ) call control_2_var( dof0%q     , mesh%ncs+4 , 0 )
            ! Hydro
            if ( c_hydrograph == 1 ) then
               call control_2_var( bc%hyd%q(:) , size( bc%hyd%q(:) ) , 1 )
               do i=1,size(bc%hyd%q)
                    if (bc%hyd%q(i)<qeps) bc%hyd%q(i)=qeps
                end do
               !Hyd lat
               if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call control_2_var( bc%hyd_lat%q , size( bc%hyd_lat%q ) , 1 )

            end if

            if ( c_hydrograph == 2 ) then
               call control_2_var_scal( bc%hyd_FS%a0    , 1 )
               call control_2_var( bc%hyd_FS%a(:) , size( bc%hyd_FS%a(:) ) , 1 )
               call control_2_var( bc%hyd_FS%b(:) , size( bc%hyd_FS%b(:) ) , 1 )
            end if

            ! Rating curve
            if ( c_ratcurve == 1 ) then
               call control_2_var( bc%rat%q(:) , size( bc%rat%q(:) ) , 1 )
            end if

            if ( c_ratcurve == 2 ) then
               call control_2_var_scal( alpha_ratcurve    , 1 )
               call control_2_var_scal( beta_ratcurve     , 1 )
            end if
         end if
#endif


   CONTAINS

      !>  Reading the model input  control vector. 
      !!
      !! \details This subroutine reads the control vector(array) from beginning ic to ic+n.
      !! \param[out] var Array to get the control vector.
      !! \param[in] n Size of var.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE control_2_var( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob

         real(rp), dimension(n), intent(out)  ::  var
         
         var( 1 : n )  =  control( ic : ic + n - 1 )
         
         ic = ic + n
         
       END SUBROUTINE control_2_var

       !>  Reading the control vector elements corresponding to the parameters of the Strickler coefficient K. 
      !!
      !! \details .
      SUBROUTINE control_2_K_params( )

         implicit none

         select case( K_model )

         case( 'K(h)' )
            do i=1,K_params%nb_diff_K_reachs
               K_params%alpha(K_params%cs_start(i)) = control(ic)
               ic = ic + 1
            end do
            ! beta
            do i=1,K_params%nb_diff_K_reachs
               K_params%beta(K_params%cs_start(i)) = control(ic)
               ic = ic + 1
            end do

         case default
            ! do nothing
         end select
         
       END SUBROUTINE control_2_K_params
       

      !>  Reading the model input  control vector. 
      !!
      !! \details This subroutine reads the control vector(array) from beginning ic to ic+n.
      !! \param[out] var Array to get the control vector.
      !! \param[in] n Size of var.
      !! \param[in] dof0 Initial conditions.
      SUBROUTINE control_2_bathy( var , n , dof0 )
      
         use m_model

         implicit none

         !=========================================================================================!
         !  Interface Variables
         !=========================================================================================!

         type( unk ), intent(inout)  ::  dof0         
         integer(ip), intent(in)  ::  n
         real(rp), dimension(n), intent(out)  ::  var
         
         var(bathy_first:bathy_last:bathy_step) = control(ic:ic+nb_bathy_control_pts-1)
         ic = ic + nb_bathy_control_pts
                        
      END SUBROUTINE control_2_bathy

      !>  Reading the model input  control vector. 
      !!
      !! \details This subroutine reads the control vector to ic.
      !! \param[out] var Piece of the control vector wanted (scalar).
      !! \param[in] data_glob Variable not used.
      SUBROUTINE control_2_var_scal( var , data_glob )

         implicit none

         !=========================================================================================!
         !  Interface Variables
         !=========================================================================================!

         integer(ip), intent(in)  ::  data_glob

         real(rp), intent(out)  ::  var
         
         var =  control( ic)

         ic= ic + 1

      END SUBROUTINE control_2_var_scal

   END SUBROUTINE read_control


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Reading the Model Input Perturbation Control Vector
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Reading the model input perturbation control vector. 
   !!
   !! \details This subroutine reads the input perturbation control vector k variable.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   SUBROUTINE read_control_diff( dof0 , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( unk ), intent(inout)  ::  dof0
      type( msh ), intent(in   )  ::  mesh

      !================================================================================================================!
      !  Filling input control vector ( control )
      !================================================================================================================!

      ic = 1

      #ifdef USE_SW_MONO


      if ( var_chg ) then
         alpha_K_chg_diff = 0._rp
         beta_K_chg_diff = 0._rp
         qin_chg_diff = 0._rp
         bathy_cell_chg_diff = 0._rp
         qlat_chg_diff = 0._rp
                  
         if ( c_manning == 1    ) then
            select case ( K_model )
            case ( 'K(h)' )
               call control_diff_2_var(alpha_K_chg_diff, K_params%nb_diff_K_reachs, 0)
               call control_diff_2_var(beta_K_chg_diff, K_params%nb_diff_K_reachs, 0)
            case default
               print*, 'K model not taken into account'
               stop
            end select
         end if
         
         if ( c_bathy == 3      ) call control_diff_2_var(bathy_cell_chg_diff, nb_bathy_control_pts, 0)
         
         if ( c_hydrograph == 1 ) call control_diff_2_var(qin_chg_diff, size(bc%hyd%q), 0)
            
         if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call control_diff_2_var(qlat_chg_diff, size(bc%hyd_lat%q), 0)
         
      else
         alpha_ratcurve_diff =  0._rp
         beta_ratcurve_diff  =  0._rp
         bathy_cell_diff(:)  =  0._rp
         dof0_diff%s    (:)  =  0._rp
         dof0_diff%q    (:)  =  0._rp
         
         bc_diff%hyd%q(:)  =  0._rp

         bc_diff%hyd_FS%a0    =  0._rp
         bc_diff%hyd_FS%a(:)  =  0._rp
         bc_diff%hyd_FS%b(:)  =  0._rp

         !bc_diff%rat%q(:)  =  0._rp

         if ( c_manning == 1 ) call control_diff_2_K_params( )

         if ( c_bathy   == 1 ) call control_diff_2_var( bathy_cell_diff , mesh%ncs+4 , 0 )
         if ( c_bathy   == 2 ) call control_diff_2_var( bathy_cell_diff(zb_cs_1 : zb_cs_2) , zb_cs_2 - zb_cs_1 + 1 , 0 )
         if ( c_bathy   == 3 ) call control_diff_2_bathy( bathy_cell_diff , mesh%ncs+4 , 0 )
         if ( c_ic      == 1 ) call control_diff_2_var( dof0_diff%s     , mesh%ncs+4 , 0 )
         if ( c_ic      == 1 ) call control_diff_2_var( dof0_diff%q     , mesh%ncs+4 , 0 )

         if ( c_hydrograph == 1 ) then
            call control_diff_2_var( bc_diff%hyd%q(:) , size( bc_diff%hyd%q(:) ) , 1 )
         end if

         if ( c_hydrograph == 2 ) then
            call control_diff_2_var_scal( bc_diff%hyd_FS%a0 , 1 )
            call control_diff_2_var( bc_diff%hyd_FS%a(:) , size( bc_diff%hyd_FS%a(:) ) , 1 )
            call control_diff_2_var( bc_diff%hyd_FS%b(:) , size( bc_diff%hyd_FS%b(:) ) , 1 )
         end if
         
         if ( c_ratcurve == 1 ) then
            call control_diff_2_var( bc_diff%rat%q(:) , size( bc_diff%rat%q(:) ) , 1 )
         end if

         if ( c_ratcurve == 2 ) then
            call control_diff_2_var_scal( alpha_ratcurve_diff   , 1 )
            call control_diff_2_var_scal( beta_ratcurve_diff    , 1 )
         end if
      end if
#endif


   CONTAINS

      !>  Reading the model input perturbation control vector. 
      !!
      !! \details This subroutine reads the perturbation control vector(array) from beginning ic to ic+n.
      !! \param[out] var Array to get the perturbation control vector.
      !! \param[in] n Size of var.
      !! \param[in] data_glob Variable not used.
     SUBROUTINE control_diff_2_var( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob
         real(rp), dimension(n), intent(out)  ::  var

         var( 1 : n )  =  control_diff( ic : ic + n - 1 )
        
         ic = ic + n

       END SUBROUTINE control_diff_2_var
       

       !>  Reading the model input perturbation control vector. 
      !!
      !! \details .
      SUBROUTINE control_diff_2_K_params( )

         implicit none

         
         select case( K_model )

         case( 'K(h)' )
            K_params_diff%alpha(:) = 0._rp
            K_params_diff%beta(:)  = 0._rp
            ! alpha
            do i=1,K_params%nb_diff_K_reachs
               K_params_diff%alpha(K_params%cs_start(i)) = control_diff(ic)
               ic = ic + 1
            end do
            ! beta
            do i=1,K_params%nb_diff_K_reachs
               K_params_diff%beta(K_params%cs_start(i)) = control_diff(ic)
               ic = ic + 1
            end do

         case default
            ! do nothing
         end select

      END SUBROUTINE control_diff_2_K_params

      !>  Reading the model input perturbation control vector. 
      !!
      !! \details This subroutine reads the perturbation control vector(array) from beginning ic to ic+n.
      !! \param[out] var Array to get the perturbation control vector.
      !! \param[in] n Size of var.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE control_diff_2_bathy( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob
         real(rp), dimension(n), intent(out)  ::  var
         

         var(bathy_first:bathy_last:bathy_step) = control_diff(ic:ic+nb_bathy_control_pts-1)
         ic = ic + nb_bathy_control_pts
               
      END SUBROUTINE control_diff_2_bathy

      !>  Reading the model input perturbation control vector. 
      !!
      !! \details This subroutine reads the perturbation control vector to ic.
      !! \param[out] var Piece of the perturbation control vector wanted (scalar).
      !! \param[in] data_glob Variable not used.
      SUBROUTINE control_diff_2_var_scal( var , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  :: data_glob

         real(rp)   , intent(out)  ::  var

         var =  control_diff( ic )
        
         ic = ic + 1

      END SUBROUTINE control_diff_2_var_scal


   END SUBROUTINE read_control_diff


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Reading the Model Input Perturbated Control Vector
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Reading the model input perturbated control vector. 
   !!
   !! \details This subroutine reads the input perturbated control vector k variable.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   SUBROUTINE read_control_perturb( dof0 , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( unk ), intent(inout)  ::  dof0
      type( msh ), intent(in   )  ::  mesh

      !================================================================================================================!
      !  Filling input control vector ( control )
      !================================================================================================================!

      ic = 1

#ifdef USE_SW_MONO

      if ( var_chg ) then
         if ( c_manning == 1    ) then
            select case ( K_model )
            case ( 'K(h)' )
               call control_perturb_2_var( alpha_K_chg, K_params%nb_diff_K_reachs, 0 )
               call control_perturb_2_var( beta_K_chg, K_params%nb_diff_K_reachs , 0 )
            case default
               print*, 'K model not taken into account'
               stop
            end select
         end if
      
         if ( c_bathy == 3      ) call control_perturb_2_var(bathy_cell_chg, nb_bathy_control_pts, 0)
      
         if ( c_hydrograph == 1 ) call control_perturb_2_var(qin_chg, size(bc%hyd%q), 0)
         
         if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call control_perturb_2_var( qlat_chg , size( bc%hyd_lat%q ) , 0 )
                        
      else

         if ( c_manning == 1 ) call control_perturb_2_K_params( )

         if ( c_bathy   == 1 ) call control_perturb_2_var( bathy_cell , mesh%ncs+4 , 0)
         if ( c_bathy   == 2 ) call control_perturb_2_var( bathy_cell(zb_cs_1 : zb_cs_2) , zb_cs_2 - zb_cs_1 + 1 , 0)
         if ( c_bathy   == 3 ) call control_perturb_2_bathy( bathy_cell , mesh%ncs+4 , 0 )
         if ( c_ic      == 1 ) call control_perturb_2_var(   dof0%s     , mesh%ncs+4 , 0 )
         if ( c_ic      == 1 ) call control_perturb_2_var(   dof0%q     , mesh%ncs+4 , 0 )

         if ( c_hydrograph == 1 ) then
            call control_perturb_2_var( bc%hyd%q(:) , size( bc%hyd%q(:) ) , 1 )
            !Hyd lat
            if ( lat_inflow == '1' .and. c_hydrograph == 1 ) call control_perturb_2_var( bc%hyd_lat%q , size( bc%hyd_lat%q ) , 1 )

         end if

         if ( c_hydrograph == 2 ) then
            call control_perturb_2_var_scal( bc%hyd_FS%a0, 1 )
            call control_perturb_2_var( bc%hyd_FS%a(:) , size( bc%hyd_FS%a(:) ) , 1 )
            call control_perturb_2_var( bc%hyd_FS%b(:) , size( bc%hyd_FS%b(:) ) , 1 )
         end if

         if ( c_ratcurve == 1 ) then
            call control_perturb_2_var( bc%rat%q(:) , size( bc%rat%q(:) ) , 1 )
         end if

         if ( c_ratcurve == 2 ) then
            call control_perturb_2_var_scal( alpha_ratcurve, 1 )
            call control_perturb_2_var_scal( beta_ratcurve , 1 )
         end if
      end if
#endif


   CONTAINS

      !>  Reading the model input perturbated control vector. 
      !!
      !! \details This subroutine reads the perturbated control vector(array) from beginning ic to ic+n.
      !! \param[out] var Array to get the perturbated control vector.
      !! \param[in] n Size of var.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE control_perturb_2_var( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob

         real(rp), dimension(n), intent(out)  ::  var

         var( 1 : n )  =  control_perturb( ic : ic + n - 1 )

         ic = ic + n

       END SUBROUTINE control_perturb_2_var
       

       !>  Reading the control vector elements corresponding to the parameters of the Strickler coefficient K. 
      !!
      !! \details .
      SUBROUTINE control_perturb_2_K_params( )

         implicit none

         select case( K_model )

         case( 'K(h)' )
            do i=1,K_params%nb_diff_K_reachs
               K_params%alpha(K_params%cs_start(i)) = control_perturb(ic)
               ic = ic + 1
            end do
            ! beta
            do i=1,K_params%nb_diff_K_reachs
               K_params%beta(K_params%cs_start(i)) = control_perturb(ic)
               ic = ic + 1
            end do
           
         case default
            ! do nothing
         end select
         
       END SUBROUTINE control_perturb_2_K_params

      !>  Reading the model input perturbated control vector. 
      !!
      !! \details This subroutine reads the perturbated control vector(array) from beginning ic to ic+n.
      !! \param[out] var Array to get the perturbated control vector.
      !! \param[in] n Size of var.
      !! \param[in] data_glob Variable not used.
      SUBROUTINE control_perturb_2_bathy( var , n , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  ::  n , data_glob
         real(rp), dimension(n), intent(out)  ::  var
         
         var(bathy_first:bathy_last:bathy_step) = control_perturb(ic:ic+nb_bathy_control_pts-1)
         ic = ic + nb_bathy_control_pts
               
      END SUBROUTINE control_perturb_2_bathy

      !>  Reading the model input perturbated control vector. 
      !!
      !! \details This subroutine reads the perturbated control vector to ic.
      !! \param[out] var Piece of the perturbated control vector wanted (scalar).
      !! \param[in] data_glob Variable not used.
      SUBROUTINE control_perturb_2_var_scal( var , data_glob )

         implicit none

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         integer(ip), intent(in)  :: data_glob

         real(rp), intent(out)  ::  var

         var     =  control_perturb( ic )

         ic = ic + 1

      END SUBROUTINE control_perturb_2_var_scal


   END SUBROUTINE read_control_perturb
   


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Output in proper Files the Control Vector
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Output in proper files the control vector. 
   !!
   !! \details This subroutine writes in output the control vector.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   SUBROUTINE output_control( dof0 , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in)  ::  mesh

      type( unk ), intent(inout)  ::  dof0

      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      character(len=lchar)  ::  file_name

      !================================================================================================================!
      !  Filling input control vector ( control )
      !================================================================================================================!

      call system('mkdir -p min')

      call read_control( dof0 , mesh )
      
      #ifdef USE_SW_MONO

         if (c_hydrograph == 1 ) then

            write(file_name,'(A,I3.3)') 'min/hydrograph_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            do i = 1,size( bc%hyd%t(:) )
               write(10,*) bc%hyd%t(i) , bc%hyd%q(i)
            end do

            close(10)
            
            if ( lat_inflow == '1' .and. c_hydrograph == 1 ) then

            write(file_name,'(A,I3.3)') 'min/hydrograph_lat_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')
            
            do i = 1,size( bc%hyd_lat%t(:) )
               write(10,*) bc%hyd_lat%t(i) , bc%hyd_lat%q(:,i)
            end do

            close(10)
            
            endif

            
         end if

         if (c_hydrograph == 2 ) then

            write(file_name,'(A,I3.3)') 'min/hydrograph_FS_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            write(10,*) bc%hyd_FS%a0
            do i = 1,size( bc%hyd_FS%a(:) )
               write(10,*) bc%hyd_FS%n(i) , bc%hyd_FS%a(i), bc%hyd_FS%b(i)
            end do

            close(10)

         end if


         if ( c_manning == 1 ) then

            write(file_name,'(A,I3.3)') 'min/manning_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            do i = 1,K_params%nb_diff_K_reachs
               write(10,*) K_params%alpha(K_params%cs_start(i)), K_params%beta(K_params%cs_start(i))
            end do
            
            close(10)

         end if


         if ( c_bathy == 1 .and. allocated(bathy_points) ) then

            write(file_name,'(A,I3.3)') 'min/bathy_points_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            do i = 1, size(bathy_points)
               write(10,*) bathy_points(i)          
            end do
            
            close(10)

         end if


         if ( c_bathy == 1 .or. c_bathy == 3 ) then

            write(file_name,'(A,I3.3)') 'min/bathy_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            do i = 3,(size(bathy_cell(:))-2)           
               write(10,*) bathy_cell(i)          
            end do
            
            close(10)

         end if


         if ( c_bathy == 2 ) then

            write(file_name,'(A,I3.3)') 'min/bathy_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            do i = zb_cs_1, zb_cs_2            
               write(10,*) bathy_cell(i)            
            end do
            
            close(10)

         end if


         if ( c_ic == 1 ) then

            write(file_name,'(A,I3.3)') 'min/s_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            do i = 3,size(dof0%s(:))-2            
               write(10,*) dof0%s(i)                     
            end do
            
            close(10)


            write(file_name,'(A,I3.3)') 'min/q_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            do i = 3,size(dof0%q(:))-2            
               write(10,*) dof0%q(i)                     
            end do
            
            close(10)

         end if


         if (c_ratcurve == 1 ) then

            write(file_name,'(A,I3.3)') 'min/ratcurve1_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            do i = 1,size( bc%rat%h(:) )
               write(10,*) bc%rat%h(i) , bc%rat%q(i)
            end do

            close(10)

         end if


         if ( c_ratcurve == 2 ) then

            write(file_name,'(A,I3.3)') 'min/ratcurve2_' , ite_min
            open(10,file=file_name,status='replace',form='formatted')

            write(10,*) alpha_ratcurve, beta_ratcurve

            close(10)

         end if


      #endif

   END SUBROUTINE output_control


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Output in proper Files the Back Control Vector (the gradient of the cost function)
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Output in proper files the back control vector (the gradient of the cost function). 
   !!
   !! \details This subroutine writes in output file the back control vector. The back control vector corresponding
   !! to the gradient of the cost function.
   !! \param[in]    mesh Mesh of the model.
   SUBROUTINE output_control_back( mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in)  ::  mesh

      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      character(len=lchar)  ::  file_name

      !real(rp), dimension( mesh%nc + mesh%ncb )  ::  temp

      !================================================================================================================!
      !  Filling input control vector ( control )
      !================================================================================================================!

      call system('mkdir -p grad')

      #ifdef USE_SW_MONO

      write(file_name,'(A)') 'grad/hydrograph_grad'
      open(10,file=file_name,status='replace',form='formatted')

      do i = 1,size( bc%hyd%t(:) )
         write(10,*) bc%hyd%t(i) , bc_back%hyd%q(i)
      end do

      close(10)


      if (c_hydrograph.eq.2) then

         write(file_name,'(A)') 'grad/hydrograph_FS_grad'
         open(10,file=file_name,status='replace',form='formatted')

         write(10,*) bc_back%hyd_FS%a0         
         do i = 1,size( bc%hyd_FS%n(:) )            
            write(10,*) bc%hyd_FS%n(i) , bc_back%hyd_FS%a(i), bc_back%hyd_FS%b(i)
         end do

         close(10)
   
      end if


      write(file_name,'(A)') 'grad/bathy_grad'
      open(10,file=file_name,status='replace',form='formatted')

      do i = 1,size( bathy_cell_back(:) )
         write(10,*) bathy_cell_back(i)
      end do

      close(10)


      write(file_name,'(A)') 'grad/manning_grad'
      open(10,file=file_name,status='replace',form='formatted')

      do i = 1,K_params%nb_diff_K_reachs
         write(10,*) K_params_back%alpha(K_params%cs_start(i)), K_params_back%beta(K_params%cs_start(i))
      end do
            
      close(10)
      

      write(file_name,'(A)') 'grad/ratcurve_grad'
      open(10,file=file_name,status='replace',form='formatted')
      write(10,*) alpha_ratcurve_back , beta_ratcurve_back

      close(10)

      #endif

   END SUBROUTINE output_control_back


END MODULE m_adjoint
