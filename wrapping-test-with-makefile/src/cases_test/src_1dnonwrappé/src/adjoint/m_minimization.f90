!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_minimization.f90
!! \brief This file includes m_minimization module.
!! \details The file includes only m_minimization module (see doc m_minimization module).


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module managing minimisation process
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

! #define DEBUG
! #define WRITE_EXTRA_FILES

!> Module m_minimization.
!!
!! \details It is in this module that the minimization of cost function is done.
MODULE m_minimization

   USE m_adjoint
!    USE m_regul_cost_coeff
   #ifdef USE_SW_MONO
      USE m_model
   #endif

   implicit none

   integer(ip)  ::  ite_line_search !< Number of the step descent for the gradient descent algorithm.


CONTAINS


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main subroutine of minimization
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Main subroutine of minimization  
   !!
   !! \details The minimization is computed from the control vector and  adjoint control vector and return
   !! the control vector minimize.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   !! \param[inout] dof Unknowns.
   SUBROUTINE minimize_cost( mesh , dof0 , dof )
   
      use m_obs, only : recalc_alpha_regul, cost_regul_parts

      implicit none

      !===========================================================================================!
      !  Interface Variables
      !===========================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0
      type( unk ), intent(inout)  ::  dof

      !===========================================================================================!
      !  Local Variables
      !===========================================================================================!

      external  simul_rc , euclid , ctonbe , ctcabe

      integer(ip)  ::  n            ! Control vector size
      real(rp)     ::  dxmin        ! Resolution for x in Linf norm
      real(rp)     ::  J            ! Cost value (internal for M2QN1)
      real(rp)     ::  dJ_expect    ! Estimation of the expected decrease in cost during the first iteration
      real(rp)     ::  epsg         ! Stopping criterion
      character*3  ::  normtype     ! specifies the norm used to test optimality
      integer(ip)  ::  impres       ! Print option for m1qn3
      integer(ip)  ::  io           ! File output label
      integer(ip)  ::  imode(3)     ! Input mode
      integer(ip)  ::  omode        ! Output mode
      integer(ip)  ::  niter        ! Maximum number of minimization iterations
      integer(ip)  ::  nsim         ! Maximum number of simulator calls
      integer(ip)  ::  ndz          ! Dimension of dz
      integer(ip)  ::  reverse      ! Specifies direct or reverse mode
      integer(ip)  ::  indic        ! m1qn3 indicates it needs cost/gradient

      integer(ip)  ::  izs(1)       !
      real         ::  rzs(1)       ! Working areas not needed in reverse mode
      real(rp)     ::  dzs(2)       !

      real(rp), dimension(:), allocatable     ::  dx     ! dxmin for M2QN1
      integer(ip), dimension(:), allocatable  ::  iz     ! Adress of working array
      real(rp), dimension(:), allocatable     ::  dz     ! Adress of working array
      real(rp), dimension(:), allocatable     ::  gradJ  ! Cost gradients (internal for M2QN1)

      integer(ip)                             ::  m         ! m for LBFGSB-3.0
      integer(ip), dimension(:), allocatable  ::  nbd       ! nbd for LBFGSB-3.0
      real(rp)                                ::  factr     ! factr for LBFGSB-3.0
      character(len=60)                       ::  task      ! task for LBFGSB-3.0
      character(len=60)                       ::  csave     ! csave for LBFGSB-3.0
      logical, dimension(29)                  ::  lsave     ! lsave for LBFGSB-3.0
      real(rp), dimension(29)                 ::  dsave     ! dsave for LBFGSB-3.0
      integer(ip), dimension(44)              ::  isave     ! isave for LBFGSB-3.0

      real(rp)  ::  norm_gradJ, norm_gradJ_ini

      real(rp)  ::  cost_ini , norm_grad_cost_ini(100) , norm_grad_cost(100)

      character(30) filename_test ! TMP pour afficher les valeurs intermediaires du controle
      
      real(rp) :: denom_gam_noise, gam_noise
      integer(ip) :: idiff

      !===========================================================================================!
      !  Initialization
      !===========================================================================================!

      call system('mkdir -p min')

      call alloc_back_vars( dof0_back , dof_back , mesh )
      call write_control( dof0 , mesh )
      
      !if True, the minimization routine does not see the true cost and its gradient,
      ! but a normalized (with the first guess infos) version, with the accordingly changed control vector
      normalize_gradJ_and_J = norm_grad0
      norm_grad_cost_ini(:) = 0.0_rp
      
#ifndef USE_M1QN3
#ifndef USE_N2QN1
#ifndef USE_LBFGSB3
      write (*,'(A)') 'Wrong MINMETHOD in Makefile (must be 1,2 or 3)'
      stop
#endif
#endif
#endif

#ifdef USE_M1QN3
      !===========================================================================================!
      !  m1qn3 arguments
      !===========================================================================================!

      n          =   size( control )
      dxmin      =   1.d-10!-5
      epsg       =   eps_min
      normtype   =   'two'
      impres     =   5
      io         =   40
      imode(1)   =   0
      imode(2)   =   0
      imode(3)   =   1
      ndz        =   4 * n + 100 * ( 2 * n + 1 )
      reverse    =   1
      indic      =   4

      allocate( iz( 5 ) )
      allocate( dz( ndz ) ) ; dz(:) = 0._rp

      !nsim  =  100
      nsim  =  1000
      
      if ( restart_min == 0 ) then

!          niter  =  nsim
         niter  =  200

      else

         niter  =  restart_min

      end if

      !==========================================================================================!
      !  Initialization / Restarting
      !==========================================================================================!

      inquire( file = 'min/min_cost.txt' , exist = file_exist(1) )

      !call mpi_wait_all

      if ( .not. file_exist(1) ) then

         ite_min         = 0
         ite_line_search = 0
!          init_bathy_regul = .TRUE.

         open(30,file='min/min_cost.txt'    ,status='replace',form = 'formatted')
         open(31,file='min/min_cost_and_noise.txt'    ,status='replace',form = 'formatted')
         open(32,file='min/min_cost_obs_and_regul.txt'    ,status='replace',form = 'formatted')
         open(40,file='min/m1qn3_output.txt',status='replace',form = 'formatted')

         write(30,'(A)') '# ite cost norm_grad_cost'
         write(31,'(A)') '# ite absolute_cost gamma_noise'
         write(32,'(A)') '# ite ite_ls cost_obs cost_regul cost_regul_bathy cost_regul_hydro '//&
                         'cost_regul_strickler'
         
         iz(:) = 0

      else
      
         call Print_Screen('restart_min')

         open(30,file='min/min_cost.txt'    ,status='old',position = 'append',form='formatted')
         open(31,file='min/min_cost_and_noise.txt',status='old',position = 'append',form='formatted')
         open(32,file='min/min_cost_obs_and_regul.txt',status='old',position='append',form = 'formatted')
         open(40,file='min/m1qn3_output.txt',status='old',position = 'append',form='formatted')

         allocate( control_back( size(control) ) )

         call read_restart_m1qn3

         imode(2)   =   1
         epsg       =   eps_min / epsg
         reverse    =   1

      end if

      !===========================================================================================!
      !  Rerun
      !===========================================================================================!
      inquire( file = 'min/rerun.txt' , exist = file_exist(1) )

      if ( ite_min == 0 .and. file_exist(1) ) then
      
         call Print_Screen('rerun_min')
         
         open(60, file='min/rerun.txt',status='old')
         read(60, *) control
         close(60)
         
      end if

      !===========================================================================================!
      !  Minimization ... M1QN3 loop in reverse mode
      !===========================================================================================!
      w_obs = 0
      do while( reverse >= 0 .and. indic /= 0 )

         !========================================================================================!
         !  Case indic = 4 -> M1QN3 needs new values of the cost and its gradient to compute
         !  either the step descent (line-search) or the new iterate
         !
         !    ===> call adjoint_model(...)
         !
         !========================================================================================!
         if ( indic == 4 ) then

            ! recalc the regularization coeff
            if (ite_period_alpha_reg_calc > 0) then
               if ( modulo(ite_min, ite_period_alpha_reg_calc) == 0 .and. ite_line_search == 0) then
                  recalc_alpha_regul = 1
               end if
            end if

            ! re-init cost_back
            cost_back = one
            verbose = -1

            ! adjoint model
            call adjoint_model( mesh , dof0 , dof )
            ite_line_search = ite_line_search + 1
            
#ifdef WRITE_EXTRA_FILES
!             ! TMP: to see the evolution of the control inside the linesearch
!             write(filename_test,'(A,I3.3,I3.3)') 'min/ext/control_',ite_min,ite_line_search
!             open(1234,file=filename_test,form='formatted')
!             do i=1, size(control)
!                write(1234,*) control(i)
!             enddo
!             close(1234)
!             write(filename_test,'(A,I3.3,I3.3)') 'min/ext/control_back_',ite_min,ite_line_search
!             open(1234,file=filename_test,form='formatted')
!             do i=1, size(control)
!                write(1234,*) control_back(i)
!             enddo
!             close(1234)
!             
            if ( c_hydrograph == 1 ) then
!               write(filename_test,'(A,I3.3,I3.3)') 'min/ext/delta_hydrograph',ite_min,ite_line_search
!               open(1234,file=filename_test,form='formatted')
!               do i=1, size(bc%hyd%q)
!                 if (var_chg) then
!                    write(1234,*) qin_fg(i) - bc%hyd%q(i), qin_chg(i)
!                 else
!                    write(1234,*) qin_fg(i) - bc%hyd%q(i)
!                 end if
!               enddo
!               close(1234)
              write(filename_test,'(A,I3.3,I3.3)') 'min/ext/hydrograph_',ite_min,ite_line_search
              open(1234,file=filename_test,form='formatted')
              do i=1, size(bc%hyd%q)
                 write(1234,*) bc%hyd%q(i)
              enddo
              close(1234)
            endif
            if ( c_manning == 1 ) then
              write(filename_test,'(A,I3.3,I3.3)') 'min/ext/manning_',ite_min,ite_line_search
              open(1234,file=filename_test,form='formatted')
              do i = 1,K_params%nb_diff_K_reachs
                 write(1234,*) K_params%alpha(K_params%cs_start(i)), K_params%beta(K_params%cs_start(i))
              end do
              close(1234)
            endif
            if ( c_bathy == 3 ) then
              write(filename_test,'(A,I3.3,I3.3)') 'min/ext/bathy_',ite_min,ite_line_search
              open(1234,file=filename_test,form='formatted')
              do i = 3,(size(bathy_cell(:))-2)           
                 write(1234,*) bathy_cell(i)
              end do
              close(1234)
            endif
#endif
            
!             print *, "control_back:", control_back
!             print *, "ITE:", ite_min, ite_line_search
!             read(*,*)
            

         end if

         !========================================================================================!
         !  As M1QN3 is sequential, only master thread perform the minimization
         !  The control vector is managed in the module m_adjoint
         !========================================================================================!

         !=====================================================================================!
         !  Store the initial cost and its gradient norm
         !=====================================================================================!

         if ( ite_min == 0 .and. indic == 4 ) then
               
            cost_ini  =  cost
            
            norm_gradJ_ini  =  sqrt( sum( control_back(:) * control_back(:) ) )
               
            i = 1

            do k = 1,nb_vars_in_control
                  
               norm_grad_cost_ini(k) = sqrt( sum( control_back( i : i - 1 + dim_vars_in_control(k) ) * &
                    control_back( i : i - 1 + dim_vars_in_control(k) ) ) )

               i = i + dim_vars_in_control(k)

            end do

         end if

         !=====================================================================================!
         !  Normalization of the control vector, its gradient,
         !     and the appropriate change of control vector for the normalizaton to be consistent
         !=====================================================================================!
         if ( normalize_gradJ_and_J ) then

            !=====================================================================================!
            !  "Normalization" of the control vector
            !=====================================================================================!

            i = 1
            
            do k = 1,nb_vars_in_control
               
               control( i : i - 1 + dim_vars_in_control(k) ) = &
               control( i : i - 1 + dim_vars_in_control(k) ) * norm_grad_cost_ini(k) / cost_ini
               i = i + dim_vars_in_control(k)

            end do

            !=====================================================================================!
            !  Normalization of the cost and its gradient
            !=====================================================================================!

            if ( indic == 4 ) then

               ! Cost
               cost = cost / cost_ini
               
               ! Cost gradient
               i = 1
               do k = 1,nb_vars_in_control
                  
                  control_back( i : i - 1 + dim_vars_in_control(k) ) = &
                  control_back( i : i - 1 + dim_vars_in_control(k) ) / norm_grad_cost_ini(k)

                  i = i + dim_vars_in_control(k)

               end do

            end if

         end if

         !=====================================================================================!
         !  Output the evolution of the cost and its gradient norm
         !=====================================================================================!

         if ( indic == 4 ) then
            
            i = 1
            do k = 1,nb_vars_in_control
               
               norm_grad_cost(k) = sqrt( sum( control_back( i : i - 1 + dim_vars_in_control(k) ) * &
                    control_back( i : i - 1 + dim_vars_in_control(k) ) ) )
               
               i = i + dim_vars_in_control(k)
               
            end do
            
            norm_gradJ  =  sqrt( sum( control_back(:) * control_back(:) ) )
            
            if (norm_gradJ / norm_gradJ_ini > 1e+6) indic = -1
            if (isNaN(norm_gradJ)) indic = -1
            
            !  Compute the noise reduction factor
            gam_noise = 0._rp
            
            denom_gam_noise = 0._rp
            
            do iobs = 1,size( station )

               do idiff = 1,size( innovation( iobs )%diff )
               
                  if (station( iobs )%h_bathy( idiff ) > -1e+12) then
            
                     gam_noise = gam_noise + innovation( iobs )%diff( idiff )**2
                     
                     denom_gam_noise = denom_gam_noise + 1.0 / station( iobs )%weight
                     
                  end if
                  !err_tmp = err_tmp + sqrt(innovation( iobs )%diff( idiff )**2)
                  !nb_pts_cost = nb_pts_cost+1
               end do
            
            end do
            gam_noise = gam_noise / denom_gam_noise

            if ( normalize_gradJ_and_J ) then
               write(6,'("ite ",I3," , J =",ES13.6," , |grad J| =",ES13.6, " , gam_noise =",ES13.6)') &
                    ite_min , cost , norm_gradJ , gam_noise
            else
               write(6,'("ite ",I3," , J =",ES13.6," , |grad J| =",ES13.6, " , gam_noise =",ES13.6)') &
                    ite_min , cost/cost_ini , norm_gradJ/norm_gradJ_ini , gam_noise
            end if
         end if
         
         !=====================================================================================!
         !  dJ_expect is df1 in the M1QN3 documentation
         !=====================================================================================!

         dJ_expect = 0.5_rp * cost
         
#ifdef WRITE_EXTRA_FILES
         write(filename_test,'(A,I3.3,I3.3)') 'min/control_BACK_m1qn3_',ite_min,ite_line_search
         open(1234,file=filename_test,form='formatted')
         do i=1, size(control)
            write(1234,*) control_back(i)
         enddo
         close(1234)
#endif
         write(32,'(2I4,102ES15.7)') ite_min, ite_line_search, cost_obs, cost_regul, cost_regul_parts
            
         !=====================================================================================!
         !  Call of M1QN3
         !=====================================================================================!
         if (run_status < 0) indic = -1
         
         call m1qn3( simul_rc     , &
              euclid       , &
              ctonbe       , &
              ctcabe       , &
              n            , & ! n Dimension of pbl
              control      , & ! x
              cost         , & ! f
              control_back , & ! g
              dxmin        , &
              dJ_expect    , & !df1
              epsg         , &
              normtype     , &
              impres       , &
              io           , &
              imode        , &
              omode        , &
              niter        , &
              nsim         , &
              iz           , &
              dz           , &
              ndz          , &
              reverse      , &
              indic        , &
              izs          , &
              rzs          , &
              dzs )

         !=====================================================================================!
         !  Back normalization of the control vector in order to output it
         !=====================================================================================!
         if ( normalize_gradJ_and_J ) then
            
            i = 1
            do k = 1,nb_vars_in_control

               control( i : i - 1 + dim_vars_in_control(k) ) = &
               control( i : i - 1 + dim_vars_in_control(k) ) / norm_grad_cost_ini(k) * cost_ini

               i = i + dim_vars_in_control(k)

            end do
         end if
         
         call write_restart_m1qn3
            
         !=======================================================================================!
         !  Case indic = 1 -> M1QN3 has finished an iterate ( imode(3) = 1 )
         !=======================================================================================!

         if ( indic == 1 ) then

            call output_control( dof0 , mesh )

            write(30,'(I4,102ES15.7)') ite_min , cost , norm_grad_cost(1:nb_vars_in_control)
            if (normalize_gradJ_and_J) then
               write(31,'(I4,102ES15.7)') ite_min , cost * cost_ini, gam_noise
            else
               write(31,'(I4,102ES15.7)') ite_min , cost, gam_noise
            end if

            ite_min = ite_min + 1

            ite_line_search = 0
            
            !   Check Morozov condition
            if (gam_noise < eps_morozov .and. ite_min > 0) then
            
               indic = 0
               omode = 10
               write(io, '(1x,79("-")/)')
               write(io, '(" m1qn3: output mode is ", i2)') omode
               write(io, '(5x,"number of iterations: ", i14)') niter
               write(io, '(5x,"number of simulations:", i13)') nsim
               write(io, '(5x,"realized relative precision on g: ",1pd9.2)') epsg
               write(io, '(5x,"f             = ",1pd15.8)') cost
               write(io, '(5x,"two-norm of g = ",1pd15.8)') sqrt(sum(control_back**2))
               
            end if
              
!          else if ( indic == 4 .and. ite_line_search > 25 ) then
! 
!             !call Stopping_Program_Sub( 'Stopping Minimization, too much iterations in line-search' )
!             write(*,*) 'Stopping Minimization, too much iterations in line-search'
!             indic = 0
!             omode = 3

         end if

      end do

      close(30)
      close(31)
      close(40)
#endif

      






      
#ifdef USE_N2QN1

      if ( var_chg ) then
         print*, '===> NOT TESTED WITH THE CHANGE OF VARIABLES'
         stop
      end if
      !================================================================================================================!
      !  Parameters for N2QN1
      !================================================================================================================!
      n          =   size( control )
      epsg       =   eps_min
      impres     =   -1
      io         =   6
      omode      =   1
      nsim       =   100
      niter      =   nsim
      ndz        =   n * ( n + 9 ) / 2
      allocate( iz( 2*n+1 ) )
      allocate( dz( ndz ) )
      allocate( dx( n ) )
      allocate( gradJ( n ) )

      !================================================================================================================!
      !  Compute bounds
      !================================================================================================================!
      call write_control_bounds( dof0 , mesh )
      
      !================================================================================================================!
      !  Compute dxmin
      !================================================================================================================!
      dx(:) = 1.0e-3
!       do k = 1, size(control)
!         dx(k) = 1e-9 * 10.0_rp**int(log10(max(abs(control(k)), abs(control_ubound(k)))))
!       end do

      !================================================================================================================!
      !  Initialization (TODO : Restarting ?)
      !================================================================================================================!
      open(30,file='min/min_cost.txt'    ,status='replace',form = 'formatted')
!       open(40,file='min/m1qn2_output.txt',status='replace',form = 'formatted')
      write(30,'(A)') '# ite cost norm_grad_cost'
      iz(:) = 0

      !================================================================================================================!
      !  Computation of initial cost and gradients
      !================================================================================================================!
      cost_back = one
      verbose = -1
      ite_min = 0
      ite_line_search = 0
      call simul_n2qn1(4, n, control, J, gradJ, izs, rzs, dzs)
      call output_control( dof0 , mesh )
      dzs(1) = cost
! 
      !================================================================================================================!
      !  Minimization ... N2QN1
      !================================================================================================================!
      J = cost
      dJ_expect = 2.0_rp * cost
      gradJ(:) = control_back(:)
      
      call n2qn1(simul_n2qn1, &     ! simul
                 n, &
                 control, &         ! x
                 J, &               ! f
                 gradJ, &           ! g
                 dx, &              ! dxmin
                 dJ_expect, &       ! df1
                 epsg, &            ! epsabs
                 impres, &          ! imp
                 io, &
                 omode, &           ! mode
                 niter, &           ! iter
                 nsim, &
                 control_lbound, &  ! binf
                 control_ubound, &  ! bsup
                 iz, &
                 dz, &
                 izs, &
                 rzs, &
                 dzs)

      close(30)
#endif
#ifdef USE_LBFGSB3

      !================================================================================================================!
      !  Parameters for LBFGSB 3.0
      !================================================================================================================!
      n          =   size( control )
      m          =   5
      factr      =   eps_min / epsilon(one)
      impres     =   -1
      epsg       =   eps_min
      allocate( iz( 3 * n ) )
      allocate( dz( 2 * m * n + 5 * n + 11 * m * m + 8 * m ) )
      allocate( nbd( n ) )
!       nbd(1) = 2
!       nbd(2) = 2
      ite_line_search = 0
!       allocate( dx( n ) )
!       allocate( gradJ( n ) )

      !================================================================================================================!
      !  Compute bounds
      !================================================================================================================!
      call write_control_bounds( dof0 , mesh )
      do k = 1, size(control)
         if (control_ubound(k) - control_lbound(k) < 1e-9) then
            nbd(k) = 0
         else
            nbd(k) = 2
         end if
      end do

      !================================================================================================================!
      !  Rerun
      !================================================================================================================!
      inquire( file = 'min/rerun.txt' , exist = file_exist(1) )

      if ( ite_min == 0 .and. file_exist(1) ) then
      
         call Print_Screen('rerun_min')
         
         open(60, file='min/rerun.txt',status='old')
         read(60, *) control
         close(60)
         
      end if

      !================================================================================================================!
      !  Initialize LBFGSB
      !================================================================================================================!
      task       = 'START'
      call setulb ( n, &
                    m, &
                    control, &            ! x
                    control_lbound, &     ! l
                    control_ubound,&      ! u
                    nbd, &
                    cost, &               ! f
                    control_back, &       ! g
                    factr, & !eps_min, &            ! factr
                    epsg, &               ! pgtol
                    dz, &                 ! wa
                    iz, &                 ! iwa
                    task, &
                    impres, &             !iprint
                    csave, &
                    lsave, &
                    isave, &
                    dsave )
                    
      !================================================================================================================!
      !  Initialization (TODO : Restarting ?)
      !================================================================================================================!
      open(30,file='min/min_cost.txt'    ,status='replace',form = 'formatted')
!       open(40,file='min/m1qn2_output.txt',status='replace',form = 'formatted')
      write(30,'(A)') '# ite cost norm_grad_cost'
      
      do while(task(1:2) == "FG" .or. task == "NEW_X" .or. &
               task == "START")
                      
         !=============================================================================================================!
         !  task = FG -> LBFGSB-3.0 needs new values of the cost and its gradient
         !=============================================================================================================!
         if (task(1:2) == "FG") then

            ! recalc the regularization coeff
            if (ite_period_alpha_reg_calc > 0) then
               if ( modulo(ite_min, ite_period_alpha_reg_calc) == 0 .and. ite_line_search == 0) then
                  recalc_alpha_regul = 1
               end if
            end if
         
            if (isave(36) > 25) then
              write(*,*) 'Stopping Minimization, too much iterations in line-search'
              task='STOP: TOTAL NO. of f AND g EVALUATIONS EXCEEDS LIMIT'
            end if
        
            cost_back = one

            verbose = -1
            
            call adjoint_model( mesh , dof0 , dof )
            
            
            ! make plots !
            open(1234,file="min/hydrograph_current",form='formatted')
            do i=1, size(bc%hyd%q)
               write(1234,*) bc%hyd%q(i)
            enddo
            close(1234)
            open(1234,file="min/manning_current",form='formatted')
            do i=1,K_params%nb_diff_K_reachs
               write(1234,*) K_params%alpha(K_params%cs_start(i)), K_params%beta(K_params%cs_start(i))
            enddo
            close(1234)
            open(1234,file="min/bathy_current",form='formatted')
            do i=3,mesh%ncs+2
               write(1234,*) bathy_cell(i)
            enddo
            close(1234)
            open(1234,file="min/control_back_current",form='formatted')
            do i=1, size(control)
               write(1234,*) control_back(i)
            enddo
            close(1234)
            call system("plot_ite_QKB.py")

            ite_line_search = ite_line_search + 1
            ! TMP: to see the evolution of the control inside the linesearch
            write(filename_test,'(A,I3.3,I3.3)') 'min/control_lbfgsb3_',ite_min,ite_line_search
            open(1234,file=filename_test,form='formatted')
            do i=1, size(control)
               write(1234,*) control(i)
            enddo
            close(1234)
            
            if ( c_hydrograph == 1 ) then
              write(filename_test,'(A,I3.3,I3.3)') 'min/delta_hydrograph',ite_min,ite_line_search
              open(1234,file=filename_test,form='formatted')
              do i=1, size(bc%hyd%q)
                write(1234,*) qin_fg(i) - bc%hyd%q(i), qin_chg(i)
              enddo
              close(1234)
            endif            
            
         end if
         

         !=============================================================================================================!
         !  Store the initial cost and its gradient norm
         !=============================================================================================================!

         if ( isave(30) == 0 .and. isave(36) == 0 .and. task(1:2) == "FG" ) then
            
            cost_ini  =  cost
            
            i = 1

            do k = 1, nb_vars_in_control

              norm_grad_cost_ini(k) = sqrt( sum( control_back( i : i - 1 + dim_vars_in_control(k) ) * &
                                                  control_back( i : i - 1 + dim_vars_in_control(k) ) ) )

              i = i + dim_vars_in_control(k)

            end do
            
         end if

         !=============================================================================================================!
         !  Normalization of the control vector and bounds
         !=============================================================================================================!
               
         if (task == "FG_START") then
            call output_control( dof0 , mesh )
         end if

         
         if ( normalize_gradJ_and_J ) then
            i = 1
            do k = 1,nb_vars_in_control
                control( i : i - 1 + dim_vars_in_control(k) ) = &
                control( i : i - 1 + dim_vars_in_control(k) ) * norm_grad_cost_ini(k) / cost_ini
                control_lbound( i : i - 1 + dim_vars_in_control(k) ) = &
                control_lbound( i : i - 1 + dim_vars_in_control(k) ) * norm_grad_cost_ini(k) / cost_ini
                control_ubound( i : i - 1 + dim_vars_in_control(k) ) = &
                control_ubound( i : i - 1 + dim_vars_in_control(k) ) * norm_grad_cost_ini(k) / cost_ini
                i = i + dim_vars_in_control(k)

            end do
         end if

         !=============================================================================================================!
         !  Normalization of the cost, its gradient and the control vector
         !=============================================================================================================!

         if ( task(1:2) == "FG" ) then

            !cost = cost / cost_ini

            i = 1

            do k = 1,nb_vars_in_control
            
              if ( normalize_gradJ_and_J ) then
                 control_back( i : i - 1 + dim_vars_in_control(k) ) = &
                 control_back( i : i - 1 + dim_vars_in_control(k) ) / norm_grad_cost_ini(k)
              end if
        
              norm_grad_cost(k) = sqrt( sum( control_back( i : i - 1 + dim_vars_in_control(k) ) * &
                                              control_back( i : i - 1 + dim_vars_in_control(k) ) ) )

              i = i + dim_vars_in_control(k)

            end do

            norm_gradJ  =  sqrt( sum( control_back(:) * control_back(:) ) )

            write(6,'("ite ",I3," , J =",ES13.6," , |grad J| =",ES13.6, " , time =",ES13.6)') &
            isave(30) , cost , norm_gradJ , time(1)
            
            if (task == "FG_START") then
            write(30,'(I4,102ES15.7)') 0, cost , norm_grad_cost(1:nb_vars_in_control)
            end if

         end if
         
         !=============================================================================================================!
         !  Call of LBFGSB
         !=============================================================================================================!
         call setulb ( n, &
                       m, &
                       control, &            ! x
                       control_lbound, &     ! l
                       control_ubound,&      ! u
                       nbd, &
                       cost, &               ! f
                       control_back, &       ! g
                       factr, & !eps_min, &            ! factr
                       epsg, &               ! pgtol
                       dz, &                 ! wa
                       iz, &                 ! iwa
                       task, &
                       impres, &             !iprint
                       csave, &
                       lsave, &
                       isave, &
                       dsave )
         
         print *, "TASK:", trim(task), cost

         !=============================================================================================================!
         !  Back normalization of the control vector in order to output it
         !=============================================================================================================!
         
         if ( normalize_gradJ_and_J ) then
            i = 1

            do k = 1,nb_vars_in_control

                control( i : i - 1 + dim_vars_in_control(k) ) = &
                control( i : i - 1 + dim_vars_in_control(k) ) / norm_grad_cost_ini(k) * cost_ini
                control_lbound( i : i - 1 + dim_vars_in_control(k) ) = &
                control_lbound( i : i - 1 + dim_vars_in_control(k) ) / norm_grad_cost_ini(k) * cost_ini
                control_ubound( i : i - 1 + dim_vars_in_control(k) ) = &
                control_ubound( i : i - 1 + dim_vars_in_control(k) ) / norm_grad_cost_ini(k) * cost_ini

                i = i + dim_vars_in_control(k)

            end do
         end if 

         !=============================================================================================================!
         !  Case task = NEW_X -> LBFGSB-3.0 has finished an iterate
         !=============================================================================================================!
         if (task == "NEW_X") then
         
            ite_min = ite_min + 1
            ite_line_search = 0

            !  Updates the regularization factor
            if (ite_period_alpha_reg_calc > 0) then
               if ( modulo(ite_min, ite_period_alpha_reg_calc) == 0 ) then
                  recalc_alpha_regul = 1
               end if
            end if

            call output_control( dof0 , mesh )
            write(30,'(I4,102ES15.7)') ite_min , cost , norm_grad_cost(1:nb_vars_in_control)

         end if
         
      end do
      close(30)
      
      if (task(1:5) == "ERROR") then
        omode = 2
         write(*,*) 'LBFGSB-3: '//trim(task)
      else if (task(1:4) == "ABNO") then
        omode = 6
      else
        omode = 1
      end if
      print *, 'FINAL_TASK=', trim(task)
#endif


      !call mpi_wait_all

      deallocate( dz )

      if ( omode == -1 .or. &
           omode == 1 .or. &
           omode == 10 .or. &
           omode == 3 .or. &
           omode == 4 .or. &
           omode == 5 .or. &
           omode == 6 ) then
           
         call Print_Screen( 'start_direct_optimum' )

         verbose = -1

         w_obs = 1
         
         call model_direct( mesh , dof0 , dof )

         call Print_Screen( 'cost' , cost )

      end if

      if      ( omode == 1 ) then

         !call Stopping_Program_Sub( 'Successful Minimization, the test on the gradient norm (eps_min) is satisfied' )
         write(*,*) 'Successful Minimization, the test on the gradient norm (eps_min) is satisfied'

      else if ( omode == 10 ) then

         write(*,*) 'Successful Minimization, the test on Morozov criterion (eps_morozov) is satisfied'

      else if ( omode == 2 ) then

         !call Stopping_Program_Sub( 'Stopping Minimization, input parmeter not well initialized (omode=2 in the M1QN3 documentation)' )
         write(*,*) 'Stopping Minimization, input parmeter not well initialized (omode=2 in the M1QN3 documentation)'

      else if ( omode == 3 ) then

         !call Stopping_Program_Sub( 'Stopping Minimization, the line-search is blocked (omode=3 in the M1QN3 documentation)' )
         write(*,*) 'Stopping Minimization, the line-search is blocked (omode=3 in the M1QN3 documentation)'

      else if ( omode == 4 ) then

         !call Stopping_Program_Sub( 'Stopping Minimization, maximal number of iterations reached (omode=4 in the M1QN3 documentation)' )
         write(*,*) 'Stopping Minimization, maximal number of iterations reached (omode=4 in the M1QN3 documentation)'

      else if ( omode == 5 ) then

         !call Stopping_Program_Sub( 'Stopping Minimization, maximal number of simulations reached (omode=5 in the M1QN3 documentation)' )
         write(*,*) 'Stopping Minimization, maximal number of simulations reached (omode=5 in the M1QN3 documentation)' 

      else if ( omode == 6 ) then

         !call Stopping_Program_Sub( 'Stopping Minimization, stop on dxmin during the line-search (omode=6 in the M1QN3 documentation)' )
         write(*,*) 'Stopping Minimization, stop on dxmin during the line-search (omode=6 in the M1QN3 documentation)'

      else

         !call Stopping_Program_Sub( 'Stopping Minimization, unknown reason !?)' )
         write(*,*) 'Stopping Minimization, unknown reason !?)', omode
      end if


   CONTAINS

      !> Write a restart file for the m1qn3 minimization
      !!
      !! \details This subroutine writes a restart file. This restart file is used to start again a minimization computation.
      !! In this restart file, there are for example ite_min, ite_line_search, rever, cost, control variables.
      SUBROUTINE write_restart_m1qn3

         implicit none

         open(50,file='min/restart_min.bin',status='replace',form='unformatted')

         write(50) ite_min , ite_line_search , reverse , indic , epsg , iz , dz, &
                      control , cost , control_back , cost_ini , norm_grad_cost_ini

         close(50)

        

      END SUBROUTINE write_restart_m1qn3

      !> Read a restart file for the m1qn3 minimization
      !!
      !! \details This subroutine reads a restart file. This restart file is used to start again a minimization computation.
      !! In this restart file, there are for example ite_min, ite_line_search, rever, cost, control variables.
      SUBROUTINE read_restart_m1qn3

         implicit none

         open(50,file='min/restart_min.bin',status='old',form='unformatted')

         read(50) ite_min , ite_line_search , reverse , indic , epsg , iz , dz, &
                  control , cost , control_back , cost_ini , norm_grad_cost_ini

         close(50)
         print *, "read_restart_m1qn3:", control
         read(*,*)

      END SUBROUTINE read_restart_m1qn3

      !> Simulator routine for M2QN1
      !!
      !! \details This subroutine computes the cost and gradients using the adjoint method
      SUBROUTINE simul_n2qn1(indic, n, x, f, g, izs, rzs, dzs)

         implicit none
         integer(ip) :: indic
         integer(ip) :: n
         double precision, dimension(n) :: x
         double precision :: f
         double precision, dimension(n) :: g
         integer, dimension(*) :: izs
         real, dimension(*) :: rzs
         double precision, dimension(*) :: dzs
         
         if ( indic == 1 ) then
         
            call output_control( dof0 , mesh )
            write(30,'(I4,102ES15.7)') ite_min , cost , norm_grad_cost(1:nb_vars_in_control)
            ite_min = ite_min + 1
            ite_line_search = 0
            
         end if
         if ( indic == 4 ) then
         
            control(:) = x(:)
            cost_back = one
            verbose = -1
            call adjoint_model( mesh , dof0 , dof )
            f = cost
            g(:) = control_back(:)
            ite_line_search = ite_line_search + 1
            ! TMP: to see the evolution of the control inside the linesearch
!             write(filename_test,'(A,I3.3,I3.3)') 'tmp/control_n1qn2_',ite_min,ite_line_search
!             open(1234,file=filename_test,form='formatted')
!             do i=1, size(control)
!                write(1234,*) control(i), control_lbound(i), control_ubound(i)
!             enddo
!             close(1234)
!             write(filename_test,'(A,I3.3,I3.3)') 'tmp/grad_n1qn2_',ite_min,ite_line_search
!             open(1234,file=filename_test,form='formatted')
!             do i=1, size(control)
!                write(1234,*) i, control_back(i)
!             enddo
!             close(1234)
            norm_gradJ  =  sqrt( sum( control_back(:) * control_back(:) ) )
            if (ite_min == 0) then
               dzs(1) = cost
               dzs(2) = norm_gradJ
            end if
            write(6,'("ite ",I3," , J =",ES13.6," , |grad J| =",ES13.6, " , time =",ES13.6)') &
                  ite_min , cost / dzs(1) , norm_gradJ / dzs(2) , time(1)
         end if

      END SUBROUTINE simul_n2qn1

   END SUBROUTINE minimize_cost
   
   


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main subroutine of rerun
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Main subroutine of rerun
   !!
   !! \details The rerun is computed from the control vector read from a prescribed iteration
   !! the control vector minimize.
   !! \param[in]    mesh Mesh of the model.
   !! \param[inout] dof0 Initial conditions.
   !! \param[inout] dof Unknowns.
   SUBROUTINE rerun_model( mesh , dof0 , dof , ite_rerun )
   
      use m_obs, only : recalc_alpha_regul

      implicit none

      !===========================================================================================!
      !  Interface Variables
      !===========================================================================================!

      type( msh ), intent(in   )  ::  mesh
      type( unk ), intent(inout)  ::  dof0
      type( unk ), intent(inout)  ::  dof
      integer(ip), intent(in   )  ::  ite_rerun

      !===========================================================================================!
      !  Local Variables
      !===========================================================================================!

      external  simul_rc , euclid , ctonbe , ctcabe

      integer(ip)  ::  i           ! File output label
      real(rp)  ::  tmp
      character(len=lchar)  ::  file_name

      !===========================================================================================!
      !  Initialization
      !===========================================================================================!

!       call system('mkdir -p min')

      var_chg = .false.

      call alloc_back_vars( dof0_back , dof_back , mesh )


      !==========================================================================================!
      !  Initialization
      !==========================================================================================!
      
      #ifdef USE_SW_MONO

      if (c_hydrograph == 1 ) then

         write(file_name,'(A,I3.3)') 'min/hydrograph_' , ite_rerun
         open(10,file=file_name, status='old', form='formatted')
         print *, "RERUN:hydrograph:", file_name
         do i = 1,size( bc%hyd%t(:) )
            read(10,*) tmp, bc%hyd%q(i)
            print *, bc%hyd%t(i), bc%hyd%q(i)
         end do
         close(10)
         print *, "RERUN:hydrograph=", bc%hyd%q(:)
         
      end if


      if ( c_manning == 1 ) then

        write(file_name,'(A,I3.3)') 'min/manning_' , ite_rerun
        open(10,file=file_name, status='old', form='formatted')

        do i = 1,K_params%nb_diff_K_reachs
            read(10,*) K_params%alpha(K_params%cs_start(i)), K_params%beta(K_params%cs_start(i))
        end do
        
        close(10)

      end if

      if ( c_bathy == 1 .or. c_bathy == 3 ) then

        write(file_name,'(A,I3.3)') 'min/bathy_' , ite_rerun
        open(10,file=file_name, status='old', form='formatted')

        do i = 3,(size(bathy_cell(:))-2)           
            read(10,*) bathy_cell(i)
        end do
        
        close(10)

      end if
      
      call write_control( dof0 , mesh )
      
      verbose = 1
      
      call model_direct( mesh , dof0 , dof )
      
      #endif
      
   END SUBROUTINE rerun_model
   

END MODULE m_minimization
