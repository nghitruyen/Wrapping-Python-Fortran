!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file sw_flux.f90
!! \brief This file includes computation fluxes and pressure terms subroutine.


!> This subroutine return the pressure term \f$pt_i\f$  computed for variables \f$h\f$ and \f$s\f$ at the 
!! cross-section \f$i\f$.
!! \details Algorithm used:\n
!! - if \f$s<=0\f$:
!!    - \f$pt_i=0\f$ 
!! - if \f$s<=s_i^0\f$:
!!    - \f$pt_i=0.5 w_i^0 h^2\f$
!! - if \f$s_i>s_i^0\f$:
!!       - Find \f$m\f$
!!       - \f$P = \sum_{j=0}^m w_i^{j-1}(h(h_i^j-h_i^{j-1})+0.5((h_i^{j-1})^2-(h_i^{j})^2 ))
!! +(\alpha_{1i}^j+\alpha_{2i}^{j})( \frac{(h_i^{j-1})^3-(h_i^{j})^3}{3}+(h+h_i^{j})\frac{h^2-(h_i^j)^2}{2}+
!! hh_i^j(h_i^{j}-h))\f$
!!       - \f$pt_i=P+ w_i^m(h(h-h_i^m)+0.5((h_i^m)^2-h^2))+(\alpha_{1}^{m+1}+\alpha_{2}^{m+1})
!! \frac{(h_i^m)^3-h^3}{3}+(h+h_i^m)\frac{h^2-(h_i^m)^2}{2}+h h_i^m ( h_i^m-h)\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] h  Water height \f$h\f$.
!! \param[in] s  Water surface \f$s\f$.
!! \param[in] im  Index \f$i\f$ of the cross section.
!! \param[out] pressureloc  Pression term \f$pt_i\f$ computed in point \f$i\f$.
SUBROUTINE PressureTerms(mesh,h,s,im,pressureloc)
   USE m_model
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)    ::  mesh
   real(rp)   , intent(in)    ::  h,s
   integer(ip), intent(in)    ::  im
   real(rp)   , intent(out)   ::  pressureloc

   integer(ip) :: findmsurface
   integer(ip) :: m, m_max
   integer(ip) ::indexLevel

   real(rp)    :: wjm1,wj
   real(rp)    :: hjm1,hj
   real(rp)    :: alpha1,alpha2


      !Pressure in no-water area
      if (s.le.0._rp) then
         pressureloc=0.0_rp !.0_rp

      !Pressure in the rectangular channel
      else if (s.le.mesh%crosssection(im)%surfacearea(1)) then
         pressureloc=(demi*(mesh%crosssection(im)%surfacewidth(1))*h**2) !P=0.5*w*h**2 (see doc) if h=0 -> P=0
         
      !If s>s0
      else
         pressureloc=0.0_rp !._rp
         m=findMSurface(mesh,s,im)
         m_max = size(mesh%CrossSection(im)%surfacewidth)
         indexLevel=1
         wj     = mesh%CrossSection(im)%surfacewidth(indexLevel  )
         !hj     = mesh%CrossSection(im)%height(indexLevel  )-mesh%CrossSection(im)%elevation
         hj     = mesh%CrossSection(im)%height(indexLevel  )-bathy_cell(im)
         
         pressureloc=wj*(h*hj-demi*hj**2) !PressureTerms in the rectangular channel

         do while (indexLevel.lt.(min(m, m_max))) ! PressureTerms computation in each "full trapezium" 
            wj     = mesh%CrossSection(im)%surfacewidth(indexLevel+1  )
            wjm1   = mesh%CrossSection(im)%surfacewidth(indexLevel)

            !hj     = mesh%CrossSection(im)%height(indexLevel+1  )-mesh%CrossSection(im)%elevation
            hj     = mesh%CrossSection(im)%height(indexLevel+1  )-bathy_cell(im)
            !hjm1   = mesh%CrossSection(im)%height(indexLevel)-mesh%CrossSection(im)%elevation
            hjm1   = mesh%CrossSection(im)%height(indexLevel   ) -bathy_cell(im)
            
            alpha1 = mesh%CrossSection(im)%alpha1(indexLevel+1)
            alpha2 = mesh%CrossSection(im)%alpha2(indexLevel+1)

            !  P= sum(w_{j-1}*(h*(hj-h{j-1})+0.5*(h_{j-1}^2-h_{j}^2))+(alpha1+alpha2)((h_{j-1}^3-h_j^3)/3+(h+h_j)*(h^2-h_j^2)/2+h*h_j(h_j-h))
            pressureloc=pressureloc+(wjm1*(h*(hj-hjm1)+demi*(hjm1**2-hj**2))+(alpha1+alpha2)*   & !w_{j-1}*(h*(hj_h{j-1})+0.5*(h_{j-1}^2-h_{j}^2))+(alpha1+alpha2)
                     (d1p3*(hjm1**3-hj**3)+(h+hjm1)*demi*(hj**2-hjm1**2)+h*hjm1*(hjm1-hj))) !((h_{j-1}^3-h_j^3)/3+(h+h_j)*(h^2-h_j^2)/2+h*h_j(h_j-h))
            indexLevel=indexLevel+1

         end do
         if (m >= m_max) then
            !  PressureTerms computation in the rectangle above all levels
            !  P= P+ 0.5*w_m*(h-h_m)**2
            hj     = mesh%CrossSection(im)%height(m_max  )-bathy_cell(im)
            wj     = mesh%CrossSection(im)%surfacewidth(m_max  )
            pressureloc=pressureloc+0.5*wj*(h-hj)**2
            !  h*hm(hm-h))
            !
         else
            !  PressureTerms computation in the last trapezium
            !  P= P+ w_m*(h*(h_hm)+0.5*(h_m^2-h^2))+(alpha1+alpha2)((hm^3-h^3)/3+(h+hm)*(h^2-hm^2)/2+
            !  h*hm(hm-h))
            !
            alpha1 = mesh%CrossSection(im)%alpha1(m+1)
            alpha2 = mesh%CrossSection(im)%alpha2(m+1)
            !hj     = mesh%CrossSection(im)%height(m  )-mesh%CrossSection(im)%elevation
            hj     = mesh%CrossSection(im)%height(m  )-bathy_cell(im)
            wj     = mesh%CrossSection(im)%surfacewidth(m  )
            pressureloc=pressureloc+(wj*(h*(h-hj)+demi*(hj**2-h**2))+(alpha1+alpha2)*  &
                        (d1p3*(hj**3-h**3)+(h+hj)*demi*(h**2-hj**2)+h*hj*(hj-h)))
         endif
      endif

      pressureloc=pressureloc*g

END SUBROUTINE PressureTerms

!> This subroutine return the vector pressure term \f$pt\f$  computed from variables \f$h\f$ and \f$s\f$ for all 
!! cross-section \f$i\f$.
!! \details Algorithm used:\n
!! For all nodes i :\n
!! - if \f$s<=0\f$:
!!    - \f$pt_i=0\f$ 
!! - if \f$s<=s_i^0\f$:
!!    - \f$pt_i=0.5 w_i^0 h^2\f$
!! - if \f$s_i>s_i^0\f$:
!!       - Find \f$m\f$
!!       - \f$P = \sum_{j=0}^m w_i^{j-1}(h(h_i^j-h_i^{j-1})+0.5((h_i^{j-1})^2-(h_i^{j})^2 ))
!! +(\alpha_{1i}^j+\alpha_{2i}^{j})( \frac{(h_i^{j-1})^3-(h_i^{j})^3}{3}+(h+h_i^{j})\frac{h^2-(h_i^j)^2}{2}+
!! hh_i^j(h_i^{j}-h))\f$
!!       - \f$pt_i=P+ w_i^m(h(h-h_i^m)+0.5((h_i^m)^2-h^2))+(\alpha_{1}^{m+1}+\alpha_{2}^{m+1})
!! \frac{(h_i^m)^3-h^3}{3}+(h+h_i^m)\frac{h^2-(h_i^m)^2}{2}+h h_i^m ( h_i^m-h)\f$
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] dof Unknowns of the model.
!! \param[in] mvector Vector \f$m\f$ updated. 
!! \param[inout] pressureSG  Pression term  vector \f$pt\f$ computed for all points of the mesh.
SUBROUTINE pressureSgUpdate(mesh,dof,mvector,pressureSg)
   USE m_model
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)    ::  mesh
   type( unk ), intent(in)  ::  dof
   integer(ip), dimension(mesh%ncs+4),intent(in)  ::  mvector 
   real(rp), dimension(mesh%ncs+4),intent(inout)  ::  pressureSg 
   
   integer(ip) :: findmsurface
   integer(ip) :: m,m_max,im
   integer(ip) ::indexLevel
  
   real(rp)    :: h,s
   real(rp)    :: wjm1,wj
   real(rp)    :: hjm1,hj
   real(rp)    :: alpha1,alpha2


   pressureSg(1)=0
   do im= 2,mesh%ncs+3
      h=dof%h(im)
      s=dof%s(im)
      !Pressure in no-water area
      if (s.le.0._rp) then
         pressureSg(im)=0.0_rp !.0_rp

      !Pressure in the rectangular channel
      else if (s.le.mesh%crosssection(im)%surfacearea(1)) then
         pressureSg(im)=(demi*(mesh%crosssection(im)%surfacewidth(1))*h**2) !P=0.5*w*h**2 (see doc) if h=0 -> P=0
         
      !If s>s0
      else
         pressureSg(im)=0.0_rp !._rp
         m=mvector(im)
         m_max = size(mesh%CrossSection(im)%surfacewidth)
         indexLevel=1
         wj     = mesh%CrossSection(im)%surfacewidth(indexLevel  )
         hj     = mesh%CrossSection(im)%height(indexLevel  )-bathy_cell(im)
         
         pressureSg(im)=wj*(h*hj-demi*hj**2) !PressureTerms in the rectangular channel

         do while (indexLevel.lt.(m)) ! PressureTerms computation in each "full trapezium" 
            wj     = mesh%CrossSection(im)%surfacewidth(indexLevel+1  )
            wjm1   = mesh%CrossSection(im)%surfacewidth(indexLevel)

            hj     = mesh%CrossSection(im)%height(indexLevel+1  )-bathy_cell(im)
            hjm1   = mesh%CrossSection(im)%height(indexLevel   ) -bathy_cell(im)
            
            alpha1 = mesh%CrossSection(im)%alpha1(indexLevel+1)
            alpha2 = mesh%CrossSection(im)%alpha2(indexLevel+1)

            !  P= sum(w_{j-1}*(h*(hj_h{j-1})+0.5*(h_{j-1}^2-h_{j}^2))+(alpha1+alpha2)((h_{j-1}^3-h_j^3)/3+(h+h_j)*(h^2-h_j^2)/2+h*h_j(h_j-h))
            pressureSg(im)=pressureSg(im)+(wjm1*(h*(hj-hjm1)+demi*(hjm1**2-hj**2))+(alpha1+alpha2)*   & !w_{j-1}*(h*(hj_h{j-1})+0.5*(h_{j-1}^2-h_{j}^2))+(alpha1+alpha2)
                     (d1p3*(hjm1**3-hj**3)+(h+hjm1)*demi*(hj**2-hjm1**2)+h*hjm1*(hjm1-hj))) !((h_{j-1}^3-h_j^3)/3+(h+h_j)*(h^2-h_j^2)/2+h*h_j(h_j-h))
            indexLevel=indexLevel+1

         end do
         if (m >= m_max) then
            !  PressureTerms computation in the rectangle above all levels
            !  P= P+ 0.5*w_m*(h-h_m)**2
            hj     = mesh%CrossSection(im)%height(m  )-bathy_cell(im)
            wj     = mesh%CrossSection(im)%surfacewidth(m  )
            pressureSg(im)=pressureSg(im)+0.5*wj*(h-hj)**2
            !  h*hm(hm-h))
            !
         else
            !  PressureTerms computation in the last trapezium
            !  P= P+ w_m*(h*(h_hm)+0.5*(h_m^2-h^2))+(alpha1+alpha2)((hm^3-h^3)/3+(h+hm)*(h^2-hm^2)/2+
            !  h*hm(hm-h))
            !
            alpha1 = mesh%CrossSection(im)%alpha1(m+1)
            alpha2 = mesh%CrossSection(im)%alpha2(m+1)
            hj     = mesh%CrossSection(im)%height(m  )-bathy_cell(im)
            wj     = mesh%CrossSection(im)%surfacewidth(m  )
            pressureSg(im)=pressureSg(im)+(wj*(h*(h-hj)+demi*(hj**2-h**2))+(alpha1+alpha2)*  &
                        (d1p3*(hj**3-h**3)+(h+hj)*demi*(h**2-hj**2)+h*hj*(hj-h)))
         endif
      endif
      pressureSg(im)=pressureSg(im)*g
   end do

END SUBROUTINE pressureSgUpdate

!> This subroutine return the  pressure term \f$pt\f$  computed from variables \f$h\f$ and \f$s\f$ at the interface
!! between cross-section im and imp.
!! \details Algorithm used:\n
!!       
!!    Compute pressure at point im
!!    Compute pressure at point imp
!!    Return the mean of the two computed pressure 
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] h Water height \f$h\f$.
!! \param[in] s Water surface \f$s\f$.
!! \param[in] im  Cross section left number.
!! \param[in] imp Cross section right number.
!! \param[out] pressure Pression term  \f$pt\f$ computed at the interface between im and imp.
SUBROUTINE PressureTerms_m(mesh,h,s,im,imp,pressure)
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)    ::  mesh
   real(rp)   , intent(in)    ::  h,s
   integer(ip), intent(in)    ::  im,imp
   real(rp)   , intent(out)   ::  pressure

   integer(ip) :: findmsurface
   integer(ip) :: m
   real(rp) :: p1,p2

   call PressureTerms(mesh,h,s,im,p1)   ! Computation on node left
   call PressureTerms(mesh,h,s,imp,p2)  ! Computation on node right
   pressure=demi*(p1+p2)               ! Interpolation on interface
END SUBROUTINE PressureTerms_m

!> This subroutine return the hydraulic radius \f$R_h\f$ for each cross-section.
!!
!! \details Algorithm used:\n
!!       
!!    For each node:
!!       If s<=0:
!!          Rh=0
!!       else :
!!          Rh=s/Pr
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] dof Unknowns of the model.
!! \param[out] hydraulicRadius Hydraulic radius \f$R_h\f$ computed for each cross-section.
SUBROUTINE computationRh(mesh,dof,hydraulicRadius)
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   type( unk ), intent(in)  ::  dof
   real(rp), dimension(mesh%ncs+4),intent(out) :: hydraulicRadius
   real(rp) ::  perimeter
   real(rp) :: PerimeterFromH

   do i=3,mesh%ncs+2 
      if ((dof%s(i).le.0.0_rp)) then 
         hydraulicRadius(i)=0.0_rp
      else 
         hydraulicRadius(i)=dof%s(i)/PerimeterFromH(mesh,dof%h(i),i) !By definition Rh=S/Pr (see doc)
      end if
   end do
END SUBROUTINE computationRh



!> This subroutine return the hydraulic radius \f$R_h\f$ for one cross-section \f$i\f$.
!!
!! \details Algorithm used:\n
!!       
!!    For the node \f$i\f$:
!!       If s<=0:
!!          Rh=0
!!       else :
!!          Rh=s/Pr
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] dof Unknowns of the model.
!! \param[out] hydraulicRadius Hydraulic radius  Mesh of the model.
!! \param[in] CrossSection Cross-section number.
!! \param[in] mvector Vector \f$m\f$.
SUBROUTINE computationRhCrossSection(mesh,dof,hydraulicRadius,CrossSection,mvector)
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   type( unk ), intent(in)  ::  dof
   integer(ip), intent(in)  ::  CrossSection
   real(rp),intent(out) :: hydraulicRadius
   integer(ip), dimension(mesh%ncs+4),intent(in)  ::  mvector 

   real(rp) ::  perimeter
   real(rp) :: PerimeterFromH

   i=CrossSection
      if ((dof%s(i).le.0.0_rp)) then 
         hydraulicRadius=0.0_rp
      else 
         hydraulicRadius=dof%s(i)/PerimeterFromH(mesh,dof%h(i),i,mvector) !By definition Rh=S/Pr (see doc)
      end if
END SUBROUTINE computationRhCrossSection



!> This subroutine compute the \f$S_g\f$ term for each cross-section
!!
!! \details Algorithm used:\n
!!      
!! The \f$S_g\f$ term is computed by :\n
!! \f$\mathcal{S}_{gi}^{n+1}=\frac{1}{2}{\displaystyle \sum_{k=1}^{N}}(z_{k+1}-z_{k})\left(\left(\bar{\tilde{h}}_{i}^{n+1}
!! -z_{k}\right)\frac{\left(\bar{\tilde{w}}_{i+1}^{n+1}(z_{k})-\bar{\tilde{w}}_{i-1}^{n+1}(z_{k})\right)}
!! {\Delta x_{i+1/2}+\Delta x_{i-1/2}}+\left(\bar{\tilde{h}}_{i}^{n+1}-z_{k+1}\right)\frac{\left(
!! \bar{\tilde{w}}_{i+1}^{n+1}(z_{k+1})-\bar{\tilde{w}}_{i-1}^{n+1}(z_{k+1})\right)}{\Delta x_{i+1/2}+\Delta x_{i-1/2}}
!! \right)-\bar{S}{}_{i}^{n+1}\frac{z_{bi+1}-z_{bi-1}}{\Delta x_{i+1/2}+\Delta x_{i-1/2}}\f$
!!
!! For more details see documentation.
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] dof Unknowns of the model.
!! \param[inout] sg \f$S_g\f$ term computed.
SUBROUTINE computationSg(mesh,dof,sg)
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   type( unk ), intent(in)  ::  dof
   real(rp), dimension(mesh%ncs+4),intent(inout) :: sg
   integer(ip) :: findmsurface
   real(rp) :: GetWFromH,dx
   integer(ip) :: m,l,r
   real(rp), dimension(150) :: winterL
   real(rp), dimension(150) :: winterR !TODO do modifier le 10 en max couple hi,wi definis
   real(rp), dimension(150) :: zinter !TODO do modifier le 10 en max couple hi,wi definis      
   real(rp) :: zb
   sg(1)=0.0_rp
   sg(1)=0.0_rp
!   write(*,'(A80)') '1'
   do i=3,(mesh%ncs+2)
      sg(i)=0.0_rp
      if ((dof%s(i).gt.0.0_rp)) then
         m=findMSurface(mesh,dof%s(i),i)
         l=i-1
         r=i+1
         !zb=mesh%crosssection(i)%elevation
         zb=bathy_cell(i)
         
         !Z0=0, w0l,w0r
         winterL(1)=GetWFromH(mesh,0._rp,l) !w0l
         winterR(1)=GetWFromH(mesh,0._rp,r) !w0R
         zinter(1)=0._rp                    !Z0

         if (m.le.0) then !if s<s0
            winterL(2)=GetWFromH(mesh,dof%h(i),l) !W2L=WNL
            winterR(2)=GetWFromH(mesh,dof%h(i),r) !W2R=WNR
            zinter(2)=dof%h(i)                    !Z2=ZN=h

         else !Else :
            do j=1,m !For each trapezium 
! DEPRECATED
!                winterL(j+1) = mesh%CrossSection(i)%wl    (j) !GetWFromH(mesh,mesh%crosssection(i)%height(j)-zb,l) 
!                winterR(j+1) = mesh%CrossSection(i)%wr    (j) !GetWFromH(mesh,mesh%crosssection(i)%height(j)-zb,r)
!                zinter(j+1)  = mesh%CrossSection(i)%zint  (j) !mesh%crosssection(i)%height(j)-zb !Zi=Hi
               winterL(j+1) = GetWFromH(mesh,mesh%crosssection(i)%height(j)-zb,l) 
               winterR(j+1) = GetWFromH(mesh,mesh%crosssection(i)%height(j)-zb,r)
               zinter(j+1)  = mesh%crosssection(i)%height(j)-zb !Zi=Hi
            end do

            !For last trapezium
            winterL(m+2)=GetWFromH(mesh,dof%h(i),l)
            winterR(m+2)=GetWFromH(mesh,dof%h(i),r)
            zinter (m+2)=dof%h(i)
         end if

         !Computation of total term source
         do j=1,m+1 
            dx=(mesh%crosssection(i)%deltademi+mesh%crosssection(i+1)%deltademi)
            sg(i)=sg(i)+&
             (zinter(j+1)-zinter(j))*&
             ((dof%h(i)-zinter(j  ))*((winterR(j  )-winterL(j  ))/dx)+&
              (dof%h(i)-zinter(j+1))*((winterR(j+1)-winterL(j+1))/dx)) 
         end do


         sg(i)=demi*g*sg(i)

      end if
   end do

END SUBROUTINE computationSg


!> This subroutine compute the \f$S_g\f$ term one each cross-section \f$i\f$
!!
!! \details Algorithm used:\n
!!      
!! The \f$S_g\f$ term is computed by :\n
!! \f$\mathcal{S}_{gi}^{n+1}=\frac{1}{2}{\displaystyle \sum_{k=1}^{N}}(z_{k+1}-z_{k})\left(\left(\bar{\tilde{h}}_{i}^{n+1}
!! -z_{k}\right)\frac{\left(\bar{\tilde{w}}_{i+1}^{n+1}(z_{k})-\bar{\tilde{w}}_{i-1}^{n+1}(z_{k})\right)}
!! {\Delta x_{i+1/2}+\Delta x_{i-1/2}}+\left(\bar{\tilde{h}}_{i}^{n+1}-z_{k+1}\right)\frac{\left(
!! \bar{\tilde{w}}_{i+1}^{n+1}(z_{k+1})-\bar{\tilde{w}}_{i-1}^{n+1}(z_{k+1})\right)}{\Delta x_{i+1/2}+\Delta x_{i-1/2}}
!! \right)-\bar{S}{}_{i}^{n+1}\frac{z_{bi+1}-z_{bi-1}}{\Delta x_{i+1/2}+\Delta x_{i-1/2}}\f$
!!
!! For more details see documentation.
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] dof Unknowns of the model.
!! \param[inout] sg \f$S_g\f$ term computed.
!! \param[in] crossSection Cross-section number.
!! \param[in] mvector \f$m\f$ updated.
SUBROUTINE computationSgCrossSection(mesh,dof,sg,crossSection,mvector)
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   type( unk ), intent(in)  ::  dof
   integer(ip), intent(in)  ::  crosssection
   real(rp),   intent(inout) :: sg
   integer(ip), dimension(mesh%ncs+4),intent(in)  ::  mvector 

   integer(ip) :: findmsurface
   real(rp) :: GetWFromH,dx
   integer(ip) :: m,l,r
   real(rp), dimension(mesh%crosssection(crosssection)%nc+2) :: winterL
   real(rp), dimension(mesh%crosssection(crosssection)%nc+2) :: winterR 
   real(rp), dimension(mesh%crosssection(crosssection)%nc+2) :: zinter      
   real(rp) :: zb
   
   !write(*,'(A80)') '1'
   i=crossSection
   sg=0.0_rp
      if ((dof%s(i).gt.0.0_rp)) then
         m=mvector(i)

         l=i-1
         r=i+1

         zb=bathy_cell(i)
         
         !Z0=0, w0l,w0r
         winterL(1)=mesh%crosssection(l)%surfacewidth(1) !w0l
         winterR(1)=mesh%crosssection(r)%surfacewidth(1) !w0R
         zinter(1)=0._rp                                 !Z0

         if (m.le.0) then !if s<s0
            winterL(2)=GetWFromH(mesh,dof%h(i),l) !W2L=WNL
            winterR(2)=GetWFromH(mesh,dof%h(i),r) !W2R=WNR
            zinter(2)=dof%h(i)                    !Z2=ZN=h

         else !Else :
            do j=1,m !For each trapezium 
               winterL  (j+1) = mesh%CrossSection(i)%wl   (j)
               winterR  (j+1) = mesh%CrossSection(i)%wr   (j)
               zinter   (j+1) = mesh%CrossSection(i)%zint (j)
            end do

            !For last trapezium
            winterL(m+2)=GetWFromH(mesh,dof%h(i),l)
            winterR(m+2)=GetWFromH(mesh,dof%h(i),r)
            zinter (m+2)=dof%h(i)
         end if

         !Computation of total term source
         do j=1,m+1 
            dx=(mesh%crosssection(i)%deltademi+mesh%crosssection(i+1)%deltademi)
            sg=sg+&
             (zinter(j+1)-zinter(j))*&
             ((dof%h(i)-zinter(j  ))*((winterR(j  )-winterL(j  ))/dx)+&
              (dof%h(i)-zinter(j+1))*((winterR(j+1)-winterL(j+1))/dx)) 
         end do


         sg=demi*g*sg

      end if

END SUBROUTINE computationSgCrossSection


!> This subroutine compute the HLL flux between the node \f$i-1\f$  and \f$i\f$.
!!
!!\details The computed flux is defined by: \n
!!    
!! 
!!\f$\mathbf{F}_{i-1/2}^{n}=\mathbf{\phi}(\mathbf{U}_{i-1}^{n},\mathbf{U}_{i}^{n})=\left\{ \begin{array}{ll}
!!\mathbf{F}(\mathbf{U}_{i-1}^{n}) & \mbox{ if }0\leq c_{1}\\
!!\frac{c_{2}\mathbf{F}(\mathbf{U}_{i-1}^{n})-c_{1}\mathbf{F}(\mathbf{U}_{i}^{n})}{c_{2}-c_{1}}
!!+\frac{c_{1}c_{2}}{c_{2}-c_{1}}(\mathbf{U}_{i}^{n}-\mathbf{U}_{i-1}^{n}) & \mbox{ if }c_{1}<0<c_{2}\\
!!\mathbf{F}(\mathbf{U}_{i}^{n}) & \mbox{ if }c_{2}\leq0
!!\end{array}\right.\f$ \n
!!with \n
!!\f$\left\{ \begin{array}{ll}
!!c_{1}=&\min(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))\\
!!c_{2}=&\max(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))
!!\end{array}\right.\f$
!!
!! Where :
!!
!!\f$\mathbf{F}(\mathbf{U})=[Q,\frac{Q^{2}}{S}+P]^T\f$
!! and 
!! \f$\lambda_{1}=u+c\f$,   \f$\lambda_{2}=u-c\f$ with
!! \f$c=\sqrt{\frac{\partial P}{\partial S}}\f$ and 
!! \f$u=\frac{Q}{S}\f$
!!
!! For more details see documentation.
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] dof Unknowns of the model.
!! \param[out] flux Flux \f$\mathbf{F}\f$ computed between the node \f$i-1\f$  and \f$i\f$.
!! \param[in] indexie Cross-section number.
SUBROUTINE sw_hll_dof( mesh,dof, flux,indexie )
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   type( unk ), intent(in)  ::  dof
   integer(ip), intent(in)  ::  indexie
   real(rp)   , intent(out) ::  flux(2)

   real(rp)   :: tfluxr(2), tfluxl(2)
   real(rp)   :: c1,c2
   real(rp)   :: pressure,pressure2
   real(rp)  ::  hL,sL,qL,ur
   real(rp)  ::  hR,sR,qR,ul

   hl=dof%h(ie-1)
   sl=dof%s(ie-1)
   ql=dof%q(ie-1)

   hr=dof%h(ie  )
   sr=dof%s(ie  )
   qr=dof%q(ie  )
      
   ur=div_by_except_0(qr,sr)
   ul=div_by_except_0(ql,sl)


   c1=min(ul+sqrt(g*hl),&
          ul-sqrt(g*hl))
   c1=min(c1,ur+sqrt(g*hr))
   c1=min(c1,ur-sqrt(g*hr))

   c2=max(ul+sqrt(g*hl),&
          ul-sqrt(g*hl))
   c2=max(c2,ur+sqrt(g*hr))
   c2=max(c2,ur-sqrt(g*hr))

   call PressureTerms(mesh,hl,sl,indexie-1,pressure)
   tfluxl(1)=ql
   if (sl.gt.0) then
      tfluxl(2)=(ql**2)/sl+pressure
   else 
      tfluxl(2)=0._rp
   end if

   call PressureTerms(mesh,hr,sr,indexie,pressure)
   tfluxr(1)=qr
   if (sr.gt.0) then
      tfluxr(2)=(qr**2)/sr+pressure
   else 
      tfluxr(2)=0._rp
   end if


   if (c1.ge.0) then
      flux(1)=tfluxl(1)
      flux(2)=tfluxl(2)
   else if (c2.le.0) then 
      flux(1)=tfluxr(1)
      flux(2)=tfluxr(2)
   else 
      flux(1)=(c2*tfluxl(1)-c1*tfluxr(1)+c1*c2*(sr-sl)) /(c2-c1)
      flux(2)=(c2*tfluxl(2)-c1*tfluxr(2)+c1*c2*(qr-ql)) /(c2-c1)
   end if
      
END SUBROUTINE sw_hll_dof




!> This subroutine compute the HLL flux between the node \f$i-1\f$  and \f$i\f$ from
!! \f$S\f$, \f$h\f$,\f$u\f$ and \f$Q\f$ values at \f$i-1\f$  and \f$i\f$.
!!
!!\details The computed flux is defined by: \n
!!    
!! 
!!\f$\mathbf{F}_{i-1/2}^{n}=\mathbf{\phi}(\mathbf{U}_{i-1}^{n},\mathbf{U}_{i}^{n})=\left\{ \begin{array}{ll}
!!\mathbf{F}(\mathbf{U}_{i-1}^{n}) & \mbox{ if }0\leq c_{1}\\
!!\frac{c_{2}\mathbf{F}(\mathbf{U}_{i-1}^{n})-c_{1}\mathbf{F}(\mathbf{U}_{i}^{n})}{c_{2}-c_{1}}
!!+\frac{c_{1}c_{2}}{c_{2}-c_{1}}(\mathbf{U}_{i}^{n}-\mathbf{U}_{i-1}^{n}) & \mbox{ if }c_{1}<0<c_{2}\\
!!\mathbf{F}(\mathbf{U}_{i}^{n}) & \mbox{ if }c_{2}\leq0
!!\end{array}\right.\f$ \n
!!with \n
!!\f$\left\{ \begin{array}{ll}
!!c_{1}=&\min(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))\\
!!c_{2}=&\max(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))
!!\end{array}\right.\f$
!!
!! Where :
!!
!!\f$\mathbf{F}(\mathbf{U})=[Q,\frac{Q^{2}}{S}+P]^T\f$
!! and 
!! \f$\lambda_{1}=u+c\f$,   \f$\lambda_{2}=u-c\f$ with
!! \f$c=\sqrt{\frac{\partial P}{\partial S}}\f$ and 
!! \f$u=\frac{Q}{S}\f$
!!
!! For more details see documentation.
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] hL Water height \f$h\f$ at cross section \f$i-1\f$.
!! \param[in] SL Water surface \f$s\f$ at cross section \f$i-1\f$.
!! \param[in] qL Flow \f$q\f$ at cross section \f$i-1\f$.
!! \param[in] uL Velocity \f$u\f$ at cross section \f$i-1\f$.
!! \param[in] hR Water height \f$h\f$ at cross section \f$i\f$.
!! \param[in] SR Water surface \f$s\f$ at cross section \f$i\f$.
!! \param[in] qR Flow \f$q\f$ at cross section \f$i\f$.
!! \param[in] uR Velocity \f$u\f$ at cross section \f$i\f$.
!! \param[out] flux Flux \f$\mathbf{F}\f$ computed between the node \f$i-1\f$  and \f$i\f$.
!! \param[in] indexie Cross-section number.
SUBROUTINE sw_hll_u( mesh, hL , SL , qL ,ul ,hR , SR , qR ,ur, flux,indexie )
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   real(rp)   , intent(in)  ::  hL,sL,qL,ul
   real(rp)   , intent(in)  ::  hR,sR,qR,ur
   integer(ip), intent(in)  ::  indexie
   real(rp)   , intent(out) ::  flux(2)

   real(rp)   :: tfluxr(2), tfluxl(2)
   real(rp)   :: c1,c2
   real(rp)   :: pressure,pressure2

!OLD PBL TAPENADE 
!   c1=min(div_by_except_0(ql,sl)+sqrt(g*hl),&
!          div_by_except_0(ql,sl)-sqrt(g*hl),&
!          div_by_except_0(qr,sr)+sqrt(g*hr),&
!          div_by_except_0(qr,sr)-sqrt(g*hr))

!   c2=max(div_by_except_0(ql,sl)+sqrt(g*hl),&
!          div_by_except_0(ql,sl)-sqrt(g*hl),&
!          div_by_except_0(qr,sr)+sqrt(g*hr),&
!          div_by_except_0(qr,sr)-sqrt(g*hr))
!END OLD

   c1=min(ul+sqrt(g*hl),&
          ul-sqrt(g*hl))
   c1=min(c1,ur+sqrt(g*hr))
   c1=min(c1,ur-sqrt(g*hr))

   c2=max(ul+sqrt(g*hl),&
          ul-sqrt(g*hl))
   c2=max(c2,ur+sqrt(g*hr))
   c2=max(c2,ur-sqrt(g*hr))

   !call PressureTerms(mesh,hl,sl,indexie-1,pressure)
   call PressureTerms(mesh,hl,sl,indexie-1,pressure)
   tfluxl(1)=ql
   if (sl.gt.0) then
      tfluxl(2)=(ql**2)/sl+pressure
   else 
      tfluxl(2)=0._rp
   end if

   call PressureTerms(mesh,hr,sr,indexie,pressure)
   tfluxr(1)=qr
   if (sr.gt.0) then
      tfluxr(2)=(qr**2)/sr+pressure
   else 
      tfluxr(2)=0._rp
   end if


   if (c1.ge.0) then
      flux(1)=tfluxl(1)
      flux(2)=tfluxl(2)
      !write(*,*) ' c1.ge.0 '
   else if (c2.le.0) then 
      flux(1)=tfluxr(1)
      flux(2)=tfluxr(2)
      !write(*,*) ' c2.le.0 '
   else 
      flux(1)=(c2*tfluxl(1)-c1*tfluxr(1)+c1*c2*(sr-sl)) /(c2-c1)
      flux(2)=(c2*tfluxl(2)-c1*tfluxr(2)+c1*c2*(qr-ql)) /(c2-c1)
      !write(*,*) ' else '
   end if
      
END SUBROUTINE sw_hll_u


!> This subroutine compute the HLL flux between the node \f$i-1\f$  and \f$i\f$ from
!! \f$S\f$, \f$h\f$,\f$Pt\f$ and \f$Q\f$ values at \f$i-1\f$  and \f$i\f$.
!!
!!\details The computed flux is defined by: \n
!!    
!! 
!!\f$\mathbf{F}_{i-1/2}^{n}=\mathbf{\phi}(\mathbf{U}_{i-1}^{n},\mathbf{U}_{i}^{n})=\left\{ \begin{array}{ll}
!!\mathbf{F}(\mathbf{U}_{i-1}^{n}) & \mbox{ if }0\leq c_{1}\\
!!\frac{c_{2}\mathbf{F}(\mathbf{U}_{i-1}^{n})-c_{1}\mathbf{F}(\mathbf{U}_{i}^{n})}{c_{2}-c_{1}}
!!+\frac{c_{1}c_{2}}{c_{2}-c_{1}}(\mathbf{U}_{i}^{n}-\mathbf{U}_{i-1}^{n}) & \mbox{ if }c_{1}<0<c_{2}\\
!!\mathbf{F}(\mathbf{U}_{i}^{n}) & \mbox{ if }c_{2}\leq0
!!\end{array}\right.\f$ \n
!!with \n
!!\f$\left\{ \begin{array}{ll}
!!c_{1}=&\min(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))\\
!!c_{2}=&\max(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))
!!\end{array}\right.\f$
!!
!! Where :
!!
!!\f$\mathbf{F}(\mathbf{U})=[Q,\frac{Q^{2}}{S}+P]^T\f$
!! and 
!! \f$\lambda_{1}=u+c\f$,   \f$\lambda_{2}=u-c\f$ with
!! \f$c=\sqrt{\frac{\partial P}{\partial S}}\f$ and 
!! \f$u=\frac{Q}{S}\f$
!!
!! For more details see documentation.
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] hL Water height \f$h\f$ at cross section \f$i-1\f$.
!! \param[in] SL Water surface \f$s\f$ at cross section \f$i-1\f$.
!! \param[in] qL Flow \f$q\f$ at cross section \f$i-1\f$.
!! \param[in] pL Pressure term \f$pr\f$ at cross section \f$i-1\f$.
!! \param[in] hR Water height \f$h\f$ at cross section \f$i\f$.
!! \param[in] SR Water surface \f$s\f$ at cross section \f$i\f$.
!! \param[in] qR Flow \f$q\f$ at cross section \f$i\f$.
!! \param[in] pR Pressure term \f$pr\f$ at cross section \f$i\f$.
!! \param[out] flux Flux \f$\mathbf{F}\f$ computed between the node \f$i-1\f$  and \f$i\f$.
!! \param[in] indexie Cross-section number.
SUBROUTINE sw_hll( mesh, hL , SL , qL ,pL ,hR , SR , qR , pR, flux,indexie )
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   real(rp)   , intent(in)  ::  hL,sL,qL,pL
   real(rp)   , intent(in)  ::  hR,sR,qR,pR
   integer(ip), intent(in)  ::  indexie
   real(rp)   , intent(out) ::  flux(2)

   real(rp)   :: tfluxr(2), tfluxl(2)
   real(rp)   :: c1,c2


   c1=min(div_by_except_0(ql,sl)+sqrt(g*hl),&
          div_by_except_0(ql,sl)-sqrt(g*hl))
   c1=min(c1,div_by_except_0(qr,sr)+sqrt(g*hr))
   c1=min(c1,div_by_except_0(qr,sr)-sqrt(g*hr))

   c2=max(div_by_except_0(ql,sl)+sqrt(g*hl),&
          div_by_except_0(ql,sl)-sqrt(g*hl))
   c2=max(c2,div_by_except_0(qr,sr)+sqrt(g*hr))
   c2=max(c2,div_by_except_0(qr,sr)-sqrt(g*hr))

   !call PressureTerms(mesh,hl,sl,indexie-1,pressure)
   tfluxl(1)=ql
   if (sl.gt.0) then
      tfluxl(2)=(ql**2)/sl+pl
   else 
      tfluxl(2)=0._rp
   end if

   tfluxr(1)=qr
   if (sr.gt.0) then
      tfluxr(2)=(qr**2)/sr+pr
   else 
      tfluxr(2)=0._rp
   end if


   if (c1.ge.0) then
      flux(1)=tfluxl(1)
      flux(2)=tfluxl(2)
      !write(*,*) ' c1.ge.0 '
   else if (c2.le.0) then 
      flux(1)=tfluxr(1)
      flux(2)=tfluxr(2)
      !write(*,*) ' c2.le.0 '
   else 
      flux(1)=(c2*tfluxl(1)-c1*tfluxr(1)+c1*c2*(sr-sl)) /(c2-c1)
      flux(2)=(c2*tfluxl(2)-c1*tfluxr(2)+c1*c2*(qr-ql)) /(c2-c1)
      !write(*,*) ' else '
   end if
      
END SUBROUTINE sw_hll



!> This subroutine compute the Rusanov flux between the node \f$i-1\f$  and \f$i\f$ from
!! \f$S\f$, \f$h\f$,\f$u\f$ and \f$Q\f$ values at \f$i-1\f$  and \f$i\f$.
!!
!!\details The computed flux is defined by: \n
!!    
!! \f$\mathbf{F}_{i-1/2}^{n}=0.5(\mathbf{F}(\mathbf{U}_{i-1}^{n})+\mathbf{F_1}(\mathbf{U}_{i}^{n}))-0.5c_2({U}_{i}-{U}_{i-1})\f$
!!
!!with \n
!!\f$\left\{ \begin{array}{ll}
!!c_{1}=&\min(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))\\
!!c_{2}=&\max(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))
!!\end{array}\right.\f$
!!
!! Where :
!!
!!\f$\mathbf{F}(\mathbf{U})=[Q,\frac{Q^{2}}{S}+P]^T\f$
!! and 
!! \f$\lambda_{1}=u+c\f$,   \f$\lambda_{2}=u-c\f$ with
!! \f$c=\sqrt{\frac{\partial P}{\partial S}}\f$ and 
!! \f$u=\frac{Q}{S}\f$
!!
!! For more details see documentation.
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] hL Water height \f$h\f$ at cross section \f$i-1\f$.
!! \param[in] SL Water surface \f$s\f$ at cross section \f$i-1\f$.
!! \param[in] qL Flow \f$q\f$ at cross section \f$i-1\f$.
!! \param[in] hR Water height \f$h\f$ at cross section \f$i\f$.
!! \param[in] SR Water surface \f$s\f$ at cross section \f$i\f$.
!! \param[in] qR Flow  \f$q\f$ at cross section \f$i\f$.
!! \param[out] flux Flux \f$\mathbf{F}\f$ computed between the node \f$i-1\f$  and \f$i\f$.
!! \param[in] indexie Cross-section number.
SUBROUTINE sw_rusanov( mesh, hL , SL , qL ,hR , SR , qR , flux,indexie )
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   real(rp)   , intent(in)  ::  hL,sL,qL
   real(rp)   , intent(in)  ::  hR,sR,qR
   integer(ip), intent(in)  ::  indexie
   real(rp)   , intent(out) ::  flux(2)

   real(rp)   :: tfluxr(2), tfluxl(2)
   real(rp)   :: c1,c2
   real(rp)   :: pressure,pressure2

!OLD PBL TAPENADE 
!   c1=min(div_by_except_0(ql,sl)+sqrt(g*hl),&
!          div_by_except_0(ql,sl)-sqrt(g*hl),&
!          div_by_except_0(qr,sr)+sqrt(g*hr),&
!          div_by_except_0(qr,sr)-sqrt(g*hr))

!   c2=max(div_by_except_0(ql,sl)+sqrt(g*hl),&
!          div_by_except_0(ql,sl)-sqrt(g*hl),&
!          div_by_except_0(qr,sr)+sqrt(g*hr),&
!          div_by_except_0(qr,sr)-sqrt(g*hr))
!END OLD

   c1=min(div_by_except_0(ql,sl)+sqrt(g*hl),&
          div_by_except_0(ql,sl)-sqrt(g*hl))
   c1=min(c1,div_by_except_0(qr,sr)+sqrt(g*hr))
   c1=min(c1,div_by_except_0(qr,sr)-sqrt(g*hr))

   c2=max(abs(div_by_except_0(ql,sl)+sqrt(g*hl)),&
          abs(div_by_except_0(ql,sl)-sqrt(g*hl)))
   c2=max(c2,abs(div_by_except_0(qr,sr)+sqrt(g*hr)))
   c2=max(c2,abs(div_by_except_0(qr,sr)-sqrt(g*hr)))

   !call PressureTerms(mesh,hl,sl,indexie-1,pressure)
   call PressureTerms(mesh,hl,sl,indexie-1,pressure)
   tfluxl(1)=ql
   if (sl.gt.0) then
      tfluxl(2)=(ql**2)/sl+pressure
   else 
      tfluxl(2)=0._rp
   end if

   call PressureTerms(mesh,hr,sr,indexie,pressure)
   tfluxr(1)=qr
   if (sr.gt.0) then
      tfluxr(2)=(qr**2)/sr+pressure
   else 
      tfluxr(2)=0._rp
   end if

   flux(1)=0.5_rp*(tfluxl(1)+tfluxr(1)) -c2*0.5_rp*(sr-sl)
   flux(2)=0.5_rp*(tfluxl(2)+tfluxr(2)) -c2*0.5_rp*(qr-ql)

END SUBROUTINE sw_rusanov


!> This subroutine compute the Lax flux between the node \f$i-1\f$  and \f$i\f$ from
!! \f$S\f$, \f$h\f$,\f$u\f$ and \f$Q\f$ values at \f$i-1\f$  and \f$i\f$.
!!
!!\details The computed flux is defined by: \n
!!    
!! \f$\mathbf{F}_{i-1/2}^{n}=0.5(\mathbf{F}(\mathbf{U}_{i-1}^{n})+\mathbf{F_1}(\mathbf{U}_{i}^{n}))-0.5\frac{\Delta x_i}{\Delta t}({U}_{i}-{U}_{i-1})\f$
!!
!! Where :
!!
!!\f$\mathbf{F}(\mathbf{U})=[Q,\frac{Q^{2}}{S}+P]^T\f$
!! and 
!! \f$\lambda_{1}=u+c\f$,   \f$\lambda_{2}=u-c\f$ with
!! \f$c=\sqrt{\frac{\partial P}{\partial S}}\f$ and 
!! \f$u=\frac{Q}{S}\f$
!!
!! For more details see documentation.
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] hL Water height \f$h\f$ at cross section \f$i-1\f$.
!! \param[in] SL Water surface \f$s\f$ at cross section \f$i-1\f$.
!! \param[in] qL Flow \f$q\f$ at cross section \f$i-1\f$.
!! \param[in] hR Water height \f$h\f$ at cross section \f$i\f$.
!! \param[in] SR Water surface \f$s\f$ at cross section \f$i\f$.
!! \param[in] qR Flow \f$q\f$ at cross section \f$i\f$.
!! \param[out] flux Flux \f$\mathbf{F}\f$ computed between the node \f$i-1\f$  and \f$i\f$.
!! \param[in] indexie Cross-section number.
SUBROUTINE sw_lax( mesh, hL , SL , qL ,hR , SR , qR , flux,indexie )
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   real(rp)   , intent(in)  ::  hL,sL,qL
   real(rp)   , intent(in)  ::  hR,sR,qR
   integer(ip), intent(in)  ::  indexie
   real(rp)   , intent(out) ::  flux(2)

   real(rp)   :: tfluxr(2), tfluxl(2)
   real(rp)   :: c1,c2
   real(rp)   :: pressure,pressure2

!OLD PBL TAPENADE 
!   c1=min(div_by_except_0(ql,sl)+sqrt(g*hl),&
!          div_by_except_0(ql,sl)-sqrt(g*hl),&
!          div_by_except_0(qr,sr)+sqrt(g*hr),&
!          div_by_except_0(qr,sr)-sqrt(g*hr))

!   c2=max(div_by_except_0(ql,sl)+sqrt(g*hl),&
!          div_by_except_0(ql,sl)-sqrt(g*hl),&
!          div_by_except_0(qr,sr)+sqrt(g*hr),&
!          div_by_except_0(qr,sr)-sqrt(g*hr))
!END OLD



   !call PressureTerms(mesh,hl,sl,indexie-1,pressure)
   call PressureTerms(mesh,hl,sl,indexie-1,pressure)
   tfluxl(1)=ql

   if (sl.gt.0) then
      tfluxl(2)=(ql**2)/sl+pressure
   else 
      tfluxl(2)=0._rp
   end if

   call PressureTerms(mesh,hr,sr,indexie,pressure)
   tfluxr(1)=qr
   if (sr.gt.0) then
      tfluxr(2)=(qr**2)/sr+pressure
   else 
      tfluxr(2)=0._rp
   end if



   flux(1)=0.5_rp * (tfluxl(1)+tfluxr(1))- 0.5_rp *((mesh%crosssection(indexie)%delta)/(dt))*(sr-sl)
   flux(2)=0.5_rp * (tfluxl(2)+tfluxr(2))- 0.5_rp *((mesh%crosssection(indexie)%delta)/(dt))*(qr-ql)


   !write (*,*) 'dt : ', dt
   !write (*,*) 'tfluxl : ', tfluxl
   !write (*,*) 'tfluxr : ', tfluxr
   !write (*,*) 'mesh%crosssection(indexie)%delta : ', mesh%crosssection(indexie)%delta
   !write (*,*) 'qr : ', qr


      
END SUBROUTINE sw_lax



!<NOADJ     
        
!> This subroutine compute the HLL flux between for MUSCL for the node \f$i-1\f$  and \f$i\f$ from
!! \f$S\f$, \f$h\f$ and \f$Q\f$ values at \f$i-1\f$  and \f$i\f$.
!!
!!\details The computed flux is defined by: \n
!!    
!! 
!!\f$\mathbf{F}_{i-1/2}^{n}=\mathbf{\phi}(\mathbf{U}_{i-1}^{n},\mathbf{U}_{i}^{n})=\left\{ \begin{array}{ll}
!!\mathbf{F}(\mathbf{U}_{i-1}^{n}) & \mbox{ if }0\leq c_{1}\\
!!\frac{c_{2}\mathbf{F}(\mathbf{U}_{i-1}^{n})-c_{1}\mathbf{F}(\mathbf{U}_{i}^{n})}{c_{2}-c_{1}}
!!+\frac{c_{1}c_{2}}{c_{2}-c_{1}}(\mathbf{U}_{i}^{n}-\mathbf{U}_{i-1}^{n}) & \mbox{ if }c_{1}<0<c_{2}\\
!!\mathbf{F}(\mathbf{U}_{i}^{n}) & \mbox{ if }c_{2}\leq0
!!\end{array}\right.\f$ \n
!!with \n
!!\f$\left\{ \begin{array}{ll}
!!c_{1}=&\min(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))\\
!!c_{2}=&\max(\lambda_{1}(\mathbf{U}_{i}^{n}),\lambda_{1}(\mathbf{U}_{i-1}^{n}),
!!\lambda_{2}(\mathbf{U}_{i}^{n}),\lambda_{2}(\mathbf{U}_{i-1}^{n}))
!!\end{array}\right.\f$
!!
!! Where :
!!
!!\f$\mathbf{F}(\mathbf{U})=[Q,\frac{Q^{2}}{S}+P]^T\f$
!! and 
!! \f$\lambda_{1}=u+c\f$,   \f$\lambda_{2}=u-c\f$ with
!! \f$c=\sqrt{\frac{\partial P}{\partial S}}\f$ and 
!! \f$u=\frac{Q}{S}\f$
!!
!! For more details see documentation.
!!
!! \param[in] mesh  Mesh of the model.
!! \param[in] hL Water height \f$h\f$ at cross section \f$i-1\f$.
!! \param[in] SL Water surface \f$s\f$ at cross section \f$i-1\f$.
!! \param[in] qL Flow \f$q\f$ at cross section \f$i-1\f$.
!! \param[in] hR Water height \f$h\f$ at cross section \f$i\f$.
!! \param[in] SR Water surface \f$s\f$ at cross section \f$i\f$.
!! \param[in] qR Flow \f$q\f$ at cross section \f$i\f$.
!! \param[out] flux Flux \f$\mathbf{F}\f$ computed between the node \f$i-1\f$  and \f$i\f$.
!! \param[in] indexie Cross-section number.            
SUBROUTINE sw_hll_m( mesh, hL , SL , qL ,hR , SR , qR , flux,indexie )
   USE m_model
   USE m_common
   USE m_mesh

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in)  ::  mesh
   real(rp)   , intent(in)  ::  hL,sL,qL
   real(rp)   , intent(in)  ::  hR,sR,qR
   integer(ip), intent(in)  ::  indexie
   real(rp)   , intent(out) ::  flux(2)

   real(rp)   :: tfluxr(2), tfluxl(2)
   real(rp)   :: c1,c2
   real(rp)   :: pressure,pressure2

  
   c1=min(div_by_except_0(ql,sl)+sqrt(g*hl),&
          div_by_except_0(ql,sl)-sqrt(g*hl),&
          div_by_except_0(qr,sr)+sqrt(g*hr),&
          div_by_except_0(qr,sr)-sqrt(g*hr))

   c2=max(div_by_except_0(ql,sl)+sqrt(g*hl),&
          div_by_except_0(ql,sl)-sqrt(g*hl),&
          div_by_except_0(qr,sr)+sqrt(g*hr),&
          div_by_except_0(qr,sr)-sqrt(g*hr))

   call PressureTerms_m(mesh,hl,sl,indexie-1,indexie,pressure)
   tfluxl(1)=ql
   tfluxl(2)=div_by_except_0(ql**2,sl)+pressure
  
   call PressureTerms_m(mesh,hr,sr,indexie-1,indexie,pressure)
   tfluxr(1)=qr
   tfluxr(2)=div_by_except_0(qr**2,sr)+pressure
   

   if (c1.ge.0) then
      flux(1)=tfluxl(1)
      flux(2)=tfluxl(2)

   else if (c2.le.0) then 
      flux(1)=tfluxr(1)
      flux(2)=tfluxr(2)
   else
      flux(1)=(c2*tfluxl(1)-c1*tfluxr(1)+c1*c2*(sr-sl)) /(c2-c1)
      flux(2)=(c2*tfluxl(2)-c1*tfluxr(2)+c1*c2*(qr-ql)) /(c2-c1) 
   end if
   
END SUBROUTINE sw_hll_m

!>NOADJ
