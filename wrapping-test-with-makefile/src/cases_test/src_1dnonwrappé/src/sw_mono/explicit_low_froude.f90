!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file explicit_low_froude.f90
!! \brief This file includes the computation with explicit low froude method without MUSCL and slope limiter. An unique
!! subroutine :
!! explicit_low_froude

!> Subroutine of the computation explicit low froude method without MUSCL and slope limiter. 
!!
!! \details Algorithm used:
!!
!!     Update boundaries conditions
!!     Update mvector
!!
!!     do i = 2, n:
!!       Computation of F (low froude)
!!         s(i) = max(0,s-(dt/dxi) (F1(i+1)-F1(i)))
!!         Update mvector(i)
!!         Update H(i) (from S(i))
!!     end do
!!     
!!     do i = 2, n:
!!       Computation of Sg(i) and Sf(i)
!!       Computation of q(i)
!!     end do
!!
!! \param[in]  dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
SUBROUTINE explicit_low_froude( dof , mesh )

   USE m_common
   USE m_mesh
!    USE m_time_screen
   USE m_model
!    USE m_linear_solver
   USE m_user_data
   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   TYPE( msh ), intent(in   )  ::  mesh
   TYPE( unk ), intent(inout)  ::  dof

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!

   real(rp) :: wjm1,wj,wjp1
   real(rp) :: vjm1,vj,vjp1
   real(rp) :: Hjm1,Hj,Hjp1
   real(rp) :: sjm1,sj,sjp1

   real(rp), dimension( mesh%ncs+4)  ::  h,v,s                    ! Temporal depths
   integer(ip), dimension(mesh%ncs+4) :: mVector              ! Pressure for fluxes computing
   
   real(rp) :: gamma_expl,alpha_expl
   
   real(rp) :: mult_gamma, mult_alpha
   
   real(rp) :: Fjm1d2 , Fjp1d2,Phijp1d2, Phijm1d2,Rj

   real(rp) :: SourceTermPente,SourceTermFriction

   real(rp) :: SfS,q,dz,HtoS,s_new,v_new,F2

   real(rp) :: manning, hydraulicradiusie, L
   
   real(rp) :: A,B,D,lambda,Ch,P,Pprim,gamma_min,gamma_max,alpha_min,alpha_max, wdemi
   real(rp), dimension(2, mesh%ncs+4)  ::  alpha_expl_v, gamma_expl_v
   
   
   !Function
   real(rp)  :: GetWFromH

   !======================================================================================================================!
   !  Begin Subroutine
   !======================================================================================================================!

   call calc_boundary_state( mesh,dof)
   call UpdateMVector(mesh,dof,mvector)         ! Update mvector   


      
   h(:)  =  dof%h(:)
   do ie=1,mesh%ncs+4
      v(ie)  =  dof%q(ie)/dof%s(ie)
   end do 
   s(:)  =  dof%s(:)

   h(2)=h(3)
   v(2)=dof%q(2)/dof%s(3)


   v(mesh%ncs+3)=v(mesh%ncs+2)
   
   mult_alpha = 1.5
   mult_gamma = 1.5
   A = 0.1
   B = 0.4
   D = 0.4
   
   !===================================================================================================================!
   !  Compute gamma and alpha
   !===================================================================================================================!
   do ie=3,mesh%ncs+2
   
   
      !================================================================================================================!
      !  Compute local gamma and alpha (arrays)
      !================================================================================================================!
      wjm1=GetWFromH(mesh,dof%h(ie-1),ie-1)
      wj  =GetWFromH(mesh,dof%h(ie),ie)
      wdemi = 0.5 * (wjm1 + wj)
      lambda = dt / mesh%crosssection(ie-1)%delta
      Ch = 0.5 * g / wdemi
      P     = lambda**2 * Ch * wdemi / ((1.0 - A - B) * D)
      Pprim = lambda**2 * 2.0 * Ch * wdemi / (B * (1.0 - D))
      gamma_min = (1.0 - D) * (1.0 - sqrt(1.0 - P)) / (4.0 * (1.0 - A - B) * D * P)
      gamma_max = (1.0 - D) * (1.0 + sqrt(1.0 - P)) / (4.0 * (1.0 - A - B) * D * P)
      gamma_expl_v(1, ie) = min(mult_gamma * gamma_min, 0.5 * (gamma_min + gamma_max))
      alpha_min = (1.0 - A - B) * (1.0 - sqrt(1.0 - Pprim)) / (B * (1.0 - D) * Pprim)
      alpha_max = (1.0 - A - B) * (1.0 + sqrt(1.0 - Pprim)) / (B * (1.0 - D) * Pprim)
      alpha_expl_v(1, ie) = min(mult_alpha * alpha_min, 0.5 * (alpha_min + alpha_max))
      wjp1=GetWFromH(mesh,dof%h(ie+1),ie+1)
      wdemi = 0.5 * (wj + wjp1)
      lambda = dt / mesh%crosssection(ie)%delta
      Ch = 0.5 * g / wdemi
      P     = lambda**2 * Ch * wdemi / ((1.0 - A - B) * D)
      Pprim = lambda**2 * 2.0 * Ch * wdemi / (B * (1.0 - D))
      gamma_min = (1.0 - D) * (1.0 - sqrt(1.0 - P)) / (4.0 * (1.0 - A - B) * D * P)
      gamma_max = (1.0 - D) * (1.0 + sqrt(1.0 - P)) / (4.0 * (1.0 - A - B) * D * P)
      gamma_expl_v(2, ie) = min(mult_gamma * gamma_min, 0.5 * (gamma_min + gamma_max))
      alpha_min = (1.0 - A - B) * (1.0 - sqrt(1.0 - Pprim)) / (B * (1.0 - D) * Pprim)
      alpha_max = (1.0 - A - B) * (1.0 + sqrt(1.0 - Pprim)) / (B * (1.0 - D) * Pprim)
      alpha_expl_v(2, ie) = min(mult_alpha * alpha_min, 0.5 * (alpha_min + alpha_max))
!    
!    
!       !================================================================================================================!
!       !  Compute local gamma and alpha
!       !================================================================================================================!
!       wjm1=GetWFromH(mesh,dof%h(ie-1),ie-1)
!       wj  =GetWFromH(mesh,dof%h(ie),ie)
!       wjp1=GetWFromH(mesh,dof%h(ie+1),ie+1)
!       wdemi = 0.5 * (wjm1 + wj)
!       lambda = dt / mesh%crosssection(ie)%delta
!       Ch = 0.5 * g / wj
!       P     = lambda**2 * Ch * wj / ((1.0 - A - B) * D)
!       Pprim = lambda**2 * 2.0 * Ch * wj / (B * (1.0 - D))
!       gamma_min = (1.0 - D) * (1.0 - sqrt(1.0 - P)) / (4.0 * (1.0 - A - B) * D * P)
!       gamma_max = (1.0 - D) * (1.0 + sqrt(1.0 - P)) / (4.0 * (1.0 - A - B) * D * P)
!       gamma_expl = min(mult_gamma * gamma_min, 0.5 * (gamma_min + gamma_max))
!       
!       alpha_min = (1.0 - A - B) * (1.0 - sqrt(1.0 - Pprim)) / (B * (1.0 - D) * Pprim)
!       alpha_max = (1.0 - A - B) * (1.0 + sqrt(1.0 - Pprim)) / (B * (1.0 - D) * Pprim)
!       alpha_expl = min(mult_alpha * alpha_min, 0.5 * (alpha_min + alpha_max))
!    
! ! ! !       Fjm1d2=demi*(v(ie-1)*s(ie-1)+v(ie)*s(ie))-demi*gamma_expl*(dt/mesh%crosssection(ie)%delta)&
! ! ! !       *g*(bathy_cell(ie)+h(ie  )-bathy_cell(ie-1)-h(ie-1))*(s(ie-1)+s(ie))*demi
! ! ! !       Fjp1d2=demi*(v(ie+1)*s(ie+1)+v(ie)*s(ie))-demi*gamma_expl*(dt/mesh%crosssection(ie)%delta)&
! ! ! !       *g*(bathy_cell(ie+1)+h(ie+1)-bathy_cell(ie)- h(ie  ))*(s(ie+1)+s(ie))*demi
! !       Fjm1d2=demi*(v(ie-1)*s(ie-1)+v(ie)*s(ie))-demi*gamma_expl_v(1, ie)*(dt/mesh%crosssection(ie)%delta)&
! !       *g*(bathy_cell(ie)+h(ie  )-bathy_cell(ie-1)-h(ie-1))*(s(ie-1)+s(ie))*demi
! !       Fjp1d2=demi*(v(ie+1)*s(ie+1)+v(ie)*s(ie))-demi*gamma_expl_v(2, ie)*(dt/mesh%crosssection(ie)%delta)&
! !       *g*(bathy_cell(ie+1)+h(ie+1)-bathy_cell(ie)- h(ie  ))*(s(ie+1)+s(ie))*demi
! 
!       Hjm1 = bathy_cell(ie-1)+h(ie-1)
!       Hj = bathy_cell(ie)+h(ie)
!       Hjp1 = bathy_cell(ie+1)+h(ie+1)
!       lambda = dt/mesh%crosssection(ie)%delta
!       Fjm1d2=demi*(v(ie-1)*s(ie-1)+v(ie)*s(ie))-&
!              gamma_expl_v(1,ie)*g*lambda*(Hj-Hjm1)*demi*(s(ie-1)+s(ie))
!       Fjp1d2=demi*(v(ie+1)*s(ie+1)+v(ie)*s(ie))-&
!              gamma_expl_v(2,ie)*g*lambda*(Hjp1-Hj)*demi*(s(ie+1)+s(ie))
!       
      !Fjm1d2=demi*(v(ie-1)*s(ie-1)+v(ie)*s(ie))-demi*gamma_expl*(dt/mesh%crosssection(ie)%delta)*g*(h(ie  )-h(ie-1))*(s(ie-1)+s(ie))*demi
      !Fjp1d2=demi*(v(ie+1)*s(ie+1)+v(ie)*s(ie))-demi*gamma_expl*(dt/mesh%crosssection(ie)%delta)*g*(h(ie+1)-h(ie  ))*(s(ie+1)+s(ie))*demi
!       dof%s(ie)=dof%s(ie)-(dt/mesh%crosssection(ie)%delta)*(Fjp1d2-Fjm1d2)
!       call UpdateMVectorElement(mesh,dof,ie,mvector)                 ! Update of mvector 
!       call SurfaceToHeightCrossSection(mesh,dof,ie,mvector)          ! Update of dof%h(ie)
   end do

   
   !call SurfaceToHeight(mesh,dof)


   !===================================================================================================================!
   !  Calculating explicit Q
   !===================================================================================================================! 
   do ie=3,mesh%ncs+2

      vjm1=v( ie-1 )
      vj  =v( ie   )
      vjp1=v( ie+1 )
      wjm1=GetWFromH(mesh,dof%h(ie-1),ie-1)
      wj  =GetWFromH(mesh,dof%h(ie),ie)
      wjp1=GetWFromH(mesh,dof%h(ie+1),ie+1)
   
      lambda = dt / mesh%crosssection(ie)%delta
      Ch = 0.5 * g / wj
      P     = lambda**2 * Ch * wj / ((1.0 - A - B) * D)
      Pprim = lambda**2 * 2.0 * Ch * wj / (B * (1.0 - D))
      gamma_min = (1.0 - D) * (1.0 - sqrt(1.0 - P)) / (4.0 * (1.0 - A - B) * D * P)
      gamma_max = (1.0 - D) * (1.0 + sqrt(1.0 - P)) / (4.0 * (1.0 - A - B) * D * P)
      gamma_expl = min(mult_gamma * gamma_min, 0.5 * (gamma_min + gamma_max))
      alpha_min = (1.0 - A - B) * (1.0 - sqrt(1.0 - Pprim)) / (B * (1.0 - D) * Pprim)
      alpha_max = (1.0 - A - B) * (1.0 + sqrt(1.0 - Pprim)) / (B * (1.0 - D) * Pprim)
      alpha_expl = min(mult_alpha * alpha_min, 0.5 * (alpha_min + alpha_max))
      
! ! !       Fjm1d2=demi*(v(ie-1)*s(ie-1)+v(ie)*s(ie))-d1p4*g*gamma_expl*&
! ! !       (dt/mesh%crosssection(ie)%delta)*(bathy_cell(ie)+h(ie  )-bathy_cell(ie-1)-h(ie-1))*(s(ie-1)+s(ie))
! ! !       Fjp1d2=demi*(v(ie+1)*s(ie+1)+v(ie)*s(ie))-d1p4*g*gamma_expl*&
! ! !       (dt/mesh%crosssection(ie)%delta)*(bathy_cell(ie+1)+h(ie+1)-bathy_cell(ie)- h(ie  ))*(s(ie+1)+s(ie))
!       Fjm1d2=demi*(v(ie-1)*s(ie-1)+v(ie)*s(ie))-d1p4*g*gamma_expl_v(1, ie)*&
!       (dt/mesh%crosssection(ie)%delta)*(bathy_cell(ie)+h(ie  )-bathy_cell(ie-1)-h(ie-1))*(s(ie-1)+s(ie))
!       Fjp1d2=demi*(v(ie+1)*s(ie+1)+v(ie)*s(ie))-d1p4*g*gamma_expl_v(2, ie)*&
!       (dt/mesh%crosssection(ie)%delta)*(bathy_cell(ie+1)+h(ie+1)-bathy_cell(ie)- h(ie  ))*(s(ie+1)+s(ie))
      Hjm1 = bathy_cell(ie-1)+h(ie-1)
      Hj = bathy_cell(ie)+h(ie)
      Hjp1 = bathy_cell(ie+1)+h(ie+1)
      Fjm1d2=demi*(v(ie-1)*s(ie-1)+v(ie)*s(ie))-&
             gamma_expl_v(1,ie)*g*lambda*(Hj-Hjm1)*demi*(s(ie-1)+s(ie))
      Fjp1d2=demi*(v(ie+1)*s(ie+1)+v(ie)*s(ie))-&
             gamma_expl_v(2,ie)*g*lambda*(Hjp1-Hj)*demi*(s(ie+1)+s(ie))


      !Fjm1d2=demi*(v(ie-1)*s(ie-1)+v(ie)*s(ie))-d1p4*g*gamma_expl*(dt/mesh%crosssection(ie)%delta)*(h(ie  )-h(ie-1))*(s(ie-1)+s(ie))
      !Fjp1d2=demi*(v(ie+1)*s(ie+1)+v(ie)*s(ie))-d1p4*g*gamma_expl*(dt/mesh%crosssection(ie)%delta)*(h(ie+1)-h(ie  ))*(s(ie+1)+s(ie))
      
!       alpha_expl=alpha_expl/5.0_rp
!       !Phijm1d2=demi*(h(ie-1)+bathy_cell(ie-1)+h(ie)+bathy_cell(ie))-alpha_expl*(dt/mesh%crosssection(ie)%delta)*&
!       !   demi*(v(ie  )*(h(ie  ))-v(ie-1)*(h(ie-1)))
!       !Phijp1d2=demi*(h(ie+1)+bathy_cell(ie+1)+h(ie)+bathy_cell(ie))-alpha_expl*(dt/mesh%crosssection(ie)%delta)*&
!       !   demi*(v(ie+1)*(h(ie+1))-v(ie  )*(h(ie  )))
!       Phijm1d2=demi*(h(ie-1)+bathy_cell(ie-1)+h(ie)+bathy_cell(ie))-alpha_expl*(dt/mesh%crosssection(ie)%delta)*&
!          demi*(v(ie  )*(h(ie  )+bathy_cell(ie))-v(ie-1)*(h(ie-1)+bathy_cell(ie-1)))
!       Phijp1d2=demi*(h(ie+1)+bathy_cell(ie+1)+h(ie)+bathy_cell(ie))-alpha_expl*(dt/mesh%crosssection(ie)%delta)*&
!          demi*(v(ie+1)*(h(ie+1)+bathy_cell(ie+1))-v(ie  )*(h(ie  )+bathy_cell(ie)))
! 
! ! !       L = 0.5 * (wjm1 + wj)
! ! !       Phijm1d2=demi*(h(ie-1)+bathy_cell(ie-1)+h(ie)+bathy_cell(ie))- &
! ! !                alpha_expl*(dt/mesh%crosssection(ie)%delta)*demi*(v(ie)*s(ie)-v(ie-1)*s(ie-1)) / (2 * L)
! ! !       L = 0.5 * (wj + wjp1)
! ! !       Phijp1d2=demi*(h(ie+1)+bathy_cell(ie+1)+h(ie)+bathy_cell(ie))-&
! ! !                alpha_expl*(dt/mesh%crosssection(ie)%delta)*demi*(v(ie+1)*s(ie+1)-v(ie)*s(ie)) / (2 * L)
      L = 0.5 * (wjm1 + wj)
      Phijm1d2=demi*(h(ie-1)+bathy_cell(ie-1)+h(ie)+bathy_cell(ie))- &
               alpha_expl_v(1, ie)*(dt/mesh%crosssection(ie)%delta)*demi*(v(ie)*s(ie)-v(ie-1)*s(ie-1)) / (2 * L)
      L = 0.5 * (wj + wjp1)
      Phijp1d2=demi*(h(ie+1)+bathy_cell(ie+1)+h(ie)+bathy_cell(ie))-&
               alpha_expl_v(2, ie)*(dt/mesh%crosssection(ie)%delta)*demi*(v(ie+1)*s(ie+1)-v(ie)*s(ie)) / (2 * L)


      q=dof%q(ie)


      tflux1(ie)  = Fjm1d2
      tflux1(ie+1)= Fjp1d2

      dof%s(ie)=dof%s(ie)-(dt/mesh%crosssection(ie)%delta)*(Fjp1d2-Fjm1d2)
      call UpdateMVectorElement(mesh,dof,ie,mvector)                 ! Update of mvector 
      call SurfaceToHeightCrossSection(mesh,dof,ie,mvector)          ! Update of dof%h(ie)


      !===================================================
      !  S,Q computation with source term (friction)
      !===================================================
      if (friction.eq.1) then 
         call computationRhCrossSection(mesh,dof,hydraulicRadiusie,ie,mvector) !Hydraulics computation (if friction==1)
            call calc_K_at_cs(dof, Manning, ie)                  ! Update of Manning
         SfS=(q*abs(q))/(((manning**2))*(s(ie))*(hydraulicRadiusie**d4p3))  ! Sf*S= |q|*q /(K^2*S*Rh^(4/3)                
         SourceTermFriction=-g*SfS
      else 
         SourceTermFriction=0._rp
      end if

      Rj      = SourceTermFriction
      

     
      dof%q(ie)=v(ie)*s(ie)-(dt/mesh%crosssection(ie)%delta)*&
      ((max(Fjp1d2,0._rp)*vj+min(Fjp1d2,0._rp)*vjp1)-(max(Fjm1d2,0._rp)*vjm1+min(Fjm1d2,0._rp)*vj)) &
      -((g*dt)/(mesh%crosssection(ie)%delta))*s(ie)*(Phijp1d2-Phijm1d2)&
      +dt*Rj
      if ((abs(dof%q(ie)).le.zerom)) then
         dof%q(ie)=0.0
      endif
   
   end do
  
   !call updateW(mesh,dof)


END SUBROUTINE explicit_low_froude

