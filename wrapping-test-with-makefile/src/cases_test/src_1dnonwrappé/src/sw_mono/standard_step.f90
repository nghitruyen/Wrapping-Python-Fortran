! #define DEBUG_L3
!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), fiitere volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, fiitere elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), fiitere volumes or fiitere differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the iiterial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file backwater.f90
!! \brief This file includes the computation of backwater curve

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute backwater curve
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Compute backwater curve
!!
!! \details This subroutine computes a steady profile using standard stepo method and update the dof values accordingly
!! \param[in] mesh Mesh of the model.
!! \param[in,out] dof Unknowns of the model.
!! \param[in] eps Convergence criterion.
!! \param[in] itermax Maximum number of non-linear iterations.
SUBROUTINE standard_step(mesh, dof, eps, itermax)

   USE m_mesh
   USE m_model
   USE m_numeric
   USE m_user_data

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in   )  ::  mesh
   type( unk ), intent(inout)  ::  dof
   real(rp),    intent(in   )  ::  eps
   integer(ip), intent(in   )  ::  itermax

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!

      real(rp) :: q                                     ! Discharge
      real(rp) :: zi, zip1                              ! Water elevations
!       real(rp) :: w                                   ! Water surface width 
      real(rp) :: perimeter                             ! Wet Perimeter 
      real(rp) :: rhi, rhip1                            ! Hydraulic radiuses
      real(rp) :: Manning                               ! Manning
      real(rp) :: w                                     ! Width
      real(rp) :: debitancei, debitanceip1, debitance   ! Debitances
      real(rp) :: fr2                                   ! Froude square
      real(rp) :: dx                                    ! Spatial step size
      real(rp) :: So                                    ! Bathy slope
      real(rp) :: Sf                                    ! Friction slope
      
      real(rp) :: f                                     ! Function value for Newton iterations
      real(rp) :: df                                    ! Function gradient for Newton iterations
      real(rp) :: dh                                    ! Delta depth
      real(rp) :: dPdZ                                  ! Gradient of wetted perimeter wrt elevation
      real(rp)  :: dK_dh                                ! Gradient of Strickler coeff wrt water height
      real(rp) :: hmin                                  ! Minimum depth for secant method
      real(rp) :: hmax                                  ! Maximum depth for secant method
      
      
      integer(ip), dimension(mesh%ncs+4) :: mvector     ! Vector m
      real(rp)  ::  hci                                 ! Critical depth
      real(rp)  ::  hip1, hi, hikm1, hikm2              ! Water depths
      real(rp)  ::  errkm1, errkm2                      ! Errors in depths
      real(rp)  ::  vi, vip1                            ! Velocities
      
      integer(ip) :: iter                               ! Iterations counter
      
!======================================================================================================================!
!  External Functions
!======================================================================================================================!
      real(rp)  :: PerimeterFromH
      real(rp)  :: GetWFromH
      real(rp)  :: HtoS
      real(rp)  :: dPdZFromH
      
      
   
!======================================================================================================================!
!  Begin Subroutine
!======================================================================================================================!


   !===================================================================================================================!
   !  Compute downstream dof
   !===================================================================================================================!
   call calc_boundary_state(mesh, dof)
   i = mesh%ncs+2
   dof%q(i) = dof%q(1)
   dof%q(i+1) = dof%q(1)
   
   if (BC_E == 'elevation') then
   
    ! Compute S as h is computed in calc_boundary_state
    dof%s(i) = HtoS(mesh, i, dof%h(i))
    call UpdateMVectorElement(mesh, dof, i, mvector)
   
   else if (BC_E == 'normal_depth' .or. BC_E == "neumann") then
   
      !================================================================================================================!
      ! Newton to compute hn (normal depth)
      !================================================================================================================!
      
      dof%h(i) = 1.0
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      dh = 1.0
      dx = mesh%crosssection(i)%deltademi
!       So = (bathy_cell(i) - bathy_cell(i+1)) / dx
!       if (So < 1e-9) then
!         So = (bathy_cell(mesh%ncs+2) - bathy_cell(mesh%ncs+3)) / mesh%CrossSection(mesh%ncs+1)%deltademi
!       end if
      So = max(1e-8, (bathy_cell(i) - bathy_cell(i+1)) / dx)
#ifdef DEBUG_L3
      print *, "NORMAL_DEPTH:So=", So
#endif
      iter = 0
#ifdef DEBUG_L3
      print *, "NORMAL_DEPTH:First pass..."
#endif
      do while (abs(dh) > 1e-3 .and. iter < 100)
         call UpdateMVectorElement(mesh, dof, i, mvector)
         call calc_K_at_cs(dof, Manning, i)
         perimeter = PerimeterFromH(mesh, dof%h(i), i, mvector)
         rhi = dof%s(i) / perimeter
         w = GetWFromH(mesh, dof%h(i), i)
         dPdZ = min(100.0_rp, dPdZFromH(mesh,dof%h(i),i,mvector))
         call calc_dK_dh(mesh, dof, dK_dh, i, mvector)
         df = rhi**d2p3*(dK_dh*dof%s(i)+Manning*(d5p3*w-d2p3*rhi*dPdZ))*sqrt(So)
         f = Manning*dof%s(i)*rhi**d2p3*sqrt(So) - dof%q(i)
         dh = - f / df
#ifdef DEBUG_L3
         print *, "--Hn", dof%h(i)
         print *, "--A=", dof%s(i)
         print *, "--P=", perimeter
         print *, "--Rh=", rhi
         print *, "--D=", Manning*dof%s(i)*rhi**d2p3
         print *, "--Qn=", Manning*dof%s(i)*rhi**d2p3*sqrt(So)
         print *, "--dh=", dh, abs(dH), abs(dH) > 1e-3
         print *, "--F=", f
         print *, "--dF=", df, dK_dh, dPdZ
         read(*,*)
#endif
         dof%h(i) = max(normal_depth_heps, dof%h(i) - f / df)
         dof%s(i) = HtoS(mesh, i, dof%h(i))
! #ifdef DEBUG_L3
!          print *, "  ", iter, dof%h(i), f, df
!          print *, "  **  ", Manning, perimeter, rhi, w, dPdZ
! #endif
         iter = iter + 1
      end do
#ifdef DEBUG_L3
      print *, "NORMAL_DEPTH:First pass=", iter, dof%h(i)
#endif
      if (iter >= 100) then
      
         !=============================================================================================================!
         ! Secant method to compute hn
         !=============================================================================================================!
         hmin = heps
         hmax = mesh%crosssection(i)%height(size(mesh%crosssection(i)%height))
         do while (hmax - hmin > 1e-4 .and. iter < 1000)
        
            dof%h(i) = 0.5 * (hmin + hmax)
            dof%s(i) = HtoS(mesh, i, dof%h(i))
            call UpdateMVectorElement(mesh, dof, i, mvector)
            call calc_K_at_cs(dof, Manning, i)                   
            perimeter = PerimeterFromH(mesh, dof%h(i), i, mvector)
            rhi = dof%s(i) / perimeter
            w = GetWFromH(mesh, dof%h(i), i)
            if (Manning*dof%s(i)*rhi**d2p3*sqrt(So) < dof%q(i)) then
               hmin = dof%h(i)
            else
               hmax = dof%h(i)
            end if
            
         end do 
         !<NOADJ
         if (iter > 1000) then
            print *, "NORMAL_DEPTH:UNCONVERGED", dof%h(i), Manning*dof%s(i)*rhi**d2p3*sqrt(So), dof%q(i) 
            read(*,*)
         end if
         !>NOADJ
      end if
   
   else if (BC_E == 'ratcurve') then
   
      !================================================================================================================!
      ! Compute h from rating curve
      !================================================================================================================!
      if (bc%typerat=='file') then
          dof%h(i) = linear_interp(bc%rat%q, bc%rat%h, dof%q(i)) - bathy_cell(i)
!           print *, "h(E)=", linear_interp(bc%rat%q, bc%rat%h, dof%q(i)) - bathy_cell(i)
      else if (alpha_ratcurve > 0.0) then
          dof%h(i) = alpha_ratcurve * abs(dof%q(i))**beta_ratcurve
      end if
      
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      call UpdateMVectorElement(mesh, dof, i, mvector)

   else
      !================================================================================================================!
      ! Use h0_user in the m_user_data.f90 as h_downstream
      !================================================================================================================!

      dof%h(i) = max( 0.0_rp , h0_user( mesh%CrossSection(i)%coord%x , mesh%CrossSection(i)%coord%y ) )
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      call UpdateMVectorElement(mesh, dof, i, mvector)
      
      
   end if
   
#ifdef DEBUG_L3
   print *, "STANDARD_STEP(E):", i-2, dof%h(i) + bathy_cell(i), dof%s(i)
   read(*,*)
#endif
    
   !===================================================================================================================!
   !  Compute dof using standard step method
   !===================================================================================================================!
   do i = mesh%ncs+1, 1, -1

      !================================================================================================================!
      !  Retrieve discharge and dx
      !================================================================================================================!
      q = dof%q(i+1)
      dx = mesh%crosssection(i+1)%deltademi
      
      !================================================================================================================!
      !  Retrieve state variables for i+1-th cross-section
      !================================================================================================================!
      hip1 = dof%h(i+1)
      zip1 = dof%h(i+1) + bathy_cell(i+1)
      perimeter = PerimeterFromH(mesh, dof%h(i+1), i+1, mvector)
      rhip1 = dof%s(i+1) / perimeter
      call calc_K_at_cs(dof, Manning, i+1)                   
      vip1 = q / dof%s(i+1)
      debitanceip1 = Manning * dof%s(i+1) * (rhip1**(d2p3))

      !================================================================================================================!
      !  Compute critical depth for i-th cross-section
      !================================================================================================================!
      call bisect_critical_depth(mesh, dof, i, q, hci)
      
      !================================================================================================================!
      !  Convergence loop
      !================================================================================================================!
!       print *, "INIT:", zip1, hip1
      hikm1 = hip1
      hikm2 = hip1 + 0.1
      iter = 0
!       print *, " - check:", abs(hikm1 - hikm2), eps
!       read(*,*)
#ifdef DEBUG_L3
      print *, "OPTIM_pass..."
      open(73, file="cs_area.dat")
      do iter = 0, size(mesh%crosssection(i)%height)
         if (iter == 0) then
            dof%h(i) = 0
         else
            dof%h(i) = mesh%crosssection(i)%height(iter) - bathy_cell(i)
         end if
         call UpdateMVectorElement(mesh, dof, i, mvector)
         write(73,*) dof%h(i)+bathy_cell(i), PerimeterFromH(mesh, dof%h(i), i, mvector)
      end do
      close(73)
      iter = 0
#endif
      do while(abs(hikm1 - hikm2) > eps .and. iter < itermax)
      
         iter = iter + 1
         zi = hikm1 + bathy_cell(i)
         dof%h(i) = hikm1
#ifdef DEBUG_L3
         print *, " ** UPDATE:", zi
#endif
         dof%s(i) = HtoS(mesh, i, dof%h(i))
         call UpdateMVectorElement(mesh, dof, i, mvector)
        
         perimeter = PerimeterFromH(mesh, dof%h(i), i, mvector)
         rhi = dof%s(i) / perimeter
         call calc_K_at_cs(dof, Manning, i)
         debitancei = Manning * dof%s(i) * (rhi**(d2p3))
         vi = q / dof%s(i)
         debitance = 0.5 * (debitancei + debitanceip1)
         Sf = (q / debitance)**2
#ifdef DEBUG_L3
         print *, " ** Rh", rhi, rhip1
         print *, " ** P", perimeter
         print *, " ** A", dof%s(i), dof%s(i+1)
         print *, " ** V", vi, vip1
         print *, " ** B", bathy_cell(i), bathy_cell(i+1)
         print *, " ** Z", zi, zip1
         print *, " ** D", debitance
         print *, " ** Sf", Sf
         print *, " ** Hc", hci
#endif
         zi = zip1 + 0.5 * (vip1**2 - vi**2) / g + dx * Sf
         hi = zi - bathy_cell(i)
         if (hi < hci) hi = hci
        
         !=============================================================================================================!
         !  Update water depth
         !=============================================================================================================!
!          print *, " - step:", iter, hi
!          read(*,*)
         if (iter == 1) then
            errkm1 = hi - hikm1
            hikm1 = hikm1 + 0.7 * errkm1
         else
            errkm2 = errkm1
            errkm1 = hi - hikm1
            if (abs(errkm2 - errkm1) < 1e-2) then
               hi = hikm2 + 0.5 * errkm2
            else
               hi = hikm2 - errkm2 * (hikm2 - hikm1) / (errkm2 - errkm1)
            end if
#ifdef DEBUG_L3
            if (hi < hci) then
              print *, "hi < hci", i
              print *, " ** Rh", rhi, rhip1
              print *, " ** P", perimeter
              print *, " ** A", dof%s(i), dof%s(i+1)
              print *, " ** V", vi, vip1
              print *, " ** B", bathy_cell(i), bathy_cell(i+1)
              print *, " ** Z", zi, zip1
              print *, " ** D", debitance
              print *, " ** Sf", Sf
              print *, " ** Hc", hci
              read(*,*)
            end if
#endif
            if (hi < hci) hi = hci
            hikm2 = hikm1
            hikm1 = hi
         end if
#ifdef DEBUG_L3
         print *, " == ", hi, hikm1, hikm2
#endif
      end do
      
      !================================================================================================================!
      !  Compute final water depth and updates mvector for i-th cross-section
      !================================================================================================================!
      dof%h(i) = 0.5 * (hikm1 + hikm2)
#ifdef DEBUG_L3
      if (dof%h(i) < heps) then 
        print *, "h < heps:", dof%h(i), heps, hci
      end if
#endif
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      dof%q(i) = q
      call UpdateMVectorElement(mesh, dof, i, mvector)
#ifdef DEBUG_L3
      print *, "STANDARD_STEP(0):", i-2, dof%h(i) + bathy_cell(i), dof%s(i)
      if (i-2==1) read(*,*)
#endif
        
   end do

   !============================================================================================!
   !  Init downstream ghost cells 
   !  -> for simplicity, just equal to the most downstream dof (to change to be more consistent ?)
   !============================================================================================!
   i = mesh%ncs+2
   ! mesh%ncs+3
   dof%h(i+1) = dof%h(i)
   dof%s(i+1) = dof%s(i)
   dof%q(i+1) = dof%q(i)
   ! mesh%ncs+4
   dof%h(i+2) = dof%h(i)
   dof%s(i+2) = dof%s(i)
   dof%q(i+2) = dof%q(i)
   
   open(101, file="res/criticaldepth_initial.dat")
   do i = 3, mesh%ncs+2
   
      !================================================================================================================!
      !  Compute critical depth for i-th cross-section
      !================================================================================================================!
      call bisect_critical_depth(mesh, dof, i, q, hci)
      write(101, *) mesh%CrossSection(i)%coord%x, hci
      
   end do
   close(101)

   
END SUBROUTINE standard_step
