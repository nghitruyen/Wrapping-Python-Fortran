!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file output_sw.f90
!! \brief This file includes routines of creation of ouput results file.

! #define WITH_FORCE_GRADIENTS_OUTPUT
!#define WRITE_RAWBIN

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main Subroutine Managing Output Files
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Main subroutine managing output files
!!
!! \details This subroutine manages others to write result file.
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
SUBROUTINE write_results( dof , mesh )

   USE m_common
   USE m_time_screen
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   TYPE( unk ), intent(in)  ::  dof
   TYPE( msh ), intent(in)  ::  mesh

   !===================================================================================================================!
   !  Testing if it is time to write a result file
   !===================================================================================================================!
   if ( .not. test_dt_nearest( dtw ) .and. &
              tc > zerom                .and. &
              abs( tc - ts ) > zerom    .and. &
              nt /= max_nt_for_direct ) return

   !===================================================================================================================!
   !  Output Screen
   !===================================================================================================================!

   call Print_Screen( 'result' )

   !===================================================================================================================!
   !  Writing Result File
   !===================================================================================================================!

!    call system('mkdir -p res')
   call write_result_file( dof , mesh , 'res/result' )

   call write_restart_direct( dof , mesh )

   !===================================================================================================================!
   !  Writing Exact Solution
   !===================================================================================================================!

! #ifdef USE_VALID
   if      ( w_exact == 1 ) then

      call write_exact_solution( mesh )

   else if ( w_exact == 2 .and. nt == 0 ) then

      call write_exact_solution( mesh )

   end if
! #endif
   
#ifdef USE_REF_HEIGHT
   call write_ref_height_file(dof, mesh, 'res/ref_heights')
#endif

 END SUBROUTINE write_results
 

!>  Main subroutine managing output files
!!
!! \details This subroutine manages others to write result file (use to stationnary computation).
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
SUBROUTINE write_results_temp( dof , mesh )

   USE m_common
   USE m_time_screen
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   TYPE( unk ), intent(in)  ::  dof
   TYPE( msh ), intent(in)  ::  mesh


   !===================================================================================================================!
   !  Output Screen
   !===================================================================================================================!

   call Print_Screen( 'result_bis' )

   !===================================================================================================================!
   !  Writing Result File
   !===================================================================================================================!

   call system('mkdir -p res')
   call write_result_file( dof , mesh , 'res/result' )

   !call write_restart_direct( dof , mesh )

   !===================================================================================================================!
   !  Writing Exact Solution
   !===================================================================================================================!

! #ifdef USE_VALID
      if      ( w_exact == 1 ) then

         call write_exact_solution( mesh )

      else if ( w_exact == 2 .and. nt == 0 ) then

         call write_exact_solution( mesh )

      end if

! #endif

#ifdef USE_REF_HEIGHT
   call write_ref_height_file(dof, mesh, 'res/ref_heights')
#endif
   
END SUBROUTINE write_results_temp



!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main Subroutine to Write a Result File
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Main subroutine to write a result file
!!
!! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile.  
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
!! \param[in]    namefile Name of the file.
SUBROUTINE write_result_file( dof , mesh , namefile )

   USE m_common
   USE m_time_screen
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   TYPE( unk ), intent(in)  ::  dof
   TYPE( msh ), intent(in)  ::  mesh

   character(len=*), intent(in)  ::  namefile

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   character(200)  ::  filename
   character(150) :: tmpdir
   logical :: dir_exists

   !===================================================================================================================!
   !  Creating result file name
   !===================================================================================================================!
   call get_environment_variable("DASSFLOW1D_TMPDIR", tmpdir)
   if (len_trim(tmpdir) > 0) then
   
      ! Check and create res dir if necessary
      inquire(file=trim(tmpdir)//"/res", EXIST=dir_exists)
      if (.not. dir_exists) then
        print *, "mkdir "//trim(tmpdir)//"/res!!!"
        call system('mkdir -p '//trim(tmpdir)//"/res")
      end if
   
      if      ( tc < zerom ) then
          write(filename,'(A,"/",A,"_initial")') trim(tmpdir), namefile
      else if ( abs( tc - ts ) < zerom ) then
          write(filename,'(A,"/",A,"_final")') trim(tmpdir), namefile
      else
          write(filename,'(A,"/",A,"_",ES12.6)') trim(tmpdir), namefile , tc
      end if
   else
      inquire(file="res", EXIST=dir_exists)
      if (.not. dir_exists) then
        print *, "mkdir res!!!"
        call system('mkdir -p res')
      end if
      if      ( tc < zerom ) then
          write(filename,'(A,"_initial")') namefile
      else if ( abs( tc - ts ) < zerom ) then
          write(filename,'(A,"_final")') namefile
      else
          write(filename,'(A,"_",ES12.6)') namefile , tc
      end if
   end if

   !===================================================================================================================!
   !  Gnuplot result file output
   !===================================================================================================================!

#ifdef WRITE_RAWBIN
   call v_rawbin( dof , mesh , trim(filename)//'.bin' )
#else
   call v_gnuplot( dof , mesh , trim(filename)//'.dat' )
#endif
#ifdef WITH_EXT_OUTPUT
   call v_gnuplot_ext( dof , mesh , trim(filename)//'.ext' )
#endif
#ifdef WITH_FORCE_GRADIENTS_OUTPUT
   call v_gnuplot_dSf( dof , mesh , trim(filename)//'.dsf' )
!    call v_gnuplot_dF4( dof , mesh , trim(filename)//'.dfi' )
#endif
   

END SUBROUTINE write_result_file

   
!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write Normal and Critical depth File
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

#ifdef USE_REF_HEIGHT

!>  Main subroutine to write the normal and critical heights on a result file
!!
!! \details This subroutine writes exact result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file.
!! \param[in] dof Unknowns of the model.
!! \param[in] mesh Mesh of the model.
!! \param[in] namefile Name of the output file.

SUBROUTINE write_ref_height_file( dof, mesh, namefile )
  
  USE m_common
  USE m_time_screen
  USE m_model
  USE m_user_data

  implicit none

  !================================================================================================================!
  !  Interface Variables
  !================================================================================================================!
  
  type( unk ), intent(in)  ::  dof
  TYPE( msh ), intent(in)  ::  mesh
  character(len=*), intent(in)  ::  namefile
  ! Local variable
  character(50) ::  filename

  !================================================================================================================!
  !  Calculating normal depth 
  !================================================================================================================!
  
  allocate( hn( mesh%ncs+3 ) )
  call computes_normal_depth(mesh, dof)
  
  !================================================================================================================!
  !  Calculating critical depth 
  !================================================================================================================!

  allocate( hc( mesh%ncs+3 ) )
  call computes_critical_depth(mesh, dof)

  !===================================================================================================================!
  !  Creating result file
  !===================================================================================================================!
  
  if      ( tc < zerom ) then
     write(filename,'(A,"_initial")') namefile
  else if ( abs( tc - ts ) < zerom ) then
     write(filename,'(A,"_final")') namefile
  else
     write(filename,'(A,"_",ES12.6)') namefile , tc
  end if
  
  filename = trim(filename)//'.dat'
  open(10, file=filename, status='replace', form='formatted')
  write(10,*) '# File with the normal and critical depth at each point of the mesh'
  write(10,*) '#  hn            hc'
  do i=3,mesh%ncs+2
     write(10,'(2ES16.8)') hn(i), hc(i)
  end do
  close(10)

  deallocate(hn)
  deallocate(hc)
  
END SUBROUTINE write_ref_height_file

#endif


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write a restart direct file
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Write a restart direct file
!!
!! \details This subroutine writes a restart direct file. This file is read if the computation have been stopped. 
!! It is possible to use this file to impose initial condition.  
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
SUBROUTINE write_restart_direct( dof , mesh )

   USE m_common
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   type( unk ), intent(in)  ::  dof
   type( msh ), intent(in)  ::  mesh

   real(rp) :: q
   !===================================================================================================================!
   !  Begin Subroutine
   !===================================================================================================================!


   open(10,file='restart.bin',status='replace',form='unformatted',access='direct',recl=3*length_real)

   write(10,rec=1) tc

   close(10)


   open(10,file='restart.bin',status='old',form='unformatted',access='direct',recl=3*length_real)


   if (Qinterface.eq.1) then
      do i = 1,mesh%ncs+3
         q=(0.5_rp*tflux1(i  )*mesh%crosssection(i  )%deltademi + &
            0.5_rp*tflux1(i+1)*mesh%crosssection(i+1)%deltademi)/ &
            mesh%crosssection(i)%delta
         write(10,rec=1+i) dof%h(i) , dof%s(i) , q
      end do
         write(10,rec=1+i) dof%h(mesh%ncs+4) , dof%s(mesh%ncs+4) , dof%q(mesh%ncs+4)
   else 
      do i = 1,mesh%ncs+4
         write(10,rec=1+i) dof%h(i) , dof%s(i) , dof%q(i)
      end do
   end if 

   close(10)

   
END SUBROUTINE write_restart_direct




!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write Exact Solution File
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!


! #ifdef USE_VALID

   !>  Main subroutine to write exact solution on a result file
   !!
   !! \details This subroutine writes exact result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file.
   !! This subroutine is usable when the exact solution of the model is avaible (analytics solution define in
   !! m_user.f90 file).  
   !! \param[in]    mesh Mesh of the model.

   SUBROUTINE write_exact_solution( mesh )

      USE m_common
      USE m_time_screen
      USE m_model
      USE m_user_data

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      TYPE( msh ), intent(in)  ::  mesh

      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      TYPE( unk )  ::  dof_exact

      real(rp) :: StoH

      !================================================================================================================!
      !  Calculating exact solution
      !================================================================================================================!

      call alloc_dof( dof_exact , mesh )

      do i = 3,mesh%ncs+2

         dof_exact%S(i) = max( 0._rp , S_exact( mesh%crosssection(i)%coord%x , mesh%crosssection(i)%coord%y , tc ) )


         dof_exact%h(i) = StoH(mesh, i , dof_exact%S(i) )


         if ( dof_exact%s(i) <= 0._rp ) then

            dof_exact%Q(i) = 0._rp

         else

            dof_exact%Q(i) = q_exact( mesh%crosssection(i)%coord%x , mesh%crosssection(i)%coord%y , tc )
         end if

      end do

      !================================================================================================================!
      !  Writing exact solution
      !================================================================================================================!

      call write_result_file( dof_exact , mesh , 'res/result_exact' )

      call dealloc_dof( dof_exact )

   END SUBROUTINE write_exact_solution

! #endif



   
!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write an Raw Binary Output Result File
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Main subroutine to write a result file in raw binary format
!!
!! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
!! in raw binary format.  
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
!! \param[in]    filename Name of the file.
SUBROUTINE v_rawbin( dof , mesh , filename )

   USE m_common
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   TYPE( unk ), intent(in)  ::  dof
   TYPE( msh ), intent(in)  ::  mesh

   character(len=*), intent(in)  ::  filename

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   real(rp)  ::  q

   !===================================================================================================================!
   !  Begin Subroutine
   !===================================================================================================================!
   open(10,file=filename,status='replace',access='stream')

   !===================================================================================================================!
   !   Writing raw binary file data
   !===================================================================================================================!

   if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
      do i = 3,mesh%ncs+2
         q=(0.5_rp*tflux1(i  )*mesh%crosssection(i  )%deltademi + &
            0.5_rp*tflux1(i+1)*mesh%crosssection(i+1)%deltademi)/ &
           mesh%crosssection(i)%delta

         write(10) mesh%CrossSection(i)%coord%x    , &
                   mesh%CrossSection(i)%coord%y    , &
                   bathy_cell(i) + dof%h(i)        , &
                   dof%S(i)                        , &
                   q
                                  
      end do
   else 

      do i = 3,mesh%ncs+2
         write(10) mesh%CrossSection(i)%coord%x    , &
                   mesh%CrossSection(i)%coord%y    , &
                   bathy_cell(i) + dof%h(i)        , &
                   dof%S(i)                        , &
                   dof%Q(i)
      end do

   endif

   close(10)


END SUBROUTINE v_rawbin



   
!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write an Gnuplot Output Result File
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Main subroutine to write a result file in gnuplot format
!!
!! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
!! in gnuplot format.  
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
!! \param[in]    filename Name of the file.
SUBROUTINE v_gnuplot( dof , mesh , filename )

   USE m_common
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   TYPE( unk ), intent(in)  ::  dof
   TYPE( msh ), intent(in)  ::  mesh

   character(len=*), intent(in)  ::  filename

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   real(rp)  ::  h , u , v ,fr,q, w

   !===================================================================================================================!
   !  Functions
   !===================================================================================================================!
   real(rp)  :: GetWFromH

   !===================================================================================================================!
   !  Begin Subroutine
   !===================================================================================================================!

   open(10,file=filename,status='replace',form='formatted')

   !===================================================================================================================!
   !   Creating Gnuplot file and header
   !===================================================================================================================!

   write(10,*) '# Gnuplot DataFile Version'
   

   !===================================================================================================================!
   !   Writing VTK file datas
   !===================================================================================================================!
   if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
      if (w_froude.eq.1) then
         write(10,*) '#             x               y           bathy               S            Qint'//&
                     '               h          Froude'
         do i = 3,mesh%ncs+2
            fr=div_by_except_0(div_by_except_0(dof%Q(i),dof%S(i)),sqrt(g*dof%h(i)))
            w = GetWFromH(mesh,dof%h(i),i)
            if (dof%S(i) < 1e-12) then
               fr=0.0
            else
               fr=sqrt(dof%Q(i)**2 * w / (g * dof%S(i)**3))
            end if
            q=(0.5_rp*tflux1(i  )*mesh%crosssection(i  )%deltademi + &
               0.5_rp*tflux1(i+1)*mesh%crosssection(i+1)%deltademi)/ &
               mesh%crosssection(i)%delta

            write(10,'(8ES16.8)') mesh%CrossSection(i)%coord%x    , &
                                  mesh%CrossSection(i)%coord%y    , &
                                  bathy_cell(i)                   , &
                                  dof%S(i)                        , &
                                  q                               , &
                                  dof%h(i)                        , &
                                  fr
                                  
         end do
      else 
         write(10,*) '#             x               y           bathy               S            Qint'//&
                     '               h'
         do i = 3,mesh%ncs+2
            q=(0.5_rp*tflux1(i  )*mesh%crosssection(i  )%deltademi + &
               0.5_rp*tflux1(i+1)*mesh%crosssection(i+1)%deltademi)/ &
               mesh%crosssection(i)%delta         
            write(10,'(7ES16.8)') mesh%CrossSection(i)%coord%x    , &
                                  mesh%CrossSection(i)%coord%y    , &
                                  bathy_cell(i)                   , &
                                  dof%S(i)                        , &
                                  q                               , &
                                  dof%h(i)
                                  
         end do
      endif


   else 

      if (w_froude.eq.1) then
         write(10,*) '#             x               y           bathy               S            Qint'//&
                     '               h          Froude'
         do i = 3,mesh%ncs+2
            fr=div_by_except_0(div_by_except_0(dof%Q(i),dof%S(i)),sqrt(g*dof%h(i)))
            w = GetWFromH(mesh,dof%h(i),i)
            if (dof%S(i) < 1e-12) then
               fr=0.0
            else
               fr=sqrt(dof%Q(i)**2 * w / (g * dof%S(i)**3))
            end if

            write(10,'(8ES16.8)') mesh%CrossSection(i)%coord%x    , &
                                  mesh%CrossSection(i)%coord%y    , &
                                  bathy_cell(i)                   , &
                                  dof%S(i)                        , &
                                  dof%Q(i)                        , &
                                  dof%h(i)                        , &
                                  fr
                                  
         end do
      else 
         write(10,*) '#             x               y           bathy               S            Qint'//&
                     '               h'
         do i = 3,mesh%ncs+2
         
            write(10,'(7ES16.8)') mesh%CrossSection(i)%coord%x    , &
                                  mesh%CrossSection(i)%coord%y    , &
                                  bathy_cell(i)                   , &
                                  dof%S(i)                        , &
                                  dof%Q(i)                        , &
                                  dof%h(i)
                                  
         end do
      endif


   endif

   close(10)


END SUBROUTINE v_gnuplot



   
!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write an Gnuplot Output Result File
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Main subroutine to write a result file in gnuplot format (with extended results)
!!
!! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
!! in gnuplot format.  
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
!! \param[in]    filename Name of the file.
SUBROUTINE v_gnuplot_ext( dof , mesh , filename )

   USE m_common
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   TYPE( unk ), intent(in)  ::  dof
   TYPE( msh ), intent(in)  ::  mesh

   character(len=*), intent(in)  ::  filename

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   integer(ip), dimension(mesh%ncs+4) :: mvector
   
   real(rp)  ::  h , u , v , fr , p, rh, q

   !===================================================================================================================!
   !  Extern functions
   !===================================================================================================================!
   
   real(rp)  :: PerimeterFromH

   !===================================================================================================================!
   !  Begin Subroutine
   !===================================================================================================================!

   open(10,file=filename,status='replace',form='formatted')

   !===================================================================================================================!
   !   Creating Gnuplot file and header
   !===================================================================================================================!

   write(10,*) '# Gnuplot DataFile Version'
   

   !===================================================================================================================!
   !   Writing VTK file datas
   !===================================================================================================================!
   call UpdateMVector(mesh,dof,mvector)

   if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
      if (w_froude.eq.1) then
         write(10,*) '#             x               y           bathy               S            Qint'//&
                     '               h              Rh          Froude'
         do i = 3,mesh%ncs+2
            q=(0.5_rp*tflux1(i  )*mesh%crosssection(i  )%deltademi + &
               0.5_rp*tflux1(i+1)*mesh%crosssection(i+1)%deltademi)/ &
               mesh%crosssection(i)%delta
            p = PerimeterFromH(mesh,dof%h(i),i,mvector)
            rh = dof%S(i) / p
            fr=div_by_except_0(div_by_except_0(dof%Q(i),dof%S(i)),sqrt(g*dof%h(i)))

            write(10,'(9ES16.8)') mesh%CrossSection(i)%coord%x    , &
                                  mesh%CrossSection(i)%coord%y    , &
                                  bathy_cell(i)                   , &
                                  dof%S(i)                        , &
                                  q                               , &
                                  dof%h(i)                        , &
                                  rh                              , &
                                  fr
                                  
         end do
      else 
         write(10,*) '#             x               y           bathy               S            Qint'//&
                     '               h              Rh'
         do i = 3,mesh%ncs+2
            q=(0.5_rp*tflux1(i  )*mesh%crosssection(i  )%deltademi + &
               0.5_rp*tflux1(i+1)*mesh%crosssection(i+1)%deltademi)/ &
               mesh%crosssection(i)%delta         
            p = PerimeterFromH(mesh,dof%h(i),i,mvector)
            rh = dof%S(i) / p
            write(10,'(8ES16.8)') mesh%CrossSection(i)%coord%x    , &
                                  mesh%CrossSection(i)%coord%y    , &
                                  bathy_cell(i)                   , &
                                  dof%S(i)                        , &
                                  q                               , &
                                  dof%h(i)                        , &
                                  rh
                                  
         end do
      endif


   else 

      if (w_froude.eq.1) then
         write(10,*) '#             x               y           bathy               S               Q'//&
                     '               h              Rh          Froude'
         do i = 3,mesh%ncs+2
            p = PerimeterFromH(mesh,dof%h(i),i,mvector)
            rh = dof%S(i) / p
            fr=div_by_except_0(div_by_except_0(dof%Q(i),dof%S(i)),sqrt(g*dof%h(i)))
            write(10,'(9ES16.8)') mesh%CrossSection(i)%coord%x    , &
                                  mesh%CrossSection(i)%coord%y    , &
                                  bathy_cell(i)                   , &
                                  dof%S(i)                        , &
                                  dof%Q(i)                        , &
                                  dof%h(i)                        , &
                                  rh                              , &
                                  fr
                                  
         end do
      else 
         write(10,*) '#             x               y           bathy               S               Q'//&
                     '               h              Rh'
         do i = 3,mesh%ncs+2
         
            p = PerimeterFromH(mesh,dof%h(i),i,mvector)
            rh = dof%S(i) / p
            write(10,'(8ES16.8)') mesh%CrossSection(i)%coord%x    , &
                                  mesh%CrossSection(i)%coord%y    , &
                                  bathy_cell(i)                   , &
                                  dof%S(i)                        , &
                                  dof%Q(i)                        , &
                                  dof%h(i)                        , &
                                  rh
                                  
         end do
      endif


   endif

   close(10)


END SUBROUTINE v_gnuplot_ext



   
!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write an Gnuplot Output Result File
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Main subroutine to write a result file in gnuplot format (with F4 gradients)
!!
!! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
!! in gnuplot format.  
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
!! \param[in]    filename Name of the file.
SUBROUTINE v_gnuplot_dF4( dof , mesh , filename )

   USE m_common
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   TYPE( unk ), intent(in)  ::  dof
   TYPE( msh ), intent(in)  ::  mesh

   character(len=*), intent(in)  ::  filename

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   integer(ip), dimension(mesh%ncs+4) :: mvector
   
   real(rp)  ::  h , u , v , fr , p, rh, q
   real(rp), dimension(mesh%ncs+4) :: Manning   ! Manning
   real(rp), dimension(4) :: dF4          ! Gradients of F4 force term

   !===================================================================================================================!
   !  Extern functions
   !===================================================================================================================!
   
   real(rp)  :: PerimeterFromH

   !===================================================================================================================!
   !  Begin Subroutine
   !===================================================================================================================!

   open(10,file=filename,status='replace',form='formatted')

   !===================================================================================================================!
   !   Creating Gnuplot file and header
   !===================================================================================================================!

   write(10,*) '# Gnuplot DataFile Version'
   write(10,*) '#             x               y           dF4dK           dF4dA          dF4dRh' // &
               '           dF4dQ'

   !===================================================================================================================!
   !   Writing VTK file datas
   !===================================================================================================================!
   call UpdateMVector(mesh,dof,mvector)
   call calc_K_everywhere(dof, mesh, Manning, mvector)                      ! Update of Manning
   
   do i = 3,mesh%ncs+2
      if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
         q=(0.5_rp*tflux1(i  )*mesh%crosssection(i  )%deltademi + &
            0.5_rp*tflux1(i+1)*mesh%crosssection(i+1)%deltademi)/ &
           mesh%crosssection(i)%delta
      else
         q = dof%Q(i)
      end if
      p = PerimeterFromH(mesh,dof%h(i),i,mvector)
      rh = dof%S(i) / p
      
      dF4(1) = - 2.0_rp * q**2 / (Manning(i)**3 * dof%S(i)**2 * rh**d4p3)
      dF4(2) = - 2.0_rp * q**2 / (Manning(i)**2 * dof%S(i)**3 * rh**d4p3)
      dF4(3) = - d4p3 * q**2 / (Manning(i)**2 * dof%S(i)**2 * rh**d7p3)
      dF4(4) = 2.0_rp * q / (Manning(i)**2 * dof%S(i)**2 * rh**d4p3)
      
      write(10,'(9ES16.8)') mesh%CrossSection(i)%coord%x    , &
                            mesh%CrossSection(i)%coord%y    , &
                            dF4(1)                          , &
                            dF4(2)                          , &
                            dF4(3)                          , &
                            dF4(4)
                            
   end do

   close(10)


END SUBROUTINE v_gnuplot_dF4



   
!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write an Gnuplot Output Result File
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Main subroutine to write a result file in gnuplot format (with F4 gradients)
!!
!! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
!! in gnuplot format.  
!! \param[in]    dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
!! \param[in]    filename Name of the file.
SUBROUTINE v_gnuplot_dSf( dof , mesh , filename )

   USE m_common
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   TYPE( unk ), intent(in)  ::  dof
   TYPE( msh ), intent(in)  ::  mesh

   character(len=*), intent(in)  ::  filename

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   integer(ip), dimension(mesh%ncs+4) :: mvector
   
   real(rp)  ::  h , u , v , fr , p, rh, q, mult, w0
   real(rp), dimension(mesh%ncs+4) :: Manning   ! Manning
   real(rp), dimension(4) :: dF4          ! Gradients of F4 force term (raw gradients : dK, dA, dRh, dQ)
   real(rp), dimension(3) :: dSf          ! Gradients of Sf force term
   real(rp)               :: dgh          ! Gradients of Sf force term w.r.t. h, e.g. dg(h) in lyx

   !===================================================================================================================!
   !  Extern functions
   !===================================================================================================================!
   
   real(rp)  :: PerimeterFromH

   !===================================================================================================================!
   !  Begin Subroutine
   !===================================================================================================================!

   open(10,file=filename,status='replace',form='formatted')

   !===================================================================================================================!
   !   Creating Gnuplot file and header
   !===================================================================================================================!

   write(10,*) '# Gnuplot DataFile Version'
   write(10,*) '#             x               y           dSfdK          dSfdA0           dSfdQ' // &
               '           dg(h)'

   !===================================================================================================================!
   !   Writing VTK file datas
   !===================================================================================================================!
   call UpdateMVector(mesh,dof,mvector)
   call calc_K_everywhere(dof, mesh, Manning, mvector)                      ! Update of Manning
   
   do i = 3,mesh%ncs+2
      if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
         q=(0.5_rp*tflux1(i  )*mesh%crosssection(i  )%deltademi + &
            0.5_rp*tflux1(i+1)*mesh%crosssection(i+1)%deltademi)/ &
           mesh%crosssection(i)%delta
      else
         q = dof%Q(i)
      end if
      p = PerimeterFromH(mesh,dof%h(i),i,mvector)
      rh = dof%S(i) / p
      w0 = mesh%crosssection(i)%surfacewidth(1)
      
      mult = q / (Manning(i)**2 * dof%S(i)**2 * rh**d4p3)
      dSf(1) = mult * (-2.0_rp * q / Manning(i))
      dSf(2) = mult * (- q / dof%S(i) * (2.0_rp + d4p3 * (1.0_rp - 2.0 * rh / w0)))
      dSf(3) = mult * 2.0_rp
      
      dF4(2) = - 2.0_rp * q**2 / (Manning(i)**2 * dof%S(i)**3 * rh**d4p3)
      dF4(3) = - d4p3 * q**2 / (Manning(i)**2 * dof%S(i)**2 * rh**d7p3)
      dgh = dF4(2) + dF4(3) - dSf(2)
      
!       
!       write(10,'(9ES16.8)') mesh%CrossSection(i)%coord%x    , &
!                             mesh%CrossSection(i)%coord%y    , &
!                             dF4(1)                          , &
!                             dF4(2)                          , &
!                             dF4(3)                          , &
!                             dF4(4)
      
      write(10,'(9ES16.8)') mesh%CrossSection(i)%coord%x    , &
                            mesh%CrossSection(i)%coord%y    , &
                            dSf(1)                          , &
                            dSf(2)                          , &
                            dSf(3)                          , &
                            dgh
                            
   end do

   close(10)


END SUBROUTINE v_gnuplot_dSf


