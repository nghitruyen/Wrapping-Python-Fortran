!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file bathymetry.f90
!! \brief This file includes the computation/update of bathymetry

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute/update bathymetry
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Compute/update bathymetry and update dof values
!!
!! \details This subroutine compute the bathymetry and update the dof values accordingly
!! \param[in]    mesh Mesh of the problem.
!! \param[in]    dof Unknowns of the model.
SUBROUTINE calc_bathymetry(mesh, dof)

   USE m_mesh
   USE m_model
   USE m_numeric
   USE m_user_data
   USE m_obs
!    USE m_adjoint, only : ite_min
!    USE m_minimization, only : ite_line_search

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   type( msh ), intent(inout)  ::  mesh

   type( unk ), intent(inout)  ::  dof
   

   real(rp) :: HtoS
   real(rp) :: dx, dy, norm
   real(rp) :: z, slopemean, alpha_bathy, offset
   real(rp) :: D, D_ref, h_ref, D_ref_left, D_ref_right, h_ref_left, h_ref_right
   real(rp) :: h_test, h_test_tmp
   integer(ip) :: t_minh_idx
   integer(ip) :: iobs_ref, iobs_ref_left, iobs_ref_right
   integer(ip) :: tmptest
   real(rp), dimension(mesh%ncs+4) :: bathy_tmp

   real(rp) :: wi,wim1,Hi,Him1,yi !temporary variable 
   
   character(len=64) :: filename
   
   real(rp) :: GetWFromH
   
   !======================================================================================================================!
   !  Begin Subroutine
   !======================================================================================================================!

   !===================================================================================================================!
   !  Bathymetry must not be higher than H0
   !===================================================================================================================!

   select case( bathymetry )

   !===================================================================================================================!
   !  Inflow Boundary  :  'discharg'
   !===================================================================================================================!

      case('parametric')
      
        if (c_bathy == 1) then
          bathy_cell(3:mesh%ncs+2) = bathy_points(:)
        end if
      
        !===================================================================================================================!
        ! Compute mean slope
        !===================================================================================================================!
        bathy_step = 1
        slopemean = 0.0_rp
        do i = 3, mesh%ncs+1
            dx = mesh%crosssection(i+1)%coord%x - mesh%crosssection(i)%coord%x
            dy = mesh%crosssection(i+1)%coord%y - mesh%crosssection(i)%coord%y
            slopemean = slopemean + (bathy_cell(i+1) - bathy_cell(i)) / sqrt(dx**2 + dy**2)
        end do
        slopemean = slopemean / real(mesh%ncs-1)
        
        do i = 3, mesh%ncs+1
            if (bathy_cell(i) > mesh%crosssection(i)%height(1) - 1.1 * heps) then
              !<NOADJ
!               print *, "correction bathy!!", i, bathy_cell(i), mesh%crosssection(i)%height(1) - 1.1 * heps
              !>NOADJ
              bathy_cell(i) = mesh%crosssection(i)%height(1) - 1.1 * heps
            end if
        end do
        mesh%crosssection(mesh%ncs+2)%slope = -slopemean
        
        !===================================================================================================================!
        ! Update bathymetry and dof of ghost cells
        !===================================================================================================================!
        bathy_cell(1) = bathy_cell(3)-mesh%CrossSection(4)%deltademi*slopemean*2._rp
        bathy_cell(1) = min(mesh%CrossSection(1)%height(1) - 1.1 * heps, bathy_cell(1))
        bathy_cell(2) = bathy_cell(3)-mesh%CrossSection(4)%deltademi*slopemean
        bathy_cell(2) = min(mesh%CrossSection(1)%height(1) - 1.1 * heps, bathy_cell(2))
        bathy_cell(mesh%ncs+3) = bathy_cell(mesh%ncs+2)+mesh%CrossSection(mesh%ncs+1)%deltademi*slopemean
        bathy_cell(mesh%ncs+3) = min(mesh%CrossSection(mesh%ncs+3)%height(1) - 1.1 * heps, bathy_cell(mesh%ncs+3))
        bathy_cell(mesh%ncs+4) = bathy_cell(mesh%ncs+2)+mesh%CrossSection(mesh%ncs+1)%deltademi*slopemean*2._rp
        bathy_cell(mesh%ncs+4) = min(mesh%CrossSection(mesh%ncs+4)%height(1) - 1.1 * heps, bathy_cell(mesh%ncs+4))
          
        !<NOADJ
          write(filename,'(A)') "internal_bathy_parametric"
          open(12, file=filename, form='formatted')
          do i=1,mesh%ncs+4
             write(12,*) mesh%crosssection(i)%coord%x, bathy_cell(i)
          end do
          close(12)
        !>NOADJ
        
      case('piecewise_constant')
      
         do i = 1, size(bathy_indices) - 1
            do j = bathy_indices(i), bathy_indices(i+1)
               bathy_cell(j) = bathy_points(i)
               if (bathy_cell(j) > mesh%crosssection(j)%height(1) - 1.1 * heps) then
                  bathy_cell(j) = mesh%crosssection(j)%height(1) - 1.1 * heps
               end if
            end do
         end do
         do j = 1, bathy_indices(1)-1
            bathy_cell(j) = bathy_points(1)
            if (bathy_cell(j) > mesh%crosssection(j)%height(1) - 1.1 * heps) then
               bathy_cell(j) = mesh%crosssection(j)%height(1) - 1.1 * heps
            end if
         end do

         ! Interpolate bathy pts after the last bathy control pt using the mean slope
         do j = bathy_indices(size(bathy_indices))+1, mesh%ncs+2
            bathy_cell(j) = bathy_points(size(bathy_indices))
            if (bathy_cell(j) > mesh%crosssection(j)%height(1) - 1.1 * heps) then
               bathy_cell(j) = mesh%crosssection(j)%height(1) - 1.1 * heps
            end if
         end do
        
      case('piecewise_linear')
      
         do i = 1, size(bathy_indices) - 1
            dx = mesh%crosssection(bathy_indices(i+1))%coord%x - &
                mesh%crosssection(bathy_indices(i))%coord%x
            norm = sqrt(dx**2)
            do j = bathy_indices(i), bathy_indices(i+1)
               dx = mesh%crosssection(j)%coord%x - mesh%crosssection(bathy_indices(i))%coord%x
               alpha_bathy = sqrt(dx**2) / norm
               bathy_cell(j) = bathy_points(i) + alpha_bathy * (bathy_points(i+1) - bathy_points(i))
               if (bathy_cell(j) > mesh%crosssection(j)%height(1) - 1.1 * heps) then
                  bathy_cell(j) = mesh%crosssection(j)%height(1) - 1.1 * heps
               end if
            end do
         end do
            
         ! Compute mean slope
         slopemean = 0.0_rp
         do i = bathy_indices(1), bathy_indices(size(bathy_indices)) - 1
            dx = mesh%crosssection(i+1)%coord%x - mesh%crosssection(i)%coord%x
            slopemean = slopemean + (bathy_cell(i+1) - bathy_cell(i)) / sqrt(dx**2)
         end do
         slopemean = slopemean / (bathy_indices(size(bathy_indices)) - bathy_indices(1))
         
         ! Interpolate bathy pts before the first bathy control pt using the mean slope
         do j = 3, bathy_indices(1)
            dx = mesh%crosssection(j)%coord%x - mesh%crosssection(bathy_indices(1))%coord%x
            bathy_cell(j) = bathy_points(1) - slopemean * sqrt(dx**2)
            if (bathy_cell(j) > mesh%crosssection(j)%height(1) - 1.1 * heps) then
               bathy_cell(j) = mesh%crosssection(j)%height(1) - 1.1 * heps
            end if
         end do
         ! 1st ghost cells
         bathy_cell(1) = bathy_cell(3)-(mesh%CrossSection(3)%deltademi+mesh%CrossSection(2)%deltademi)*slopemean
         bathy_cell(2) = bathy_cell(3)-mesh%CrossSection(3)%deltademi*slopemean

         ! Interpolate bathy pts after the last bathy control pt using the mean slope
         do j = bathy_indices(size(bathy_indices))+1, mesh%ncs+2
            dx = mesh%crosssection(j)%coord%x - mesh%crosssection(bathy_indices(size(bathy_indices)))%coord%x
            bathy_cell(j) = bathy_points(size(bathy_points)) + slopemean * sqrt(dx**2)
            if (bathy_cell(j) > mesh%crosssection(j)%height(1) - 1.1 * heps) then
               bathy_cell(j) = mesh%crosssection(j)%height(1) - 1.1 * heps
            end if
         end do
         ! last ghost cells
         bathy_cell(mesh%ncs+3) = bathy_cell(mesh%ncs+2)+mesh%CrossSection(mesh%ncs+3)%deltademi*slopemean
         bathy_cell(mesh%ncs+4) = bathy_cell(mesh%ncs+2)+&
              (mesh%CrossSection(mesh%ncs+3)%deltademi+mesh%CrossSection(mesh%ncs+4)%deltademi)*slopemean
         
        !<NOADJ
          open(12, file='bathy_linear.txt', form='formatted')
          do i=1,mesh%ncs+4
             write(12,*) bathy_cell(i)
          end do
          close(12)
        !>NOADJ
        
      case('constant_slope')
      
        !===================================================================================================================!
        ! Compute mean slope
         !===================================================================================================================!
         bathy_first = 3
         bathy_last = 3
         bathy_step = 1
        dx = mesh%crosssection(mesh%ncs+2)%coord%x - mesh%crosssection(3)%coord%x
        dy = mesh%crosssection(mesh%ncs+2)%coord%y - mesh%crosssection(3)%coord%y
        slopemean = (bathy_cell(mesh%ncs+2) - bathy_cell(3)) / sqrt(dx**2 + dy**2)
        
        do j = 4, mesh%ncs+1
          dx = mesh%crosssection(j)%coord%x - mesh%crosssection(3)%coord%x
          dy = mesh%crosssection(j)%coord%y - mesh%crosssection(3)%coord%y
          bathy_cell(j) = bathy_cell(3) + slopemean * sqrt(dx**2 + dy**2)
        end do
        bathy_cell(1) = bathy_cell(3)-mesh%CrossSection(4)%deltademi*slopemean*2._rp
        bathy_cell(2) = bathy_cell(3)-mesh%CrossSection(4)%deltademi*slopemean
        bathy_cell(mesh%ncs+3) = bathy_cell(mesh%ncs+2)+mesh%CrossSection(mesh%ncs+1)%deltademi*slopemean
        bathy_cell(mesh%ncs+4) = bathy_cell(mesh%ncs+2)+mesh%CrossSection(mesh%ncs+1)%deltademi*slopemean*2._rp
        
      case('offset')
         
!          offset = bathy_cell(bathy_first) - mesh%crosssection(bathy_first)%elevation
         offset = bathy_cell(bathy_first+bathy_step) - mesh%crosssection(bathy_first+bathy_step)%elevation
         do j = 1, bathy_first
            z = bathy_cell(j)
            if (j == bathy_first+bathy_step) cycle
            bathy_cell(j) = mesh%crosssection(j)%elevation + offset
            if (bathy_cell(j) > mesh%crosssection(j)%height(1)) then
               bathy_cell(j) = z
            end if
         end do
         offset = bathy_cell(bathy_first+bathy_step) - mesh%crosssection(bathy_first+bathy_step)%elevation
!          do j = bathy_first+1, mesh%ncs+4
         do j = 1, mesh%ncs+4
            z = bathy_cell(j)
            if (j == bathy_first+bathy_step) cycle
            bathy_cell(j) = mesh%crosssection(j)%elevation + offset
            if (bathy_cell(j) > mesh%crosssection(j)%height(1)) then
               bathy_cell(j) = z
            end if
         end do
      
         
!          offset = bathy_cell(bathy_first) - mesh%crosssection(bathy_first)%elevation
!          do j = 1, bathy_last
!             z = bathy_cell(j)
!             if (j == bathy_first) cycle
!             bathy_cell(j) = mesh%crosssection(j)%elevation + offset
!             if (bathy_cell(j) > mesh%crosssection(j)%height(1)) then
!                bathy_cell(j) = z
!             end if
!          end do
!          offset = bathy_cell(bathy_last) - mesh%crosssection(bathy_last)%elevation
!          do j = bathy_last+1, mesh%ncs+4
!             z = bathy_cell(j)
!             if (j == bathy_last) cycle
!             bathy_cell(j) = mesh%crosssection(j)%elevation + offset
!             if (bathy_cell(j) > mesh%crosssection(j)%height(1)) then
!                bathy_cell(j) = z
!             end if
!          end do
      

      !===================================================================================================================!
      ! Propagating bathymetry with Low Froude/constant K assumptions
      !===================================================================================================================!
      ! /!\ Hyp pour ce cas : une station toutes les cs, bathy_first = 1e ref, control tous les bathy_first + k*bathy_step, propagation en amont des pts de ref
      case('low_froude')
         !print*, 'propagate bathy with low froude model'
         ! Find suitable water surface profile (min, mean ...? => for now min)
         h_test = hugem
         do i = 1,SIZE(station(1)%h_bathy) ! time
            do iobs = 1, mesh%ncs             ! space
               h_test_tmp = h_test_tmp + station(iobs)%h_bathy(i)
            end do
               h_test_tmp = h_test_tmp / mesh%ncs 
            if ( h_test_tmp < h_test ) then
               h_test = h_test_tmp
               t_minh_idx = i
            end if
         end do
         !print*, 'idx t_obs', t_minh_idx
         
         ! "upstream" bathy_first
         iobs_ref = bathy_first - 2
         ! Coeffs of observed quantities: D = W*sqrt(slope)
         D_ref = station(iobs_ref)%w(t_minh_idx)*SQRT(station(iobs_ref)%slope(t_minh_idx))
         ! height corresponding to bathy infered
         h_ref = station(iobs_ref)%h_bathy(t_minh_idx) - bathy_cell(bathy_first)
         do j = 3, bathy_first-1
            ! Find corresponding stations
            iobs = j - 2
            D = station(iobs)%w(t_minh_idx)*SQRT(station(iobs)%slope(t_minh_idx))
            ! Computes bathy
            bathy_cell(j) = station(iobs)%h_bathy(t_minh_idx) - h_ref*D_ref**(0.6_rp)*D**(-0.6_rp) ! zb(x) = H(x) - href*D_ref^(3/5)*D(x)^(-3/5)
            ! Check if bathy does not match the geometry
            if (bathy_cell(j) > mesh%crosssection(j)%height(1)) then
               print*, 'upstream, zb>h0' !NOADJ
               bathy_cell(j) = mesh%crosssection(j)%height(1)-0.01
            end if
         end do

         ! between bathy_first and bathy last
         if ( bathy_first /= bathy_last ) then
            do i = bathy_first+bathy_step, bathy_last, bathy_step
               iobs_ref = i-2
               D_ref = station(iobs_ref)%w(t_minh_idx)*SQRT(station(iobs_ref)%slope(t_minh_idx))
               h_ref = station(iobs_ref)%h_bathy(t_minh_idx) - bathy_cell(i)
               do j = i-bathy_step+1, i-1
                  iobs = j-2
                  z = bathy_cell(j)
                  D = station(iobs)%w(t_minh_idx)*SQRT(station(iobs)%slope(t_minh_idx))
                  bathy_cell(j) = station(iobs)%h_bathy(t_minh_idx) - h_ref*D_ref**(0.6_rp)*D**(-0.6_rp)
                  if (bathy_cell(j) > mesh%crosssection(j)%height(1)) then
                     print*, 'btw ref pts, zb>h0'   !NOADJ
                     bathy_cell(j) = mesh%crosssection(j)%height(1)-0.01
                  end if
               end do
            end do
         end if

         ! "downstream" last_bathy
         iobs_ref = bathy_last-2
         D_ref = station(iobs_ref)%w(t_minh_idx)*SQRT(station(iobs_ref)%slope(t_minh_idx))
         h_ref = station(iobs_ref)%h_bathy(t_minh_idx) - bathy_cell(bathy_last)
         do j = bathy_last+1, mesh%ncs+2
            iobs = j-2
            D = station(iobs)%w(t_minh_idx)*SQRT(station(iobs)%slope(t_minh_idx))
            bathy_cell(j) = station(iobs)%h_bathy(t_minh_idx) - h_ref*D_ref**(0.6_rp)*D**(-0.6_rp)
            if (bathy_cell(j) > mesh%crosssection(j)%height(1)) then
               print*, 'downstream, zb>h0'    !NOADJ
               bathy_cell(j) = mesh%crosssection(j)%height(1)-0.01
            end if
         end do


         ! Ghost cells E
         slopemean = 0.0_rp
         do i = 3, mesh%ncs+1
            slopemean = slopemean + (bathy_cell(i+1) - bathy_cell(i)) / mesh%Crosssection(i+1)%deltademi
         end do
         slopemean = slopemean / real(mesh%ncs-1)
         bathy_cell(1) = bathy_cell(3)-(mesh%CrossSection(3)%deltademi+mesh%CrossSection(2)%deltademi)*slopemean
         bathy_cell(2) = bathy_cell(3)-mesh%CrossSection(3)%deltademi*slopemean
         ! Ghost cells W
         bathy_cell(mesh%ncs+3) = bathy_cell(mesh%ncs+2)+mesh%CrossSection(mesh%ncs+3)%deltademi*slopemean
         bathy_cell(mesh%ncs+4) = bathy_cell(mesh%ncs+2)+&
              (mesh%CrossSection(mesh%ncs+3)%deltademi+mesh%CrossSection(mesh%ncs+4)%deltademi)*slopemean
         !<NOADJ
         ! TMP, to see all the bathy cells (ghost included)
          open(12, file='bathy_LF.txt', form='formatted')
          do i=1,mesh%ncs+4
             write(12,*) bathy_cell(i)
          end do
          close(12)
         !>NOADJ

          
      case default
      
         write (*,'(A31)') 'W bathymetry model not defined' !NOADJ

      end select
  
! DEPRECATED
!    !===================================================================================================================!
!    !  Recomputation of sum of area surface
!    !===================================================================================================================!
!    do i = 1,mesh%ncs+4
!       k=mesh%CrossSection(i)%nc
! 
!       !TODO : Verifier coherence des donneess
!       !s_0=(H_0-z_b)*w_0
!       mesh%CrossSection(i)%surfaceArea(1)      =(mesh%crosssection(i)%height(1)-bathy_cell(i))* & !(H_0-z_b)*
!                                                 mesh%crosssection(i)%surfacewidth(1)              !w_0
!       mesh%CrossSection(i)%surfaceAreaSum(1)   =mesh%CrossSection(i)%surfaceArea(1)               !S_0=s_0
! 
!       
!       do j=2,k
!          !S_m=0.5*(w_{m-1}+w_{m})*(H_{m}-H_{m-1})      
!          mesh%CrossSection(i)%surfaceArea(j)=demi* &                                            !S_m=0.5*
!               (mesh%crosssection(i)%surfacewidth(j-1)+mesh%crosssection(i)%surfacewidth(j))*&   !(w_{m-1}+w_{m})*
!               (mesh%crosssection(i)%height(j)-mesh%crosssection(i)%height(j-1))                 !(H_{m}-H_{m-1})
! 
!          !St_m=St_{m-1}+S_m
!          mesh%CrossSection(i)%surfaceAreaSum(j)=mesh%CrossSection(i)%surfaceAreaSum(j-1) + mesh%CrossSection(i)%surfaceArea(j)!St_m=St_{m-1}+S_m
! 
!       end do
!    end do
! 
!    !===================================================================================================================!
!    !  Recomputation of perimeter and alpha
!    !===================================================================================================================!
!    
!    do i = 1,mesh%ncs+4
!       k=mesh%CrossSection(i)%nc
!       
!       !Pe0=w_0+2*(H_0-z_b)
!       mesh%CrossSection(i)%perimeter(1)= mesh%crosssection(i)%surfacewidth(1)+ &                               !Pe0=w_0+
!                                          two*(mesh%crosssection(i)%height(1)-bathy_cell(i))   !2*(H_0-z_b)
!       mesh%CrossSection(i)%perimeterp1(1)= (mesh%crosssection(i)%height(1)-bathy_cell(i))
!       mesh%CrossSection(i)%perimeterp2(1)= (mesh%crosssection(i)%height(1)-bathy_cell(i))
! 
!       mesh%CrossSection(i)%perimeterSum(1)=mesh%CrossSection(i)%perimeter(1) !Sum Pe0=Pe0
! 
!       do j=2,k
!          !Pe1_i=((0.5*W_i-(0.5*W_{i-1}-y_i))^2+(H_i-H_{i-1})^2)^(1/2)
!          !Pe2_i=((0.5*W_i-(0.5*W_{i-1}+y_i))^2+(H_i-H_{i-1})^2)^(1/2)
!          !Pe_i=Pe1_i+Pe2_i
!          wi=mesh%crosssection(i)%surfacewidth(j)
!          wim1=mesh%crosssection(i)%surfacewidth(j-1)
!          Hi=mesh%crosssection(i)%height(j)
!          Him1=mesh%crosssection(i)%height(j-1)
!          yi=mesh%crosssection(i)%y(j-1)-mesh%crosssection(i)%y(j)
! 
!          mesh%CrossSection(i)%perimeterp1(j)=sqrt((demi*wi-(demi*wim1-yi))**2+(Hi-Him1)**2) !((0.5*W_i-(0.5*W_{i-1}-y_i))^2+(H_i-H_{i-1})^2)^(1/2)
!          mesh%CrossSection(i)%perimeterp2(j)=sqrt((demi*wi-(demi*wim1+yi))**2+(Hi-Him1)**2) !((0.5*W_i-(0.5*W_{i-1}+y_i))^2+(H_i-H_{i-1})^2)^(1/2)
! 
!          mesh%CrossSection(i)%perimeter(j)=mesh%CrossSection(i)%perimeterp1(j)+mesh%CrossSection(i)%perimeterp2(j) !p1+p2
! 
!          mesh%CrossSection(i)%perimeterSum(j)=mesh%CrossSection(i)%perimeterSum(j-1)+mesh%CrossSection(i)%perimeter(j)
! 
!       end do
!    end do
! 
!    !===================================================================================================================!
!    !  Recomputation of w_derivative for pressure term computation
!    !===================================================================================================================!
!    
!    do i = 3,mesh%ncs+2
!       k=mesh%CrossSection(i)%nc
!       !do j=1,k
!       do j=1,k-1
!          mesh%CrossSection(i)%zint  (j) = mesh%crosssection(i)%height(j)-bathy_cell(i)
!          mesh%CrossSection(i)%wl    (j) = GetWFromH(mesh,mesh%crosssection(i)%height(j)-bathy_cell(i),i-1)
!          mesh%CrossSection(i)%wr    (j) = GetWFromH(mesh,mesh%crosssection(i)%height(j)-bathy_cell(i),i+1)
!       end do
!    end do

   
!   open(99, file="bathy_tmp.txt", status='replace')
!   do k = 1, size(bathy_cell)
!     write(99, *) bathy_cell(k)
!   end do
!   close(99)
!   print *, "BATHY_TMP SAVED"
!   read(*,*)
!             


END SUBROUTINE calc_bathymetry




!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute mean slope
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Compute mean slope
!!
!! \details This subroutine compute the bathymetry mean slope
!! \param[in]    mesh Mesh of the problem.

SUBROUTINE calc_bathymetry_mean_slope(mesh)
  USE m_mesh
   USE m_model
   USE m_numeric
   USE m_user_data
   USE m_obs

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in   )  ::  mesh

   do i = 3, mesh%ncs+1
      bathy_slopemean = bathy_slopemean + (bathy_cell(i+1) - bathy_cell(i)) / mesh%Crosssection(i+1)%deltademi
   end do
   bathy_slopemean = bathy_slopemean / real(mesh%ncs-1)
  
END SUBROUTINE calc_bathymetry_mean_slope
