!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file backwater.f90
!! \brief This file includes the computation of backwater curve

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute backwater curve
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Compute backwater curve
!!
!! \details This subroutine compute the backwater curve and update the dof values accordingly
!! \param[in]    mesh Mesh of the problem.
!! \param[in]    dof Unknowns of the model.
SUBROUTINE solve_backwater(mesh, dof)

   USE m_mesh
   USE m_model
   USE m_numeric
   USE m_user_data

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type( msh ), intent(in   )  ::  mesh
   type( unk ), intent(inout)  ::  dof

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!

      real(rp) :: q         ! Discharge
      real(rp) :: z         ! Water elevation
      real(rp) :: w         ! Water surface width 
      real(rp) :: perimeter ! Wet Perimeter 
      real(rp) :: rh        ! Hydraulic radius
      real(rp) :: Manning   ! Manning
      real(rp) :: debitance ! Debitance
      real(rp) :: fr2       ! Froude square
      real(rp) :: dx        ! Spatial step size
      real(rp) :: So        ! Bathy slope
      real(rp) :: Sf        ! Friction slope
      
      real(rp) :: f         ! Function value for Newton iterations
      real(rp) :: df        ! Function gradient for Newton iterations
      real(rp) :: dh        ! Delta depth
      real(rp)  :: dPdZ     ! Gradient of wetted perimeter wrt elevation
      real(rp)  :: dK_dh    ! Gradient of Strickler coeff wrt water height
      
      
      integer(ip), dimension(mesh%ncs+4) :: mvector           ! Vector m
      real(rp)  ::  hc1
      integer(ip) :: iloc
!======================================================================================================================!
!  External Functions
!======================================================================================================================!
      real(rp)  :: PerimeterFromH
      real(rp)  :: GetWFromH
      real(rp)  :: HtoS
      real(rp)  :: dPdZFromH
      
      integer(ip) :: nit
   
!======================================================================================================================!
!  Begin Subroutine
!======================================================================================================================!


   !===================================================================================================================!
   !  Compute downstream dof
   !===================================================================================================================!
   call calc_boundary_state(mesh, dof)
   i = mesh%ncs+2
   dof%q(i) = dof%q(1)
   dof%q(i+1) = dof%q(1)
   
   if (BC_E == 'normal_depth' .or. BC_E == "neumann") then
   
      !================================================================================================================!
      ! Newton to compute hn (normal depth)
      !================================================================================================================!
      
      dof%h(i) = 1.0
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      dh = 1.0
      dx = mesh%crosssection(i)%deltademi
      So = (bathy_cell(i) - bathy_cell(i+1)) / dx
      nit = 0
      do while (abs(dh) > 1e-3 .and. nit < 1000)
        call UpdateMVectorElement(mesh, dof, i, mvector)
        call calc_K_at_cs(dof, Manning, i)
        perimeter = PerimeterFromH(mesh, dof%h(i), i, mvector)
        rh = dof%s(i) / perimeter
        w = GetWFromH(mesh, dof%h(i), i)
        dPdZ = min(100.0_rp, dPdZFromH(mesh,dof%h(i),i,mvector))
        call calc_dK_dh(mesh, dof, dK_dh, i)
        df = rh**d2p3*(dK_dh*dof%s(i)+Manning*(d5p3*w-d2p3*rh*dPdZ))*sqrt(So)
        f = Manning*dof%s(i)*rh**d2p3*sqrt(So) - dof%q(i)
        dh = - 0.5 * f / df
        dof%h(i) = max(1e-3, dof%h(i) - f / df)
        dof%s(i) = HtoS(mesh, i, dof%h(i))
        nit = nit + 1
      end do
      !<NOADJ
      if (nit >= 1000) then
         print *, "NORMAL_DEPTH:UNCONVERGED"
         print*, dof%h(i), Manning, dof%s(i), rh, dof%q(i)
        dof%h(i) = 1.0
        dof%s(i) = HtoS(mesh, i, dof%h(i))
        dh = 1.0
        dx = mesh%crosssection(i)%deltademi
        So = (bathy_cell(i) - bathy_cell(i+1)) / dx
        do nit = 1, 100
           call UpdateMVectorElement(mesh, dof, i, mvector)
           call calc_K_at_cs(dof, Manning, i)                   
          perimeter = PerimeterFromH(mesh, dof%h(i), i, mvector)
          rh = dof%s(i) / perimeter
          w = GetWFromH(mesh, dof%h(i), i)
          dPdZ = min(100.0_rp, dPdZFromH(mesh,dof%h(i),i,mvector))
          call calc_dK_dh(mesh, dof, dK_dh, i)
          df = rh**d2p3*(dK_dh*dof%s(i)+Manning*(d5p3*w-d2p3*rh*dPdZ))*sqrt(So)
          f = Manning*dof%s(i)*rh**d2p3*sqrt(So) - dof%q(i)
          dh = - 0.5 * f / df
          dof%h(i) = max(1e-3, dof%h(i) - f / df)
          dof%s(i) = HtoS(mesh, i, dof%h(i))
          !print *, nit, dh, dof%h(i)
        end do
      end if
      !>NOADJ
   
   else if (BC_E == 'ratcurve') then
   
      !================================================================================================================!
      ! Compute h from rating curve
      !================================================================================================================!
      
      if (bc%typerat=='file') then
          dof%h(i) = linear_interp(bc%rat%q, bc%rat%h, dof%q(i)) - bathy_cell(i)
      else if (alpha_ratcurve > 0.0) then
          dof%h(i) = alpha_ratcurve * abs(dof%q(i))**beta_ratcurve
      end if
      
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      call UpdateMVectorElement(mesh, dof, i, mvector)

   else
      !================================================================================================================!
      ! Use h0_user in the m_user_data.f90 as h_downstream
      !================================================================================================================!

      dof%h(i) = max( 0.0_rp , h0_user( mesh%CrossSection(i)%coord%x , mesh%CrossSection(i)%coord%y ) )
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      call UpdateMVectorElement(mesh, dof, i, mvector)
      
      
   end if
    
   !===================================================================================================================!
   !  Compute dof from backwater curve
   !===================================================================================================================!   
     !================================================================================================================!
     !  Varied discharge
     !================================================================================================================!
    if ( lat_inflow == '1' ) then
	iloc = 0
	do i = 2, mesh%ncs+1, 1
	  if ( ANY( bc%hyd_lat%loc == i ) ) then
	      iloc=iloc+1
	      !print*, i,  dof%q(i), bc%hyd_lat%q(iloc,1)
	      dof%q(i) = dof%q(i-1) + bc%hyd_lat%q(iloc,1)
	      !print*,bc%hyd_lat%q(iloc,1),bc%hyd_lat%q(iloc,2),bc%hyd_lat%q(iloc,3),bc%hyd_lat%q(iloc,4)
	  else 
	      dof%q(i) = dof%q(i-1)
	  endif
	enddo

    else   
      do i = mesh%ncs+1, 1, -1   
      !================================================================================================================!
      !  Uniform discharge
      !================================================================================================================!
      dof%q(i) = dof%q(i+1)
   end do
   endif
   
! ! !    ! critical height
! ! !    allocate(hc(mesh%ncs+3))
! ! !    call computes_critical_depth(mesh, dof)

   do i = mesh%ncs+1, 1, -1
      
      !================================================================================================================!
      !  Backwater curve
      !================================================================================================================!

      perimeter = PerimeterFromH(mesh, dof%h(i+1), i+1, mvector)
      w = GetWFromH(mesh, dof%h(i+1), i+1)
      rh = dof%s(i+1) / perimeter
      call calc_K_at_cs(dof, Manning, i+1)
      debitance = Manning * dof%s(i+1) * (rh**(d2p3))
      Sf = dof%q(i+1)**2 / debitance**2
      dx = mesh%crosssection(i+1)%deltademi
      So = (bathy_cell(i) - bathy_cell(i+1)) / dx
      fr2 = dof%q(i+1)**2 * w / (g * dof%s(i+1)**3)
      if (backwater_hmin > 0.0) then
         dof%h(i) = max(backwater_hmin, dof%h(i+1) - dx * (So - Sf) / (1.0_rp - fr2))
      else
         call bisect_critical_depth(mesh, dof, i, dof%q(i), hc1)
         dof%h(i) = max(backwater_alpha*hc1, dof%h(i+1) - dx * (So - Sf) / (1.0_rp - fr2))
      end if
      
      
      if (isnan(dof%h(i))) print *, "backwater::NaN"        !NOADJ
      !================================================================================================================!
      ! Update S and mvector
      !================================================================================================================!
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      call UpdateMVectorElement(mesh, dof, i, mvector)
        
   end do
   
   ! Ghost cell downstream
   do i=mesh%ncs+3,mesh%ncs+4
      perimeter = PerimeterFromH(mesh, dof%h(i-1), i-1, mvector)
      w = GetWFromH(mesh, dof%h(i-1), i-1)
      rh = dof%s(i-1) / perimeter
      call calc_K_at_cs(dof, Manning, i-1)
      debitance = Manning * dof%s(i-1) * (rh**(d2p3))
      Sf = dof%q(i-1)**2 / debitance**2
      dx = mesh%crosssection(i-1)%deltademi
      So = (bathy_cell(i-1) - bathy_cell(i)) / dx
      fr2 = dof%q(i-1)**2 * w / (g * dof%s(i-1)**3)
      dof%h(i) = dof%h(i-1) + dx * (So - Sf) / (1.0_rp - fr2)
      dof%s(i) = HtoS(mesh, i, dof%h(i))
      call UpdateMVectorElement(mesh, dof, i, mvector)
   end do


END SUBROUTINE solve_backwater
! ! ! 
! ! ! 
! ! ! subroutine bisect_critical_depth(mesh, dof, im, q, hc1)
! ! !   use m_mesh
! ! !   use m_model
! ! !   use m_numeric
! ! !   
! ! !   implicit none
! ! ! 
! ! ! !======================================================================================================================!
! ! ! !  Interface Variables
! ! ! !======================================================================================================================!
! ! ! 
! ! !    type( msh ), intent(in)  ::  mesh
! ! !    type( unk ), intent(in)  ::  dof
! ! !    integer(ip), intent(in)  ::  im
! ! !    real(rp), intent(in)  ::  q
! ! !    real(rp), intent(out)  ::  hc1
! ! ! 
! ! ! !======================================================================================================================!
! ! ! !  Local Variables
! ! ! !======================================================================================================================!
! ! !       real(rp) :: w         ! Water surface width 
! ! !       real(rp) :: s         ! Wetted area
! ! !       real(rp) :: fr2       ! Wetted area
! ! !       real(rp) :: hmin      !
! ! !       real(rp) :: hmax      !
! ! !       integer(ip) :: m_max
! ! ! 
! ! ! !======================================================================================================================!
! ! ! !  External Functions
! ! ! !======================================================================================================================!
! ! !       real(rp)  :: GetWFromH
! ! !       real(rp)  :: HtoS
! ! !       
! ! !   m_max=size(mesh%crosssection(im)%height)
! ! !   hmin = 0.1
! ! !   hmax = mesh%crosssection(i)%height(m_max) - bathy_cell(i)
! ! !   
! ! !   do while (hmax - hmin > 1e-3)
! ! !   
! ! !     hc1 = 0.5 * (hmin + hmax)
! ! !     w = GetWFromH(mesh, hc1, i)
! ! !     s = HtoS(mesh, i, hc1)
! ! !     fr2 = dof%q(i)**2 * w / (g * s**3)
! ! !     if (1.0 - fr2 > 0._rp) then
! ! !       hmax = hc1
! ! !     else
! ! !       hmin = hc1
! ! !     end if
! ! !   end do
! ! !   
! ! ! end subroutine

