!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file explicit_low_froude_b1.f90
!! \brief This file includes the computation with explicit low froude method with MUSCL and without slope limiter.
!! An unique subroutine :
!! explicit_low_froude_b1

!> Subroutine of the computation explicit low froude method with MUSCL and without slope limiter. 
!!
!! \details Algorithm used:
!!
!!     Update boundaries conditions
!!     Update mvector
!!
!!     do i = 2, n:
!!       Computation of MUSCL variable ( h and u)
!!       Computation of F (low froude)
!!       s(i) = max(0,s-(dt/dxi) (F1(i+1)-F1(i)))
!!       Update mvector(i)
!!       Update H(i) (from S(i))
!!     end do
!!     
!!     do i = 2, n:
!!       Computation of Sg(i) and Sf(i)
!!       Computation of q(i)
!!     end do
!!
!! \param[in]  dof Unknowns of the model.
!! \param[in]    mesh Mesh of the model.
SUBROUTINE explicit_low_froude_b1( dof , mesh )

   USE m_common
   USE m_mesh
   USE m_time_screen          !NOADJ
   USE m_model
   USE m_linear_solver        !NOADJ
   USE m_user_data
   USE m_numeric
   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   TYPE( msh ), intent(in   )  ::  mesh
   TYPE( unk ), intent(inout)  ::  dof

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!


   real(rp) :: wjm1,wj,wjp1
   real(rp) :: vjm1,vj,vjp1
   real(rp) :: hjm1,hj,hjp1
   real(rp) :: sjm1,sj,sjp1

   real(rp), dimension( mesh%ncs+4)  ::  h,v,s                    ! Temporal depths

   real(rp) :: gamma_expl,alpha_expl
   
   real(rp) :: Fjm1d2 , Fjp1d2,Phijp1d2, Phijm1d2,Rj

   real(rp) :: SourceTermPente,SourceTermFriction

   real(rp) ::A ,q,dz,HtoS,s_new,v_new,F2

   real(rp) :: manning, hydraulicradiusie



   real(rp)  :: hm2,hm1,hi,hp1,hp2   !Height    at the point i-2,i-1,i,i+1,i+2

   real(rp)  :: qm2,qm1,qi,qp1,qp2   !Flow      at the point i-2,i-1,i,i+1,i+2

   real(rp)  :: sm2,sm1,si,sp1,sp2   !Surface   at the point i-2,i-1,i,i+1,i+2

   real(rp)  :: um2,um1,ui,up1,up2   !Velocity  at the point i-2,i-1,i,i+1,i+2

   real(rp)  :: zm2,zm1,zi,zp1,zp2   !Elevation at the point i-2,i-1,i,i+1,i+2

   real(rp) :: xm1demiMxm1,xm1demiMxm3demi,xm1demiMx,xp1demiMxm1demi                   ! Deltax value  
   
   real(rp) ::deltaxm1demi, deltax,deltaxm1                                            !  Deltax and Deltax1demi

   real(rp) :: deltahath,deltahathm1,sigmah,sigmahm1,deltah,deltahm1,hm1demim,hm1demip ! Delta and sigma h for h reconstruction

   real(rp) :: deltahatu,deltahatum1,sigmau,sigmaum1,deltau,deltaum1,um1demim,um1demip ! Delta and sigma u for u reconstruction

   real(rp) :: deltahats,deltahatsm1,sigmas,sigmasm1,deltas,deltasm1,sm1demim,sm1demip ! Delta and sigma u for u reconstruction

   real(rp)  :: sl,sr ! Surface  to the cell left and right

   real(rp)  :: ul,ur ! Velocity to the cell left and right

   real(rp)  :: ql,qr ! Flow     to the cell left and right

   real(rp)  :: hl,hr ! Height   to the cell left and right

   real(rp), dimension(mesh%ncs+4 )  ::   tphi

   real(rp) :: L

   real(rp) :: HtoSInterface                          ! Transformation of H to S to the interface between two cell

   real(rp) :: alphab                                 ! Alpha (For MUSCL Reconstruction)

   real(rp) :: zm1demi                                ! Value of z to the interface between cell i-1 and i

   real(rp) :: deltaxm,deltaxp,sumDeltaX              ! DeltaX at cell i-1, DeltaX at cell i+1


   integer(ip), dimension(mesh%ncs+4) :: mVector              ! Pressure for fluxes computing
   real(rp) :: GetWFromH

   !======================================================================================================================!
   !  Begin Subroutine
   !======================================================================================================================!
   !write(*,*) 'expli'
   call calc_boundary_state( mesh,dof)
   call SurfaceToHeight(mesh,dof)
   call UpdateMVector(mesh,dof,mvector)         ! Update mvector   

   h(:)  =  dof%h(:)
   do ie=1,mesh%ncs+4
      v(ie)  =  dof%q(ie)/dof%s(ie)
   end do 
   s(:)  =  dof%s(:)

   h(1)=h(3)
   h(2)=h(3)
   v(1)=dof%q(2)/dof%s(3)
   v(2)=dof%q(2)/dof%s(3)


   v(mesh%ncs+3)=v(mesh%ncs+2)
   v(mesh%ncs+4)=v(mesh%ncs+2)


   ! Original 
   !gamma_expl=0.5_rp
   !alpha_expl=1._rp 
   !L=50._rp 


      
   gamma_expl=1.0_rp
   alpha_expl=2.0_rp 
   !L=50._rp 


   !For Garonne :   
   !gamma_expl=1._rp
   !alpha_expl=2._rp 
   !L=5._rp 

   do ie=3,mesh%ncs+3

     !===================================
      !  variable definition  
      !===================================

      !surfaceWidth(ie)=getWFromH(mesh,dof%h(ie),ie)
      zm2 =bathy_cell(ie-2)      
      zm1 =bathy_cell(ie-1)
      zi  =bathy_cell(ie  )
      zp1 =bathy_cell(ie+1)

      hm2 =dof%h(ie-2)
      hm1 =dof%h(ie-1)
      hi   =dof%h(ie  )
      hp1 =dof%h(ie+1)

      hm2=hm2+zm2
      hm1=hm1+zm1
      hi  =hi  +zi
      hp1=hp1+zp1

      qm2 =dof%q(ie-2)
      qm1 =dof%q(ie-1)
      qi   =dof%q(ie  )
      qp1 =dof%q(ie+1)

      sm2 =dof%s(ie-2)      
      sm1 =dof%s(ie-1)
      si  =dof%s(ie  )
      sp1 =dof%s(ie+1)

      deltaxm1     = mesh%crosssection(ie-1)%delta
      deltax       = mesh%crosssection(ie)%delta
      deltaxm1demi = mesh%crosssection(ie)%deltademi
      sumDeltaX    = deltax+deltaxm1

      um2 =div_by_except_0(qm2,sm2)
      um1 =div_by_except_0(qm1,sm1)
      ui  =div_by_except_0(qi  ,si )
      up1 =div_by_except_0(qp1,sp1)



      !===================================
      !  Interface value + MUSCL (see doc)
      !===================================
      alphab=one
      xm1demiMxm1=demi*deltaxm1demi
      xm1demiMxm3demi=deltaxm1

      xm1demiMx=-xm1demiMxm1
      xp1demiMxm1demi=deltax

      
      !  deltah computing
      deltah  =demi*(hp1-hm1) 
      deltahm1=demi*(hi-hm2) 

      deltau  =demi*(up1-um1)  
      deltaum1=demi*(ui-um2) 
    


      !  hm1demim & hm1demip
      deltaxm=(xm1demiMxm1)/(xm1demiMxm3demi)
      deltaxp=(xm1demiMx  )/(xp1demiMxm1demi)

      hm1demim=hm1 + deltahm1*deltaxm
      hm1demip=hi   + deltah  *deltaxp

      um1demim=um1 + deltaum1*deltaxm
      um1demip=ui   + deltau  *deltaxp



      !===================================
      !  transformation (h,u) to (S,Q) 
      !===================================


      !Sl=HtoSInterface(mesh,ie-1,ie,hm1demim)
      !Sr=HtoSInterface(mesh,ie-1,ie,hm1demip)


      zm1demi=demi*(zm1+zi)
      Sl=demi*(HtoS(mesh,ie-1,hm1demim-zm1demi)+HtoS(mesh,ie ,hm1demim-zm1demi))
      Sr=demi*(HtoS(mesh,ie-1,hm1demip-zm1demi)+HtoS(mesh,ie ,hm1demip-zm1demi))         

      !sl=sm1demim
      !sr=sm1demip
            

      !zm1demi=demi*(zm1+zi)
      !hm1demim=max(zero,hm1demim+zm1demi) 
      !hm1demip=max(zero,hm1demip+zm1demi)

         
      Ql=sl*um1demim
      Qr=sr*um1demip



      tflux1(ie)= & 
           (um1demim*sl*deltaxm1+um1demip*sr*deltax)/(sumDeltaX) &
         - gamma_expl*g*dt &
         *((sl*deltaxm1+sr*deltax)/(sumDeltaX)) &
         *((hm1demip-hm1demim)/(deltaxm1demi))


      if (ie.eq.3) then
         tflux1(ie)=dof%q(1) !linear_interp( bc%hyd%t ,bc%hyd%q ,tc) !65.0_rp
      end if
      
      !zm1demi=demi*(zm1+zi)
      !hm1demim=max(zero,hm1demim-zm1demi) 
      !hm1demip=max(zero,hm1demip-zm1demi)

      tphi(ie)= &
         ((hm1*deltaxm1+hi*deltax)/(sumDeltaX))&
         - alpha_expl*(dt/deltax) &
         * ((um1demip*sr*deltax-um1demim*sl*deltaxm1)/(sumDeltaX))  

      !demi*(hm1+hi)-(alpha_expl/L)*(dt/mesh%crosssection(ie)%delta)*demi*(um1demip*hm1demip-um1demim*hm1demim)
      !tphi(ie) = demi*(h(ie-1)+bathy_cell(ie-1)+h(ie)+bathy_cell(ie))-(alpha_expl/L)*&
      !(dt/mesh%crosssection(ie)%delta)*demi*(v(ie  )*(s(ie  ))-v(ie-1)*(s(ie-1)))
   end do


   !tflux1(3) = 65.0_rp
   !===================================================================================================================!
   !  Calculating explicit Q
   !===================================================================================================================! 
   do ie=3,mesh%ncs+2
      vjm1=v( ie-1 )
      vj  =v( ie   )
      vjp1=v( ie+1 )
   
      Fjm1d2=tflux1(ie)
      Fjp1d2=tflux1(ie+1)
      deltax=mesh%crosssection(ie)%delta
      dof%s(ie)=dof%s(ie)-(dt/deltax)*(Fjp1d2-Fjm1d2)

      Phijm1d2=tphi(ie)
      Phijp1d2=tphi(ie+1)

      q=dof%q(ie)

      call UpdateMVectorElement(mesh,dof,ie,mvector)                 ! Update of mvector 
      call SurfaceToHeightCrossSection(mesh,dof,ie,mvector)          ! Update of dof%h(ie)

      !===================================================
      !  S,Q computation with source term (friction)
      !===================================================
      if (friction.eq.1) then 
         call computationRhCrossSection(mesh,dof,hydraulicRadiusie,ie,mvector) !Hydraulics computation (if friction==1)
         !call computationRhCrossSection(mesh,dof,hydraulicRadiusie,ie)        !Hydraulics computation (if friction==1)
            call calc_K_at_cs(dof, Manning, ie)                  ! Update of Manning
         A=(q*abs(q))/(((Manning**2))*(s(ie))*(hydraulicRadiusie**d4p3))  ! Sf= |q|*q /(K^2*S*Rh^(4/3)                
         SourceTermFriction=-g*A
      else 
         SourceTermFriction=0._rp
      end if

      Rj      = SourceTermFriction
      
      dof%q(ie)=v(ie)*s(ie)-(dt/deltax)*&
      ((max(Fjp1d2,0._rp)*vj+min(Fjp1d2,0._rp)*vjp1)-(max(Fjm1d2,0._rp)*vjm1+min(Fjm1d2,0._rp)*vj)) &
      -((g*dt)/deltax)*s(ie)*(Phijp1d2-Phijm1d2)&
      +dt*Rj
      if ((abs(dof%q(ie)).le.(0.00000000000001))) then
         dof%q(ie)=0.0
      endif


   end do


END SUBROUTINE explicit_low_froude_b1

