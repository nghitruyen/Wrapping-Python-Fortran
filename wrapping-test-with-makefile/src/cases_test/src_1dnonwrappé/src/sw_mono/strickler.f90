!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file strickler.f90
!! \brief .
!! \details .


!> Computes the friction coefficient K at a given cross-section
!! \brief This subroutine allows to compute the Strickler coefficient of friction K with different modeling
!! \details The different modeling available for the Stricler coefficient are : K=alpha(x)*h^beta(x), Newon...
!! 
SUBROUTINE calc_K_at_cs(dof, strickler, cs_idx)
  USE m_model
  USE m_mesh
  USE m_common

  implicit none

  TYPE( unk ), intent(inout)  ::  dof
  real(rp), intent(inout) :: strickler
  integer(ip), intent(in) :: cs_idx                            ! index of the cross-section at which K is computed

  ! Compute K at the cross-section cs_idx
  select case( K_model )

  case( 'K(h)' )
     ! K(x,h) = alpha(x)*h^beta(x)
     strickler = K_params%alpha(cs_idx)*(dof%h(cs_idx))**K_params%beta(cs_idx)
  case default 
     strickler = 1000
  end select
  
END SUBROUTINE calc_K_at_cs


!> Computes the friction coefficient K at each cross-section
!! \brief .
!! \details .
!! 
SUBROUTINE calc_K_everywhere(dof, mesh, strickler, mvector)
  USE m_model
  USE m_mesh
  USE m_common

  implicit none
  
!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

  TYPE( msh ), intent(in   )  ::  mesh
  TYPE( unk ), intent(inout)  ::  dof
  real(rp), dimension(mesh%ncs+4), intent(inout) :: strickler
  integer(ip), dimension(mesh%ncs+4) :: mvector

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!
  
  real(rp) :: perimeter
  real(rp) :: denom
  real(rp), dimension(3) :: perimeters3
      
!======================================================================================================================!
!  External Functions
!======================================================================================================================!

  real(rp) :: PerimeterFromH

  ! Compute K at the cross-section cs_idx
  select case( K_model )
  ! K(x,h) = alpha(x)*h^beta(x)
  case( 'K(h)' )
     do ie=1,mesh%ncs+4
        strickler(ie) = K_params%alpha(ie)*(dof%h(ie))**K_params%beta(ie)
     end do
  case( 'Einstein3' )
     do ie=1,mesh%ncs+4
        perimeter = PerimeterFromH(mesh, dof%h(ie), ie, mvector)
        call Perimeters3FromH(mesh, dof%h(ie), ie, mvector, perimeters3)
        denom = perimeters3(1) / K_params%coeffs(1, ie)**d3p2 + &
                perimeters3(2) / K_params%coeffs(2, ie)**d3p2 + &
                perimeters3(3) / K_params%coeffs(3, ie)**d3p2
        strickler(ie) = (perimeter / denom)**d2p3
     end do
  case default
     do ie=1,mesh%ncs+4
        strickler(ie) = 1000
     end do
  end select
  
END SUBROUTINE calc_K_everywhere


!> Return the value of dK/dh, the partial derivative of the Strickler coefficient K with respect to the height h
!! \brief .
!! \details .
!! 
SUBROUTINE calc_dKdh_everywhere(dof, mesh, dK_dh, mvector)
  USE m_model
  USE m_mesh
  USE m_common

  implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

  TYPE( unk ), intent(inout)  ::  dof
  TYPE( msh ), intent(in   )  ::  mesh
  real(rp), dimension(mesh%ncs+4), intent(inout) :: dK_dh
  integer(ip), dimension(mesh%ncs+4) :: mvector

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!
  
  real(rp) :: strickler
  real(rp) :: perimeter
  real(rp) :: dPdh
  real(rp) :: denom
  real(rp), dimension(3) :: perimeters3
      
!======================================================================================================================!
!  External Functions
!======================================================================================================================!

  real(rp) :: PerimeterFromH
  real(rp) :: dPdZFromH

  select case( K_model )

  case( 'K(h)' )
     do ie=1,mesh%ncs+4
        ! dK/dh = K*beta/h
        strickler = K_params%alpha(ie)*(dof%h(ie))**K_params%beta(ie)
        dK_dh(ie) = K_params%beta(ie)*strickler/dof%h(ie)
     end do 
  case( 'Einstein3' )
     do ie=1,mesh%ncs+4
        perimeter = PerimeterFromH(mesh, dof%h(ie), ie, mvector)
        call Perimeters3FromH(mesh, dof%h(ie), ie, mvector, perimeters3)
        dPdh = dPdZFromH(mesh, dof%h(ie), ie, mvector)
        denom = perimeters3(1) / K_params%coeffs(1, ie)**d3p2 + &
                perimeters3(2) / K_params%coeffs(2, ie)**d3p2 + &
                perimeters3(3) / K_params%coeffs(3, ie)**d3p2
        if (perimeters3(3) > 0.0) then
            dK_dh = dPdh * (1.0 - 1.0 / K_params%coeffs(3, ie)**d3p2) / denom**2
        else if (perimeters3(2) > 0.0) then
            dK_dh = dPdh * (1.0 - 1.0 / K_params%coeffs(2, ie)**d3p2) / denom**2
        else
            dK_dh = dPdh * (1.0 - 1.0 / K_params%coeffs(1, ie)**d3p2) / denom**2
        end if
     end do
  case default 
     dK_dh(:) = 0._rp
  end select

END SUBROUTINE calc_dKdh_everywhere


!> Return the value of dK/dh, the partial derivative of the Strickler coefficient K with respect to the height h
!! \brief .
!! \details .
!! 
SUBROUTINE calc_dK_dh(mesh, dof, dK_dh, cs_idx, mvector)
  USE m_model
  USE m_mesh
  USE m_common

  implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

  TYPE( msh ), intent(in   )  ::  mesh
  TYPE( unk ), intent(inout)  ::  dof
  real(rp), intent(inout) :: dK_dh
  integer(ip), intent(in) :: cs_idx                            ! index of the cross-section at which K is computed
  integer(ip), dimension(mesh%ncs+4) :: mvector

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!
  
  real(rp) :: strickler
  real(rp) :: perimeter
  real(rp) :: dPdh
  real(rp) :: denom
  real(rp), dimension(3) :: perimeters3
      
!======================================================================================================================!
!  External Functions
!======================================================================================================================!

  real(rp) :: PerimeterFromH
  real(rp) :: dPdZFromH

  select case( K_model )

  case( 'K(h)' )
     ! dK/dh = K*beta/h
     strickler = K_params%alpha(cs_idx)*(dof%h(cs_idx))**K_params%beta(cs_idx)
     dK_dh = K_params%beta(cs_idx)*strickler/dof%h(cs_idx)
  case( 'Einstein3' )
     perimeter = PerimeterFromH(mesh, dof%h(cs_idx), cs_idx, mvector)
     call Perimeters3FromH(mesh, dof%h(cs_idx), cs_idx, mvector, perimeters3)
     dPdh = dPdZFromH(mesh, dof%h(cs_idx), cs_idx, mvector)
     denom = perimeters3(1) / K_params%coeffs(1, cs_idx)**d3p2 + &
             perimeters3(2) / K_params%coeffs(2, cs_idx)**d3p2 + &
             perimeters3(3) / K_params%coeffs(3, cs_idx)**d3p2
     if (perimeters3(3) > 0.0) then
        dK_dh = dPdh * (1.0 - 1.0 / K_params%coeffs(3, cs_idx)**d3p2) / denom**2
     else if (perimeters3(2) > 0.0) then
        dK_dh = dPdh * (1.0 - 1.0 / K_params%coeffs(2, cs_idx)**d3p2) / denom**2
     else
        dK_dh = dPdh * (1.0 - 1.0 / K_params%coeffs(1, cs_idx)**d3p2) / denom**2
     end if
  case default 
     strickler = 0 
  end select

END SUBROUTINE calc_dK_dh


!> Computes the value of the parameters defining the Strickler coefficient K at each cross-section
!! \brief .
!! \details .
!! 
SUBROUTINE calc_K_params_everywhere(mesh)
  USE m_mesh
  USE m_model
  USE m_common
  
  implicit none
  type( msh ), intent(inout)  ::  mesh
  
  if( K_model == 'K(h)' ) then
     do i=1,K_params%nb_diff_K_reachs
        do ie=K_params%cs_start(i),K_params%cs_end(i)
           K_params%alpha(ie) = K_params%alpha(K_params%cs_start(i))
           K_params%beta(ie) = K_params%beta(K_params%cs_start(i))
        end do
     end do
     ! Ghost cells
     K_params%alpha(1) = K_params%alpha(3)
     K_params%alpha(2) = K_params%alpha(3)
     K_params%alpha(mesh%ncs+3) = K_params%alpha(mesh%ncs+2)
     K_params%alpha(mesh%ncs+4) = K_params%alpha(mesh%ncs+2)
     K_params%beta(1) = K_params%beta(3)
     K_params%beta(2) = K_params%beta(3)
     K_params%beta(mesh%ncs+3) = K_params%beta(mesh%ncs+2)
     K_params%beta(mesh%ncs+4) = K_params%beta(mesh%ncs+2)
  end if
  
!  print*,"K_params"
!  print*,K_params%alpha
  
END SUBROUTINE calc_K_params_everywhere


