!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file initialization.f90
!! \brief This file includes initialization subroutine.

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Initialization Subroutine specific to Shallow-Water Model
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Allocate space for variable used in the model (unknowns, mesh, observations stations)
!!
!! \details This subroutine allocates memory space for a set of variables used in the DassFlow model (unknowns,
!! mesh, observations stations). It fill the initial condition on the unknowns.
!! A part a this subroutine consists to read mesh data and compute the maximun of information to avoid to compute 
!! during main computation.
!! \param[in]    dof0 Initial condition on unknowns of the model. 
!! \param[in]    mesh Mesh of the problem.
SUBROUTINE Initial( dof0 , mesh, dof )

   USE m_common
   USE m_mesh
   USE m_model
   USE m_numeric
   USE m_obs
   USE m_user_data
   USE m_time_screen

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!
   type( unk ), intent(inout)  ::  dof
   type( msh ), intent(inout)  ::  mesh
   type( unk ), intent(inout)  ::  dof0

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   character(len=lchar)  ::  filename

   integer(ip)  ::  icod, iflag, nb_sta, iloc

   integer(ip), dimension(:), allocatable  ::  index_bathy_min

   real(rp), dimension(:), allocatable  ::  bathy_min , bathy_min_glob
   
   real(rp) :: xL,yL, xR,yR, x

   real(rp) ::w

   real(rp) :: wi,wim1,Hi,Him1,yi !temporary variable 
   
   real(rp) :: rh

   real(rp) :: sumDis,slopemean,HtoS

   real(rp) :: temp

   real(rp) :: GetWFromH
! 
!    !==============================================================================================!
!    !  Create directories
!    !==============================================================================================!
!    call system('mkdir -p min') ! the cov matrix are written in the min directory
!    call system('mkdir -p res')
   
   !===================================================================================================================!
   !  Area surface computation (Sequence s_i and sum s_i of DassFlow1D doc)
   !===================================================================================================================!
   do i = 1,mesh%ncs+4
      k=mesh%CrossSection(i)%nc
      allocate(mesh%CrossSection(i)%trapAreaSum(k))
      allocate(mesh%CrossSection(i)%surfaceArea(k))
! DEPRECATED
!       allocate(mesh%CrossSection(i)%surfaceAreaSum(k))
      allocate(mesh%CrossSection(i)%intsurfaceAreaSum(k))
      

      !TODO : Verifier coherence des donneess
      !s_0=(H_0-z_b)*w_0
      mesh%CrossSection(i)%trapAreaSum(1)      = 0
      mesh%CrossSection(i)%surfaceArea(1)      =(mesh%crosssection(i)%height(1)-bathy_cell(i))* &                  !(H_0-z_b)*
                                                mesh%crosssection(i)%surfacewidth(1)                               !w_0
! DEPRECATED
!       mesh%CrossSection(i)%surfaceAreaSum(1)   =mesh%CrossSection(i)%surfaceArea(1)                                !S_0=s_0

      
      do j=2,k
         !S_m=0.5*(w_{m-1}+w_{m})*(H_{m}-H_{m-1})      
         mesh%CrossSection(i)%surfaceArea(j)=demi* &                                            !S_m=0.5*
              (mesh%crosssection(i)%surfacewidth(j-1)+mesh%crosssection(i)%surfacewidth(j))*&   !(w_{m-1}+w_{m})*
              (mesh%crosssection(i)%height(j)-mesh%crosssection(i)%height(j-1))                 !(H_{m}-H_{m-1})

         mesh%CrossSection(i)%trapAreaSum(j) = mesh%CrossSection(i)%trapAreaSum(j-1) + mesh%CrossSection(i)%surfaceArea(j)!St_m=St_{m-1}+S_m
! DEPRECATED
!          !St_m=St_{m-1}+S_m
!          mesh%CrossSection(i)%surfaceAreaSum(j)=mesh%CrossSection(i)%surfaceAreaSum(j-1) + mesh%CrossSection(i)%surfaceArea(j)!St_m=St_{m-1}+S_m

      end do
   end do


   !===================================================================================================================!
   !  Perimeter and alpha computation (Sequence pe_i ,alpha_i and sum pe_i of DassFlow1D doc)
   !===================================================================================================================!
   do i = 1,mesh%ncs+4
      k=mesh%CrossSection(i)%nc
      allocate(mesh%CrossSection(i)%perimeter(k))
      allocate(mesh%CrossSection(i)%perimeterp1(k))
      allocate(mesh%CrossSection(i)%perimeterp2(k))
      allocate(mesh%CrossSection(i)%alpha1(k))
      allocate(mesh%CrossSection(i)%alpha2(k))
      allocate(mesh%CrossSection(i)%trapPerimSum(k))
! DEPRECATED
!       allocate(mesh%CrossSection(i)%perimeterSum(k))
      !allocate(mesh%CrossSection(i)%intsurfaceAreaSum(k))
      
      !Pe0=w_0+2*(H_0-z_b)
      mesh%CrossSection(i)%perimeter(1)= mesh%crosssection(i)%surfacewidth(1)+ &                               !Pe0=w_0+
                                         two*(mesh%crosssection(i)%height(1)-bathy_cell(i))   !2*(H_0-z_b)
      mesh%CrossSection(i)%perimeterp1(1)= (mesh%crosssection(i)%height(1)-bathy_cell(i))
      mesh%CrossSection(i)%perimeterp2(1)= (mesh%crosssection(i)%height(1)-bathy_cell(i))

      mesh%CrossSection(i)%alpha1(1)=0._rp
      mesh%CrossSection(i)%alpha2(1)=0._rp

      mesh%CrossSection(i)%trapPerimSum(1)=0.0
! DEPRECATED
!       mesh%CrossSection(i)%perimeterSum(1)=mesh%CrossSection(i)%perimeter(1) !Sum Pe0=Pe0

      do j=2,k
         !Pe1_i=((0.5*W_i-(0.5*W_{i-1}-y_i))^2+(H_i-H_{i-1})^2)^(1/2)
         !Pe2_i=((0.5*W_i-(0.5*W_{i-1}+y_i))^2+(H_i-H_{i-1})^2)^(1/2)
         !Pe_i=Pe1_i+Pe2_i
         wi=mesh%crosssection(i)%surfacewidth(j)
         wim1=mesh%crosssection(i)%surfacewidth(j-1)
         Hi=mesh%crosssection(i)%height(j)
         Him1=mesh%crosssection(i)%height(j-1)
         yi=mesh%crosssection(i)%y(j-1)-mesh%crosssection(i)%y(j)

         mesh%CrossSection(i)%perimeterp1(j)=sqrt((demi*wi-(demi*wim1-yi))**2+(Hi-Him1)**2) !((0.5*W_i-(0.5*W_{i-1}-y_i))^2+(H_i-H_{i-1})^2)^(1/2)
         mesh%CrossSection(i)%perimeterp2(j)=sqrt((demi*wi-(demi*wim1+yi))**2+(Hi-Him1)**2) !((0.5*W_i-(0.5*W_{i-1}+y_i))^2+(H_i-H_{i-1})^2)^(1/2)

         !alpha1_i=(0.5*w_i -(0.5*w_{i-1}-y_i))/(H_i-H_{i-1})
         !alpha2_i=(0.5*w_i -(0.5*w_{i-1}+y_i))/(H_i-H_{i-1})
         mesh%CrossSection(i)%alpha1(j)   =(demi*wi-(demi*wim1-yi))/(Hi-Him1) !0.5*w_i -(0.5*w_{i-1}-y_i))/(H_i-H_{i-1})
         mesh%CrossSection(i)%alpha2(j)   =(demi*wi-(demi*wim1+yi))/(Hi-Him1) !0.5*w_i -(0.5*w_{i-1}+y_i))/(H_i-H_{i-1})
         
         mesh%CrossSection(i)%perimeter(j)=mesh%CrossSection(i)%perimeterp1(j)+mesh%CrossSection(i)%perimeterp2(j) !p1+p2

         mesh%CrossSection(i)%trapPerimSum(j)=mesh%CrossSection(i)%trapPerimSum(j-1)+mesh%CrossSection(i)%perimeter(j)
! DEPRECATED
!          mesh%CrossSection(i)%perimeterSum(j)=mesh%CrossSection(i)%perimeterSum(j-1)+mesh%CrossSection(i)%perimeter(j)

      end do
   end do

   !===================================================================================================================!
   !  w_derivative for pressure term computation
   !===================================================================================================================!
   do i = 3,mesh%ncs+2
      k=mesh%CrossSection(i)%nc
      allocate(mesh%CrossSection(i)%zint(k))
      allocate(mesh%CrossSection(i)%wl(k))
      allocate(mesh%CrossSection(i)%wr(k))
      !do j=1,k
      do j=1,k-1
         mesh%CrossSection(i)%zint  (j) = mesh%crosssection(i)%height(j)-bathy_cell(i)
         mesh%CrossSection(i)%wl    (j) = GetWFromH(mesh,mesh%crosssection(i)%height(j)-bathy_cell(i),i-1)
         mesh%CrossSection(i)%wr    (j) = GetWFromH(mesh,mesh%crosssection(i)%height(j)-bathy_cell(i),i+1)
      end do
   end do

   !===================================================================================================================!
   !  x calculation mesh%crosssection(i)%x=distance(xi,x0)
   !===================================================================================================================!
   sumDis = 0.0
   mesh%CrossSection(3)%x = 0.0
   do i = 4,mesh%ncs+2
    xL = mesh%CrossSection(i-1)%coord%x
    yL = mesh%CrossSection(i-1)%coord%y
    xR=mesh%CrossSection(i)%coord%x
    yR=mesh%CrossSection(i)%coord%y
    sumDis = sumDis + sqrt((xR-xL)**2+(yR-yL)**2)
    mesh%CrossSection(i)%x = sumDis
   end do

   mesh%CrossSection(1)%x = -2.0 * mesh%CrossSection(4)%x
   mesh%CrossSection(2)%x = -mesh%CrossSection(4)%x
   sumDis = mesh%CrossSection(mesh%ncs+2)%x - mesh%CrossSection(mesh%ncs+1)%x
   mesh%CrossSection(mesh%ncs+3)%x = mesh%CrossSection(mesh%ncs+2)%x + sumDis
   mesh%CrossSection(mesh%ncs+4)%x = mesh%CrossSection(mesh%ncs+3)%x + sumDis

   !===================================================================================================================!
   !  Delta x calculation mesh%crosssection(i)%delta=distance(xi-1/2,xi+1/2)
   !===================================================================================================================!
   do i = 4,mesh%ncs+1
      xL=(mesh%CrossSection(i)%coord%x+mesh%CrossSection(i-1)%coord%x)*demi
      yL=(mesh%CrossSection(i)%coord%y+mesh%CrossSection(i-1)%coord%y)*demi
      xR=(mesh%CrossSection(i+1)%coord%x+mesh%CrossSection(i)%coord%x)*demi
      yR=(mesh%CrossSection(i+1)%coord%y+mesh%CrossSection(i)%coord%y)*demi

      mesh%CrossSection(i)%delta=sqrt((xR-xL)**2+(yR-yL)**2)
   end do

   do i=1,3
      mesh%CrossSection(i)%delta=mesh%CrossSection(4)%delta
   end do
   do i=mesh%ncs+2,mesh%ncs+4
      mesh%CrossSection(i)%delta=mesh%CrossSection(mesh%ncs+1)%delta
   end do

   !===================================================================================================================!
   !  Deltademi x calculation mesh%crosssection(i)%deltademi=distance(xi-1,xi)
   !===================================================================================================================!
   do i = 4,mesh%ncs+2
      xL=mesh%CrossSection(i-1)%coord%x
      yL=mesh%CrossSection(i-1)%coord%y
      xR=mesh%CrossSection(i)%coord%x
      yR=mesh%CrossSection(i)%coord%y

      mesh%CrossSection(i)%deltademi=sqrt((xR-xL)**2+(yR-yL)**2)
   end do

   do i=1,3
      mesh%CrossSection(i)%deltademi=mesh%CrossSection(4)%deltademi
   end do
   do i=mesh%ncs+2,mesh%ncs+4
      mesh%CrossSection(i)%deltademi=mesh%CrossSection(mesh%ncs+1)%deltademi
   end do
   
   !===================================================================================================================!
   !  Chainage calculation
   !===================================================================================================================!
   mesh%CrossSection(1)%chainage = 0._rp
   mesh%CrossSection(2)%chainage = 0._rp
   
   do i = 3,mesh%ncs+2
      mesh%CrossSection(i)%chainage=mesh%CrossSection(i-1)%chainage+mesh%CrossSection(i)%deltademi
   end do

   mesh%CrossSection(mesh%ncs+3)%chainage = mesh%CrossSection(mesh%ncs+2)%chainage
   mesh%CrossSection(mesh%ncs+4)%chainage = mesh%CrossSection(mesh%ncs+2)%chainage

   ! ================================================
   ! Compute Manning parameters at each cross-section
   ! ================================================
   if (friction /= 0) then
      call read_strickler_params(mesh)   ! read parameters defining the Strickler coeff from input file
      call calc_K_params_everywhere(mesh)
   end if
   
   !=====================================================================================================================!
   ! Re computation of elevation of gost cell
   !=====================================================================================================================!
   sumDis=mesh%CrossSection(3)%delta
   do i = 4,mesh%ncs+2
      sumDis=sumDis+mesh%CrossSection(i)%delta
   enddo
      


   slopemean=-(mesh%CrossSection(mesh%ncs+2)%elevation-mesh%CrossSection(3)%elevation)/sumDis

   !Fill gost cell (W_boundary)
   mesh%CrossSection(1)%elevation=mesh%CrossSection(3)%elevation+mesh%CrossSection(4)%deltademi*slopemean*2._rp
   mesh%CrossSection(2)%elevation=mesh%CrossSection(3)%elevation+mesh%CrossSection(4)%deltademi*slopemean

   do j=1,mesh%CrossSection(3)%nc
         mesh%CrossSection(1)%height(j)=mesh%CrossSection(3)%height(j)+mesh%CrossSection(4)%deltademi*slopemean*2_rp
         mesh%CrossSection(2)%height(j)=mesh%CrossSection(3)%height(j)+mesh%CrossSection(4)%deltademi*slopemean
   end do

   !Fill gost cell (E_boundary)
   mesh%CrossSection(mesh%ncs+3)%elevation=mesh%CrossSection(mesh%ncs+2)%elevation-mesh%CrossSection(mesh%ncs+1)%deltademi*slopemean
   mesh%CrossSection(mesh%ncs+4)%elevation=mesh%CrossSection(mesh%ncs+2)%elevation-mesh%CrossSection(mesh%ncs+1)%deltademi*slopemean*2._rp

   do j=1,mesh%CrossSection(mesh%ncs+2)%nc
         mesh%CrossSection(mesh%ncs+3)%height(j)=mesh%CrossSection(mesh%ncs+2)%height(j)+&
         mesh%CrossSection(mesh%ncs+1)%deltademi*slopemean
         mesh%CrossSection(mesh%ncs+4)%height(j)=mesh%CrossSection(mesh%ncs+2)%height(j)+&
         mesh%CrossSection(mesh%ncs+1)%deltademi*slopemean*2_rp
   end do

   !===================================================================================================================!
   !  Loading/Creating hydrograph File
   !===================================================================================================================!
   inquire( file = 'hydrograph_FS.txt' , exist = file_exist(1) )

   inquire( file = 'hydrograph.txt' , exist = file_exist(2) )


   if ( file_exist(1) ) then

      open(10,file='hydrograph_FS.txt',status='old')

      read(10,*)
      read(10,*) 
      read(10,*) 
      read(10,*) j
      j=j-1 
      read(10,*) bc%hyd_FS%a0
      allocate( bc%hyd_FS%a( j ) )
      allocate( bc%hyd_FS%b( j ) )
      allocate( bc%hyd_FS%n( j ) )
      do i = 1,j
         read(10,*) bc%hyd_FS%n(i),bc%hyd_FS%a(i) , bc%hyd_FS%b(i)
      end do

      close(10)
      bc%typehyd='file_FS'

   else if ( file_exist(2) ) then
      open(10,file='hydrograph.txt',status='old')

      read(10,*)
      read(10,*) 
      read(10,*) 
      read(10,*) j


      allocate( bc%hyd%t( j ) )
      allocate( bc%hyd%q( j ) )
      do i = 1,j
         read(10,*) bc%hyd%t(i) , bc%hyd%q(i)
      end do

      close(10)
      bc%typehyd='file'

   end if
   
   !===================================================================================================================!
   !  Loading/Creating lateral hydrograph File
   !===================================²================================================================================!
   
   if ( lat_inflow == '1' ) then

      call allocate_latflow(dof)
     
      call read_qlatfiles(mesh)

    else! variables must be attributed for inversion
    
        allocate(bc%hyd_lat%x( 1 ))
        allocate(bc%hyd_lat%t( 1 ), bc%hyd_lat%q( 1,1 ))
        allocate(dof%qlat(2,1))
        allocate(bc%hyd_lat%params( 1,3 ))
        bc%hyd_lat%x(:)=0.0_rp
        bc%hyd_lat%t(:)=0.0_rp
        bc%hyd_lat%q(:,:)=0.0_rp
        dof%qlat(:,:)=0.0_rp
      
   endif
   !===================================================================================================================!
   !  Loading rating curve
   !===================================================================================================================!

   inquire( file = 'rating_curve.txt' , exist = file_exist(1) )

   if ( file_exist(1) ) then

      open(10,file='rating_curve.txt',status='old')

      read(10,*)
      read(10,*)
      read(10,*)
      read(10,*) j

      allocate(bc%rat%h(j))
      allocate(bc%rat%q(j))

      do i = 1,j
         read(10,*) bc%rat%h(i) , bc%rat%q(i)
         
         !=============================================================================================================!
         ! CHECK-UP : Ensure that h and q are in increasing order
         !=============================================================================================================!
         if (i > 1) then
            if (bc%rat%h(i) < bc%rat%h(i-1) + 1e-6 .and. j > 2) then
               write(*,*) 'Height ', i, 'for rating curve is lower than or equal to previous elevation'
               write(*,*) bc%rat%h(i), bc%rat%h(i-1)
               !stop
            end if
            if (bc%rat%q(i) < bc%rat%q(i-1) + 1e-6 .and. j > 2) then
               write(*,*) 'Discharge ', i, 'for rating curve is lower than or equal to previous discharge'
               !stop
            end if
         end if
        
     end do

      
      close(10)
      bc%typerat='file'

   end if
   
   !===================================================================================================================!
   !  Loading downstream elevations
   !===================================================================================================================!

   inquire( file = 'downstream_elevations.txt' , exist = file_exist(1) )

   if ( file_exist(1) ) then

      open(10,file='downstream_elevations.txt',status='old')

      read(10,*)
      read(10,*)
      read(10,*)
      read(10,*) j

      allocate(bc%dsz%t(j))
      allocate(bc%dsz%y(j))

      do i = 1,j
         read(10,*) bc%dsz%t(i) , bc%dsz%y(i)
     end do

      close(10)

   end if

   !===================================================================================================================!
   !  Load bathymetry points
   !===================================================================================================================!
   inquire( file = 'bathymetry_points.txt' , exist = file_exist(1) )
   
   if ( file_exist(1) ) then
   
      if (bathymetry(1:10) /= "piecewise_") then
         print *, "Bathymetry model must be 'piecewise_*' when using bathymetry points"
         stop 2
      end if
      
      open(10,file='bathymetry_points.txt',status='old')
      
      read(10,*)
      read(10,*)
      read(10,*)
      read(10,*) j

      allocate(bathy_indices(j))
      allocate(bathy_points(j))
      
      do i = 1,j
         read(10,*) x
         iloc = minloc(abs(mesh%CrossSection(3:mesh%ncs+2)%coord%x - x), 1) + 2
         bathy_indices(i) = iloc
         bathy_points(i) = mesh%CrossSection(iloc)%elevation
      end do
      
   else
   
      j = 0
      do i = bathy_first, bathy_last, bathy_step
         j = j + 1
      end do
      allocate(bathy_indices(j))
      allocate(bathy_points(j))
      j = 0
      do i = bathy_first, bathy_last, bathy_step
         j = j + 1
         bathy_indices(j) = i
         bathy_points(j) = mesh%CrossSection(i)%elevation
      end do
      
   end if
   
   !===================================================================================================================!
   !  Update bathymetry
   !===================================================================================================================!
!    nb_bathy_control_pts = (bathy_last-bathy_first)/bathy_step+1
   nb_bathy_control_pts = size(bathy_indices)
   call calc_bathymetry(mesh, dof0)

   !===================================================================================================================!
   !  Slope computation
   !===================================================================================================================!
   do i = 3,mesh%ncs+2 
      mesh%crosssection(i)%slope = (bathy_cell(i+1)-bathy_cell(i-1))&
            /(mesh%crosssection(i)%deltademi+mesh%crosssection(i-1)%deltademi)
   end do

   !==============================================================================================!
   !  Store first guess parameters
   !==============================================================================================!
#ifdef USE_ADJ
   if ( c_bathy   == 3    ) then
      allocate( bathy_cell_fg(nb_bathy_control_pts) )
      bathy_cell_fg(:) = bathy_cell(bathy_first:bathy_last:bathy_step)
   end if
   if ( c_bathy == 1) then
      allocate( bathy_points_fg(nb_bathy_control_pts) )
      bathy_points_fg(:) = bathy_points(:)
   end if

   if ( c_manning == 1    ) then
      select case ( K_model )
      case ( 'K(h)' )
         allocate( alpha_K_fg(K_params%nb_diff_K_reachs) )
         allocate( beta_K_fg(K_params%nb_diff_K_reachs) )
         do i=1,K_params%nb_diff_K_reachs
            alpha_K_fg(i) = K_params%alpha(K_params%cs_start(i))
            beta_K_fg(i) = K_params%beta(K_params%cs_start(i)) 
         end do
      case default
         print*, 'K model not taken into account'
         stop
      end select
   end if

   if ( c_hydrograph == 1 ) then
      allocate( qin_fg(size(bc%hyd%q(:))) )
      qin_fg(:) = bc%hyd%q(:)
   end if
   
   if (lat_inflow == '1' .and. c_hydrograph == 1) then
      allocate( qlat_fg(size(bc%hyd_lat%q(:,1)),size(bc%hyd_lat%q(1,:))) )
      qlat_fg(:,:) = bc%hyd_lat%q(:,:)
   end if
   
   
   
#endif
   !==============================================================================================!
   !  allocate and initialize variables v = B^{-1/2}*(u-u_b) = 0
   !==============================================================================================!

   if ( var_chg ) then

      allocate( bathy_cell_chg(nb_bathy_control_pts) )
      allocate( bathy_points_chg(nb_bathy_control_pts) )
      allocate( alpha_K_chg(K_params%nb_diff_K_reachs) )
      allocate( beta_K_chg(K_params%nb_diff_K_reachs) )
      allocate( qin_chg(size(bc%hyd%q(:))) )

      bathy_cell_chg = 0._rp
      bathy_points_chg = 0._rp
      alpha_K_chg    = 0._rp
      beta_K_chg     = 0._rp
      qin_chg        = 0._rp
      
      allocate( qlat_chg(size(bc%hyd_lat%q(:,1)),size(bc%hyd_lat%q(1,:)) ))
      qlat_chg       = 0._rp
      
   end if

   !===================================================================================================================!
   !  DOF Initialization
   !===================================================================================================================!
   inquire( file = 'ic.bin'      , exist = file_exist(1) )
   inquire( file = 'restart.bin' , exist = file_exist(2) )

   !If ic.bin file exists 
   tc0 = 0._rp
   nt0 = 0
   if      ( file_exist(1) ) then
      open(10,file='ic.bin',form='unformatted',status='old',access='direct',recl=3*length_real)
      read(10,rec=1) tc0
      tc0 = 0._rp

   ! Else if restart.bin exists
   else if ( file_exist(2) ) then
      print *, "[ WARNING ] Using restart file."
      open(10,file='restart.bin',form='unformatted',status='old',access='direct',recl=3*length_real)
      read(10,rec=1) tc0
      if (adapt_dt == 0) then 
        nt0 = tc0 / dt
      end if
   end if

   !Read file
   if ( file_exist(1) .or. file_exist(2)) then
      do i = 1,mesh%ncs+4
         read(10,rec=1+i) dof0%h(i) , dof0%s(i) , dof0%q(i)
         bathy_cell(i)=mesh%CrossSection(i)%elevation
         dof0%S(i)=HtoS(mesh,i,dof0%h(i))

      end do
      close(10)
      !call SurfaceToHeight(mesh,dof0)

   ! Else use users function   
   else

      select case( initialization)
      
         case('water_height')
            do i = 1,mesh%ncs+4
               dof0%h(i)  =  max( 0.0_rp , h0_user( mesh%CrossSection(i)%coord%x , mesh%CrossSection(i)%coord%y ) )
               bathy_cell(i)=mesh%CrossSection(i)%elevation
               dof0%S(i)=HtoS(mesh,i,dof0%h(i))
            end do

         case('water_elevation')
            do i = 1,mesh%ncs+4
               dof0%h(i)  =  max( 0.0_rp , h0_user( mesh%CrossSection(i)%coord%x , mesh%CrossSection(i)%coord%y ) )&
               -mesh%CrossSection(i)%elevation
               bathy_cell(i)=mesh%CrossSection(i)%elevation
               dof0%S(i)=HtoS(mesh,i,dof0%h(i))
            end do

         case('surface')
            do i = 1,mesh%ncs+4
               dof0%s(i)  =  max( 0.0_rp , s0_user(mesh%CrossSection(i)%coord%x , mesh%CrossSection(i)%coord%y ) )
               bathy_cell(i)=mesh%CrossSection(i)%elevation
            end do
            call SurfaceToHeight(mesh,dof0)

         case('height_and_discharge')
            ! Set height from h0_user function
            do i = 1,mesh%ncs+4
               dof0%h(i)  =  max( 0.0_rp , h0_user(mesh%CrossSection(i)%coord%x , mesh%CrossSection(i)%coord%y ) )
               bathy_cell(i)=mesh%CrossSection(i)%elevation
               dof0%S(i)=HtoS(mesh,i,dof0%h(i))
            end do
            ! Set discharge from Q0_user function
            do i = 1,mesh%ncs+4 
              dof0%Q(i)  =  Q0_user( mesh%CrossSection(i)%coord%x  ,mesh%CrossSection(i)%coord%y )
            end do
            print *, dof0%h(:)

         case('backwater')
            tc = tc0
            call solve_backwater(mesh, dof0)
            do i = 1,mesh%ncs+4
               bathy_cell(i)=mesh%CrossSection(i)%elevation
            end do
            ! Nothing to do here, initialisation will be done in run_model_sw_mono

         case('standard_step')
            tc = tc0
!             call standard_step(mesh, dof0, 1e-3_rp, 1000_ip)
            do i = 1,mesh%ncs+4
               bathy_cell(i)=mesh%CrossSection(i)%elevation
            end do
            ! Nothing to do here, initialisation will be done in run_model_sw_mono

         case default
            do i = 1,mesh%ncs+4
               dof0%s(i)  =  max( 0.0_rp , s0_user(mesh%CrossSection(i)%coord%x , mesh%CrossSection(i)%coord%y ) )
               bathy_cell(i)=mesh%CrossSection(i)%elevation
            end do
            call SurfaceToHeight(mesh,dof0)
            !Update discharge from Q0_user function
            do i = 1,mesh%ncs+4 
              dof0%Q(i)  =  Q0_user( mesh%CrossSection(i)%coord%x  ,mesh%CrossSection(i)%coord%y )
            end do 


      end select


   end if
   
   !===================================================================================================================!
   !  Print Qinterface update
   !===================================================================================================================!

   ! If solver used is preissmann type tflux is not used so Qinterface sould be egal to 0 
   if (index(spatial_scheme,'preissmann').ne.0) then
      Qinterface=0_ip
   end if


   ! =========================================== !
   !  Init of the parameter that decides if the alpha_coeff weighing the J_reg term must be updated
   ! =========================================== !
   if (bathy_regul_type == "bayes") then
      recalc_alpha_regul = -1
      alpha_regul = 1
   else
      recalc_alpha_regul = 1
      if (regul_bathy < 1e-12) regul_bathy = 1.0
   end if
   
   
   !===================================================================================================================!
   !  Initilization of Stations and Sections to Output it Reading the obs.txt File
   !===================================================================================================================!

   nb_obs = 0

   if ( w_obs == 1 ) then
   
      inquire(file = 'obs_stations.txt' , exist = file_exist(1))
      
      inquire(file = 'obs_groups.txt' , exist = file_exist(2))
      
      ! Backward compatibility
      if (.not. file_exist(1) .and. .not. file_exist(2)) then
         inquire(file = 'obs.txt' , exist = file_exist(3))
         
         if (.not. file_exist(3)) then
         
            write(*, *) 'Observation stations file (obs_stations.txt) not found'
            stop 2
         end if
         
      else
      
         file_exist(3) = .false.
         
      end if
      
      if (file_exist(1)) then
      
         call read_obs_stations_file()
         
      end if
      
      if (file_exist(2)) then
      
         call read_obs_groups_file()
         
      end if
         
      if (file_exist(3)) then

         !================================================================================================================!
         !  Opening Data File concerning Stations  Recording at prescribed frequency
         !================================================================================================================!

         open(10,file='obs.txt',form='formatted',status='old')

         !================================================================================================================!
         !  Treating First Time Stations Data Record
         !================================================================================================================!

         buffer = '' ; icod = 1

         do while ( buffer(1:8) /= 'stations'          .and. &
                    buffer(1:8) /= 'stations_with_grp' .and. &
                    buffer(1:8) /= 'sections'          .and. icod >= 0 )

            read(10,'(A)',iostat=icod) buffer

         end do

         if ( icod >= 0 ) call read_obs_file

         !================================================================================================================!
         !  Treating Second Time Stations Data Record
         !================================================================================================================!

         buffer = '' ; icod = 1

         do while ( buffer(1:8) /= 'stations'          .and. &
                    buffer(1:8) /= 'stations_with_grp' .and. &
                    buffer(1:8) /= 'sections'          .and. icod >= 0 )

            read(10,'(A)',iostat=icod) buffer

         end do

         if ( icod >= 0 ) call read_obs_file

         !================================================================================================================!
         !  Treating Thrid Time Stations or Sections Data Record
         !================================================================================================================!

         buffer = '' ; icod = 1

         do while ( buffer(1:8) /= 'stations'          .and. &
                    buffer(1:8) /= 'stations_with_grp' .and. &
                    buffer(1:8) /= 'sections'          .and. icod >= 0 )

            read(10,'(A)',iostat=icod) buffer

         end do

         if ( icod >= 0 ) call read_obs_file

         !================================================================================================================!
         !  Closing Data File concerning Stations and Sections Recording at prescribed frequency
         !================================================================================================================!

         close(10)
         
      end if

   end if

   !===================================================================================================================!
   !  Reading param_obs.txt
   !===================================================================================================================!
   if ( w_obs == 1 .and. file_exist(3) ) then

      open(10,file='param_obs.txt',form='formatted',status='old')
      read(10,'(A)',iostat=icod) buffer
      
      ! Read number of stations (and code to determine if flag for regularity of observations is present)
      read(buffer, *, iostat=icod) nb_sta, iflag
      if (icod < 0) iflag = 0

      do iobs = 1,size( station )
      
         if (iflag == 1) then
            
            read(10,*) station( iobs )%length , station(iobs)%nb_dt
            allocate(station(iobs)%dt_obs(station(iobs)%nb_dt))
            
            do i = 1, station(iobs)%nb_dt
            
               read(10,*) station( iobs )%dt_obs(i)
               
            end do
            station( iobs )%ind_t=1_ip
        
         else
        
            read(10,*) station( iobs )%length , station(iobs)%dt_offset
         
         end if
        
      end do
      close(10)


      !================================================================================================================!
      !  Compute dt_obs using offset and dt (iflag == 0)
      !================================================================================================================!
      if (iflag == 0) then
      
         do iobs = 1,size(station)

            station(iobs)%nb_dt=int((ts- station(iobs)%dt_offset)/station(iobs)%dt)+1_ip
            
!             print *, "allocate(station(iobs)%dt_obs(2)", station(iobs)%nb_dt
!             print *, "**", ts- station(iobs)%dt_offset, station(iobs)%dt
            allocate( station(iobs)%dt_obs(station(iobs)%nb_dt  ) ) 
            
            station(iobs)%dt_obs(1)=station(iobs)%dt_offset

            do i =2,station(iobs)%nb_dt
              station(iobs)%dt_obs(i)=station(iobs)%dt_obs(i-1)+station(iobs)%dt ! Create array of observation time ( offset + repitivity satellite)
            end do 

            station( iobs )%ind_t=1_ip
            
         end do 
         
      end if

   endif


   !===================================================================================================================!
   !  Initialize obs
   !===================================================================================================================!

   if ( use_obs == 1 ) then

      call Print_Screen( 'start_read_obs' )
      
      call read_stations

      allocate( innovation( size( station ) ) )
      
      do iobs = 1,size( station )
      
            !==========================================================================================================!
            ! CHECK-UP : Ensure that station's array are allocated
            !==========================================================================================================!
            if (.not.allocated(station( iobs )%t)) then
              write(*, *) 'Observation for station ', iobs, 'not found'
              stop
            end if

         innovation( iobs )%nb_dt  =  size( station( iobs )%t(:) )

         innovation( iobs )%nb_dx  =  1

         allocate( innovation( iobs )%diff( innovation( iobs )%nb_dt * &
                                            innovation( iobs )%nb_dx ) )

         innovation( iobs )%diff(:)  =  0._rp

         !write (*,'(2(I5))') size( station( iobs )%t(:) ), innovation( iobs )%nb_dx

         !write (*,'(2(E20.5))') station( iobs )%t(1), station( iobs )%t(2)

   
      end do
      
      call Print_Screen( 'end_read_obs' )

   else

      allocate( innovation(1) )

   end if
      
      
   !===================================================================================================================!
   !  Enforce allocation of unallocated arrays as they will be stored by pushRealArray function
   !===================================================================================================================!
   if (.not. allocated(bc%hyd_lat%qsim)) then
      allocate(bc%hyd_lat%qsim(1))
   end if
   if (.not. allocated(dof%qlat)) then
      allocate(dof%qlat(1, 1))
   end if
   


   time(:) = 0._rp

   CONTAINS

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Initialize dof using backwater model
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>   Initialize dof using backwater model
   !!
   SUBROUTINE InitialFromBackwater( dof0, mesh)
   
      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(inout  )  ::  mesh
      type( unk ), intent(inout)  ::  dof0

      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      real(rp) :: q         ! Discharge
      real(rp) :: z         ! Water elevation
      real(rp) :: w         ! Water surface width 
      real(rp) :: perimeter ! Wet Perimeter 
      real(rp) :: rh        ! Hydraulic radius
      real(rp) :: Manning   ! Manning
      real(rp) :: debitance ! Debitance
      real(rp) :: fr2       ! Froude square
      real(rp) :: dx        ! Spatial step size
      real(rp) :: So        ! Bathy slope
      real(rp) :: Sf        ! Friction slope
      
      integer(ip), dimension(mesh%ncs+4) :: mvector           ! Vector m
      
      real(rp)  :: PerimeterFromH
      real(rp)  :: GetWFromH
      real(rp)  :: HtoS

      !================================================================================================================!
      !  Compute downstream dof
      !================================================================================================================!
      i = mesh%ncs+2
      dof0%q(i) = Q0_user(mesh%CrossSection(i)%coord%x, mesh%CrossSection(i)%coord%y)
      dof0%h(i) = linear_interp(bc%rat%q, bc%rat%h, dof0%q(i)) - bathy_cell(i)
      dof0%s(i) = HtoS(mesh, i, dof0%h(i))
      call UpdateMVectorElement(mesh, dof0, i, mvector)
      
      !================================================================================================================!
      !  Compute dof from backwater curve
      !================================================================================================================!
      do i = mesh%ncs+1, 1, -1
      
         !=============================================================================================================!
         !  Uniform discharge
         !=============================================================================================================!
         dof0%q(i) = dof0%q(i+1)
         
         !=============================================================================================================!
         !  Backwater curve
         !=============================================================================================================!
         perimeter = PerimeterFromH(mesh, dof0%h(i+1), i+1, mvector)
         w = GetWFromH(mesh, dof0%h(i+1), i+1)
         rh = dof0%s(i+1) / perimeter
         call calc_K_at_cs(dof0, Manning, i+1)
         debitance = Manning * dof0%s(i+1) * (rh**(d2p3))
         Sf = dof0%q(i+1)**2 / debitance**2
         dx = mesh%crosssection(i+1)%deltademi
         So = (bathy_cell(i) - bathy_cell(i+1)) / dx
         fr2 = dof0%q(i+1)**2 * w / (g * dof0%s(i+1)**3)
         dof0%h(i) = dof0%h(i+1) - dx * (So - Sf) / (1.0_rp - fr2)
         
         !=============================================================================================================!
         ! Update S and mvector
         !=============================================================================================================!
         dof0%s(i) = HtoS(mesh, i, dof0%h(i))
         call UpdateMVectorElement(mesh, dof0, i, mvector)
         
      end do

   END SUBROUTINE InitialFromBackwater


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Reading Stations or Sections informations in obs.txt file and Creating associated structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>   Reading stations or sections informations in obs.txt file and creating associated structure
   !!
   !! \details This subroutine read the obs.txt file to get station or groupe of station information and fill station vector
   !! information ( position, observation time, ...).
   SUBROUTINE read_obs_file

      implicit none

      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      type( vec2d )  ::  pt_temp(2)

      real(rp)  ::  length

      integer(ip)  ::  nb_rec , nb_pt , pt , search_nearest_cross_section , etq , cell

      logical  ::  point_in_cell

      character(len=8)  ::  typ

      !================================================================================================================!
      !  Beginning Treatment of File 'obs.txt'
      !================================================================================================================!

      backspace 10

      read(10,*) buffer , nb_rec

      select case( trim(buffer) )

         !=============================================================================================================!
         !  Stations at One Point Case
         !=============================================================================================================!

         case( 'stations' )

            call alloc_or_realloc_station( station , nb_obs + nb_rec )

            do iobs = nb_obs+1 , nb_obs+nb_rec

               !=======================================================================================================!
               !  Allocate Point Coordinate (only one in this case)
               !=======================================================================================================!

               allocate( station( iobs )%pt(1) )

               !=======================================================================================================!
               !  Reading Stations Informations in 'obs.txt' File
               !=======================================================================================================!
              
               read(10,*) station( iobs )%pt(1)%coord%x , &
                          station( iobs )%pt(1)%coord%y , &
                          station( iobs )%dt            , &
                          station( iobs )%weight

               !=======================================================================================================!
               !  Searching Cells for Stations
               !=======================================================================================================!

               station( iobs )%pt(1)%indexi = search_nearest_cross_section( mesh , station( iobs )%pt(1)%coord )

               !=======================================================================================================!
               !  Writing Ouput Files to Visualize Stations
               !=======================================================================================================!

               write(buffer,'(A,I4.4)') 'res/pos_station_', iobs

               call write_station_pos_in_file( buffer , station( iobs )%pt(1)%coord )

            end do

         !=============================================================================================================!
         !  Stations with a Group of Points Case
         !=============================================================================================================!

         case( 'stations_with_grp' )

            call alloc_or_realloc_station( station , nb_obs + nb_rec )

            do iobs = nb_obs+1 , nb_obs+nb_rec

               !=======================================================================================================!
               !  Reading Stations Informations in 'obs.txt' File
               !=======================================================================================================!

               read(10,*) etq , station( nb_obs + etq )%dt , station( nb_obs + etq )%weight

               if ((iobs - nb_obs) < 10000) then
                  write(buffer,'(A,I4.4,A)') 'station_grp_' , iobs - nb_obs , '.txt'
               else
                 write(buffer,'(A,I5.5,A)') 'station_grp_' , iobs - nb_obs , '.txt'
               end if

               nb_pt = count_lines( buffer ) - 1

               allocate( station( iobs )%pt( nb_pt ) )

               open(20,file=buffer,status='old',form='formatted')

               read(20,'(A)') typ

               do pt = 1,nb_pt

                  !====================================================================================================!
                  !  Reading Stations Informations in 'station_grp_xxxx.txt' File
                  !====================================================================================================!

                  if      ( trim(typ) == 'points' ) then

                     read(20,*) station( iobs )%pt( pt )%coord%x , &
                                station( iobs )%pt( pt )%coord%y

                     !=================================================================================================!
                     !  Searching Cells for Stations
                     !=================================================================================================!

                     station( iobs )%pt( pt )%indexi = search_nearest_cross_section( mesh , station( iobs )%pt( pt )%coord )

                  else if ( trim(typ) == 'indexes' ) then

                     read(20,*) station( iobs )%pt( pt )%indexi
                     
                     station( iobs )%pt( pt )%indexi=station( iobs )%pt( pt )%indexi+2 ! cell 1 -> cell 3

                  else

                     write(*,'(A50)')  'One station_grp_xxxx.txt file has a wrong header (points or indexes)' 

                  end if

 
               end do

               close(20)

            end do

         end select

         nb_obs = nb_obs + nb_rec

   END SUBROUTINE read_obs_file


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Reading Stations or Sections informations in obs.txt file and Creating associated structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>   Reading stations or sections informations in obs.txt file and creating associated structure
   !!
   !! \details This subroutine read the obs_stations.txt file to get stations information and fill vector of stations
   !! ( position, observation time, ...).
   SUBROUTINE read_obs_stations_file

      implicit none

      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      type( vec2d )  ::  pt_temp(2)

      real(rp)  ::  length

      integer(ip)  ::  nb_rec , nb_pt , pt , search_nearest_cross_section , etq , cell

      logical  ::  point_in_cell

      character(len=8)  ::  typ
      
      open(10,file='obs_stations.txt',form='formatted',status='old')
      
      !================================================================================================================!
      !  Skip header lines
      !================================================================================================================!
      
      read(10,*)
      read(10,*) 
      read(10,*) 

      !================================================================================================================!
      !  Read Number Of Stations
      !================================================================================================================!

      read(10,*) nb_rec

      call alloc_or_realloc_station( station , nb_obs + nb_rec )

      !================================================================================================================!
      !  Read Stations
      !================================================================================================================!

      do iobs = nb_obs+1 , nb_obs+nb_rec

         !=============================================================================================================!
         !  Allocate Point Coordinate (only one in this case)
         !=============================================================================================================!

         allocate( station( iobs )%pt(1) )

         !=============================================================================================================!
         !  Reading Stations Informations
         !=============================================================================================================!
        
         read(10,*) station( iobs )%pt(1)%coord%x , &
                    station( iobs )%pt(1)%coord%y , &
                    station( iobs )%dt_offset     , &
                    station( iobs )%dt            , &
                    station( iobs )%weight

         !=============================================================================================================!
         !  Searching Cells for Stations
         !=============================================================================================================!

         station( iobs )%pt(1)%indexi = search_nearest_cross_section( mesh , station( iobs )%pt(1)%coord )

         !=============================================================================================================!
         !  Writing Ouput Files to Visualize Stations
         !=============================================================================================================!

         write(buffer,'(A,I4.4)') 'res/pos_station_', iobs

         call write_station_pos_in_file( buffer , station( iobs )%pt(1)%coord )
                    
         !=============================================================================================================!
         !  Allocate stations dt_obs
         !=============================================================================================================!
         station(iobs)%nb_dt=int((ts- station(iobs)%dt_offset)/station(iobs)%dt)+1_ip
         
         allocate( station(iobs)%dt_obs(station(iobs)%nb_dt  ) ) 
            
         station(iobs)%dt_obs(1)=station(iobs)%dt_offset

         do i =2,station(iobs)%nb_dt
            station(iobs)%dt_obs(i) = station(iobs)%dt_obs(i-1) + station(iobs)%dt
         end do 

         station( iobs )%ind_t=1_ip
         
      end do

      nb_obs = nb_obs + nb_rec

   END SUBROUTINE read_obs_stations_file


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Reading Stations or Sections informations in obs.txt file and Creating associated structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>   Reading stations or sections informations in obs.txt file and creating associated structure
   !!
   !! \details This subroutine read the obs_groups.txt file to get stations information and fill vector of stations
   !! ( position, observation time, ...).
   SUBROUTINE read_obs_groups_file

      implicit none

      !================================================================================================================!
      !  Local Variables
      !================================================================================================================!

      type( vec2d )  ::  pt_temp(2)

      real(rp)  ::  length

      integer(ip)  ::  nb_rec , nb_pt , pt , search_nearest_cross_section , etq , cell

      logical  ::  point_in_cell

      character(len=8)  ::  typ
      
      open(10,file='obs_groups.txt',form='formatted',status='old')
      
      !================================================================================================================!
      !  Skip header lines
      !================================================================================================================!
      
      read(10,*)
      read(10,*) 
      read(10,*) 

      !================================================================================================================!
      !  Read Number Of Stations
      !================================================================================================================!

      read(10,*) nb_rec

      call alloc_or_realloc_station( station , nb_obs + nb_rec )

      !================================================================================================================!
      !  Read Stations
      !================================================================================================================!

      do iobs = nb_obs+1 , nb_obs+nb_rec

         !=============================================================================================================!
         !  Reading General informations
         !=============================================================================================================!
        
         read(10,*) station( iobs )%dt_offset     , &
                    station( iobs )%dt            , &
                    station( iobs )%weight

         !=============================================================================================================!
         !  Reading Points Informations
         !=============================================================================================================!
        
         read(10,*) nb_pt, typ

         !=============================================================================================================!
         !  Allocate Point Coordinates
         !=============================================================================================================!

         allocate( station( iobs )%pt(nb_pt) )

         do pt = 1,nb_pt

            !====================================================================================================!
            !  Reading Stations Informations in 'station_grp_xxxx.txt' File
            !====================================================================================================!

            if ( trim(typ) == 'points' ) then

               read(10,*) station( iobs )%pt( pt )%coord%x , &
                          station( iobs )%pt( pt )%coord%y

               !=================================================================================================!
               !  Searching Cells for Stations
               !=================================================================================================!

               station( iobs )%pt( pt )%indexi = search_nearest_cross_section( mesh , station( iobs )%pt( pt )%coord )

            else if ( trim(typ) == 'indexes' ) then

               read(10,*) station( iobs )%pt( pt )%indexi
                
               station( iobs )%pt( pt )%indexi = station( iobs )%pt( pt )%indexi + 2

            else

               write(*,'(A50)')  "Wrong type in file obs_groups.txt. Must be 'indexes' or 'points'"
               stop 2

            end if


         end do
                    
         !=============================================================================================================!
         !  Allocate stations dt_obs
         !=============================================================================================================!
         station(iobs)%nb_dt=int((ts- station(iobs)%dt_offset)/station(iobs)%dt)+1_ip
         
         allocate( station(iobs)%dt_obs(station(iobs)%nb_dt  ) ) 
            
         station(iobs)%dt_obs(1)=station(iobs)%dt_offset

         do i =2,station(iobs)%nb_dt
            station(iobs)%dt_obs(i) = station(iobs)%dt_obs(i-1) + station(iobs)%dt
         end do 

         station( iobs )%ind_t=1_ip
         
      end do

      nb_obs = nb_obs + nb_rec

   END SUBROUTINE read_obs_groups_file


   !>  Writing position of a station in file.
   !!
   !! \details This subroutine writes in some file 'file_name' the coordinates of the observation station.
   !! \param[in]  file_name Name of the output file.
   !! \param[in]  coord Coordinates ot the observation station.
   SUBROUTINE write_station_pos_in_file( file_name , coord )

      character(len=*), intent(in)  ::  file_name

      type( vec2d ), intent(in)  ::  coord

      buffer = file_name_ext( file_name, 'tecplot' )

      call system('mkdir -p res')

      open(100,file=buffer,status='replace',form='formatted')

      write(100,'(A)') 'TITLE = "DassFlow Station Position"'
      write(100,'(A)') 'VARIABLES = "x","y"'

      write(100,'(2ES15.7)') coord%x , coord%y

      close(100)


   END SUBROUTINE write_station_pos_in_file
   
   
   SUBROUTINE allocate_latflow(dof)

   IMPLICIT NONE
   
   TYPE( unk ), intent(inout)  ::  dof
   
   INTEGER :: space, times, nbtimesim
   CHARACTER(len=lchar) :: filename
   

   !===================================================================================================================
   ! Read first idlist.txt to get tQlat files names and space dimension
   !===================================================================================================================
   open(11,file='idlist.txt',status='old')
   
   read(11,*) space !number of x values
     allocate(bc%hyd_lat%id( space ))
     allocate(bc%hyd_lat%params(space , 3))
   do i = 1,space
     read(11,*) bc%hyd_lat%id( i ), bc%hyd_lat%params( i , : )
   end do
   close(11)

    !===================================================================================================================
    ! Read first tQlat file to get time dimension
    !===================================================================================================================
    
      filename = trim(bc%hyd_lat%id( 1 )) // '.txt'
       
       open(12,file=filename,status='old')
         read(12,*)
         read(12,*)
         read(12,*)
         read(12,*)        
         read(12,*) times !number of t values
        
       close(12)
! 
!    !===================================================================================================================
!    ! Allocate bc variables
!    !===================================================================================================================
! 
        allocate (bc%hyd_lat%x( space ))
        allocate( bc%hyd_lat%t( times ), bc%hyd_lat%q( space,times ))
        
        allocate(dof%qlat(2,space))
       
   END SUBROUTINE allocate_latflow
   
   SUBROUTINE read_qlatfiles(mesh)
   
   !===================================================================================================================!
   ! Global variables
   !===================================================================================================================!

   type( msh ), intent(in   )  ::  mesh

   !===================================================================================================================!
   ! Local variables
   !===================================================================================================================!
   
   character(len=lchar) :: filename
   integer :: loc
   real :: x
   integer :: times, space, nbtimesim

   !===================================================================================================================  
   ! Read t and Q from Qlat hydrographs
   !===================================================================================================================

    space = size(bc%hyd_lat%x)
    times = size(bc%hyd_lat%t)

    do i=1,space
!Spatial loop
      filename = trim(bc%hyd_lat%id( i )) // '.txt'

      open(13,file=filename,status='old')
        read(13,*)
        read(13,*)
        read(13,*)
        read(13,*) x
        
        bc%hyd_lat%x( i ) = x
        
        read(13,*) times
          
       !!! Read t, Q values
       do j = 1,times
!Time loop
          read(13,*) bc%hyd_lat%t( j ), bc%hyd_lat%q( i,j )
       end do 
!End time loop

      close(13)
      
    end do
!End spatial loop

    !===================================================================================================================  
    ! Calculate location of the inflows on the spatial grid (x in meters from bc%hyd_lat%x become cell indexes in bc%hyd_lat%loc
    !===================================================================================================================
    do i = 1,space

!Spatial loop
      loc = minloc(abs(mesh%CrossSection%coord%x - bc%hyd_lat%x( i )), 1) !!Find index of xsim closest to xdata (equivalent to ie in the euler_time_step_first scheme)

      !!! Change x to correspondong x in mesh
      if (bc%hyd_lat%x( i ) > mesh%CrossSection(loc)%coord%x) then
        bc%hyd_lat%x( i ) = mesh%CrossSection(loc+1)%coord%x
      else
        bc%hyd_lat%x( i ) = mesh%CrossSection(loc)%coord%x
      end if
      call AddToList(bc%hyd_lat%loc, loc)!Add loc value to unallocated list 

    end do 
!End spatial loop


    !===================================================================================================================  
    ! Initiate dof%qlat
    !===================================================================================================================

      dof%qlat(1,:)=bc%hyd_lat%q(:,1)
      dof%qlat(2,:)=dof%qlat(1,:)
      
!       print*,bc%hyd_lat%t
!        print*,bc%hyd_lat%x
!         print*,bc%hyd_lat%loc
!          print*,bc%hyd_lat%q
!           print*,dof%qlat


   END SUBROUTINE read_qlatfiles
   
END SUBROUTINE Initial
