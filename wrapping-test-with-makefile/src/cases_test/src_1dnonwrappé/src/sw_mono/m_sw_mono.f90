!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_sw_mono.f90
!! \brief This file includes m_model module.
!! \details The file includes only m_model module (see doc m_model module).


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module m_model
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_model.
!!
!! \details This module includes unk, bathy, flux, hydrograph, ratcurve, BC and stations definitions. 

MODULE m_model

   USE m_common
   USE m_linear_algebra
   USE m_mesh
   USE m_time_screen                                                                                              !NOADJ

   implicit none
   
   !===================================================================================================================!
   !  Discrete Model Unknows Structure
   !===================================================================================================================!

   !> Structure of unknowns.
   !!
   !! \details This structure include all unknows of models ( S, Q, h), thus the miss fit computed for velocity waves.
   TYPE unk

      real(rp), dimension(:), allocatable  ::  S   !< Values of the surface \f$S\f$.
      real(rp), dimension(:), allocatable  ::  Q   !< Values of the flow \f$Q\f$.
      real(rp), dimension(:), allocatable  ::  h   !< Values of the water height \f$h\f$.
      real(rp), dimension(:,:), allocatable  ::  qlat   !< Values of the lateral flow \f$Q\f$.
      real(rp), dimension(:), allocatable  ::  sf  !< Values of the friction term \f$S_f\f$.
      real(rp), dimension(:), allocatable  ::  sg  !< Values of the gravity term \f$S_g\f$.

   

   END TYPE unk


   real(rp) bathy_slopemean                                    !< mean slope of the canal riverbed
   real(rp), dimension(:), allocatable  ::  bathy_cell         !< Bathymetry at mesh cells gravity center.
   integer(ip) :: nb_bathy_control_pts

   real(rp), dimension(:), allocatable  ::  tflux1             !< Flux1 for finite volume scheme.

   real(rp), dimension(:), allocatable  ::  tflux2             !< Flux2 for finite volume scheme.

   real(rp), dimension(:), allocatable  ::  surfaceWidth       !< Surface width.

   real(rp), dimension(:), allocatable  :: hn, hc                  !< Normal depth, critical depth
   real(rp), dimension(:), allocatable  :: backwater                 !TMP
   
   !===================================================================================================================!
   !  Boundary Condition Structures
   !===================================================================================================================!

   !> Structure of timeseries.
   !!
   !! \details This structure is used for the definition of timeseries (i.e for each \f$t\f$, a \f$Y(t)\f$ is
   !! given.
   TYPE timeseries
      real(rp), dimension(:), allocatable  ::  t  !< Time array.
      real(rp), dimension(:), allocatable  ::  y  !< Flow array.
   END TYPE

   !> Structure of hydrograph.
   !!
   !! \details This structure is used for the definition of temporal hydrograph (i.e for each \f$t\f$, a \f$Q_{in}(t)\f$ is
   !! given.
   TYPE hydrograph
      real(rp), dimension(:), allocatable  ::  t  !< Time array.
      real(rp), dimension(:), allocatable  ::  q  !< Flow array.
   END TYPE

   !> Structure of Fourier series hydrograph.
   !!
   !! \details This structure is used for the definition of Fourier series hydrograph. Hydrograph is defined thus that
   !!
   !! \f$Q_{in}(t)=\frac{a_{0}}{2}+\sum_{n=1}^{N_{FS}}\left(a_{n}\cos(nt\frac{2\pi}{T})+b_{n}\sin(nt\frac{2\pi}{T})\right)\f$ 
   !! with \f$\{a_{0};a_{n},b_{n}\} \f$ , \f$n\in[1..N_{FS}]\f$, are the Fourier coefficients and \f$T\f$ is the total 
   !! simulation time. The lower frequency represented by the Fourier serie is \f$1/T\f$ and the highest one 
   !! is \f$N_{FS}/T\f$. 
   TYPE hydrograph_FS
   
      real(rp) :: a0                                  !< Variable \f$a_{0}\f$.
      real(rp), dimension(:), allocatable  ::  a      !< Variables \f$a_{i}\f$.
      real(rp), dimension(:), allocatable  ::  b      !< Variables \f$b_{i}\f$.
      integer(ip), dimension(:), allocatable  ::  n   !< Variable \f$N_{FS}\f$.
   END TYPE

   !> Structure of ratcurve
   !!
   !! \details This structure is used for the definition of ratcurve: \f$h(q)\f$.
   TYPE ratcurve
      real(rp), dimension(:), allocatable  ::  h !< Height variable.
      real(rp), dimension(:), allocatable  ::  q !< Flow variable.
   END TYPE

   TYPE hydrograph_qlat
      real(rp), dimension(:), allocatable  ::  t !< Time as read from text files
      real(rp), dimension(:), allocatable  ::  tsim !< Discretized time
      real(rp), dimension(:,:), allocatable  ::  q !< Lateral inflows as read from text files
      real(rp), dimension(:), allocatable  ::  qsim !< Lateral inflows discretized in time
      real(rp), dimension(:), allocatable  ::  x !< Abscisse of lateral inflows
      integer, dimension(:), allocatable  ::  loc !< Mesh index of lateral inflows
      character(25), dimension(:), allocatable  ::  id !< Name of text files
      real(rp), dimension(:,:), allocatable  ::  params !< Inversion parameters : sigma, mu, alpha_regul, read from idlist
   END TYPE   

   !> Structure of boundaries conditions
   !!
   !! \details This structure is used for the definition of boundaries conditions (type of hydrograph, of ratcurve, ...).
   TYPE bcs

      character(len=lchar) ::  typehyd !< Type of input hydrograph used: 'file_FS' for Fourier series definition
   !! or 'file' for temporal definition.
      
      character(len=lchar) ::  typerat !< Type of ratcurve used: 'file' for a definition \f$H(Q)\f$, else definition with
   !! \f$\alpha h ^{\beta}\f$.

      type(hydrograph) ::  hyd         !< Temporal hydrograph type.

      type(timeseries) ::  dsz         !< Time series of downstream elevations

      type(hydrograph_FS) ::  hyd_FS   !< Fourier Series hydrograph type.

      type(ratcurve) ::  rat           !< Ratcurve type.

      type(hydrograph_qlat) ::  hyd_lat         !< Temporal hydrograph type for lateral flow.
      
   END TYPE bcs

   type( bcs )  ::  bc                 !< Boundaries conditions definitions.

   !===================================================================================================================!
   !  Strickler (Manning in the code) coeff model parameters
   !===================================================================================================================!
   !> Structure of Strickler coeff
   !!
   !! \details This structure is used for the definition of K(x), the Strickler coefficient modeling the friction
   TYPE strickler_params
      integer(ip) :: nb_diff_K_reachs       !< nb of reachs along which the strickler params are constant
      integer(ip) :: nb_K_params            !< nb of parameters defining the Strickler coeff K
      integer(ip), dimension(:), allocatable :: cs_start, cs_end   !< start and end cross-sections of each separate reach with different Strickler parameters
      real(rp), dimension(:), allocatable :: alpha, beta        !< TEST : for now, the model is K(h,x)=alpha(x)*h^beta(x)
      real(rp), dimension(:, :), allocatable :: coeffs        !< TEST : for now, the model is K(h,x)=alpha(x)*h^beta(x)
   END TYPE strickler_params

   type( strickler_params ) :: K_params

   !==============================================================================================!
   !  Bathymetry points (for piecewise models)
   !==============================================================================================!
   integer(ip), dimension(:), allocatable  :: bathy_indices
   real(rp), dimension(:), allocatable  :: bathy_points

   !==============================================================================================!
   !  First guess of model parameters used as control in the DA process
   !==============================================================================================!
   real(rp), dimension(:), allocatable  :: bathy_cell_fg
   real(rp), dimension(:), allocatable  :: bathy_points_fg
   real(rp), dimension(:), allocatable :: alpha_K_fg
   real(rp), dimension(:), allocatable :: beta_K_fg
   real(rp), dimension(:), allocatable  :: qin_fg
   real(rp), dimension(:,:), allocatable  :: qlat_fg
   
   !==============================================================================================!
   !  Variables v, when the variable change v = Bdemi*(u-u_b) is used
   !==============================================================================================!
   ! /!\ For now, there are no cross-covariances (Bdemi is only block diagonal). 
   real(rp), dimension(:), allocatable  :: bathy_cell_chg
   real(rp), dimension(:), allocatable  :: bathy_points_chg
   real(rp), dimension(:), allocatable :: alpha_K_chg
   real(rp), dimension(:), allocatable :: beta_K_chg
   real(rp), dimension(:), allocatable  :: qin_chg 
   real(rp), dimension(:,:), allocatable  :: qlat_chg

   !==============================================================================================!
   !  Covariances matrices
   !==============================================================================================!

   ! Bdemi -> /!\ contain lower and upper triangular matrices from Cholesky decomposition
   ! So Bdemi*Bdemi != B, need to select only lower or upper half
      real(rp), dimension(:, :), allocatable  ::  Bdemi_hydrograph !< Block of \f$ B^{1/2} \f$ for the hydrograph.
      real(rp), dimension(:, :, :), allocatable  ::  Bdemi_hydrograph_lat !< Block of \f$ B^{1/2} \f$ for the lateral hydrograph.
   real(rp), dimension(:, :), allocatable  ::  Bdemi_bathy      !< Block of \f$ B^{1/2} \f$ for the bathymetry.
!!! TO DO, PAG clean this doublon
   real(rp), dimension(:), allocatable  ::  Bdemi_K_alpha    !< Block of \f$ B^{1/2} \f$ for alpha (just an array because we assume Bdemi is diagonal)
   real(rp), dimension(:), allocatable  ::  Bdemi_K_beta     !< Block of \f$ B^{1/2} \f$ for beta (just an array because we assume Bdemi is diagonal)
   real(rp), dimension(:,:), allocatable  ::  Bdemi_K_alpha_m    !< Block of \f$ B^{1/2} \f$ for alpha 
   real(rp), dimension(:,:), allocatable  ::  Bdemi_K_beta_m  !< Block of \f$ B^{1/2} \f$ for beta 



   ! Bdemi inv -> same remark as for Bdemi
   real(rp), dimension(:, :), allocatable  ::  Bdemi_hydro_inv !< Block of \f$ B^{-1/2} \f$ for the hydrograph.
   real(rp), dimension(:, :), allocatable  ::  Bdemi_bathy_inv      !< Block of \f$ B^{-1/2} \f$ for the bathymetry.
   
   !===================================================================================================================!
   !  Recording Structures
   !===================================================================================================================!
   !> Structure of stations.
   !!
   !! \details This structure is used for the definition of observation station. In this structure are defined lenght
   !! of the observation station, time step, weight, index observation time, ...

   TYPE station_obs

      type( point_in_mesh ), dimension(:), allocatable  ::  pt    !< Array of point in the mesh.

      real(rp)  :: weight                                !< Weight of observations.

      real(rp)  :: length                                !< Length of river.
      
      real(rp)  :: dt_offset                             !< Time of first observation (or offset).

      real(rp)  :: dt                                    !< Frequency of observation ( satellite time repetitiveness).

      real(rp),dimension(:), allocatable :: dt_obs       !< Array with observation time.

      integer(ip) :: ind_t                               !< Index observation time.

      integer(ip) :: nb_dt                               !< Number of observation time.

      real(rp), dimension(:), allocatable  ::  t         !< Time observation \f$T^{obs}\f$. 

      real(rp), dimension(:), allocatable  ::  h         !< Water height observed: \f$\bar{h}^{obs}\f$.

      real(rp), dimension(:), allocatable  ::  s         !< Surface observed: \f$\bar{S}^{obs}\f$.

      real(rp), dimension(:), allocatable  ::  q         !< Flow  observed: \f$\bar{Q}^{obs}\f$.

      real(rp), dimension(:), allocatable  ::  h_bathy   !< Water elevation observed: \f$\bar{H}^{obs}\f$.

      real(rp), dimension(:), allocatable  ::  w         !< surface width observed: \f$\bar{w}^{obs}\f$.

      real(rp), dimension(:), allocatable  ::  slope     !< surface slope observed


   END TYPE station_obs

   !===================================================================================================================!
   !  Recording Variables
   !===================================================================================================================!

   type( station_obs ), dimension(:), allocatable  ::  station !< Observation station definition.



   !===================================================================================================================!
   !  Input variables specific to model (in addition to m_common)
   !===================================================================================================================!
   
   character(len=lchar) :: crosssection_extrapolation !< Model for extrapolating above highest triplet (Z,W,Y)

   real(rp)     ::  g                                 !< Gravity constant \f$g\f$.
   real(rp)     ::  heps                              !< Minimal water depth.
   real(rp)     ::  qeps                              !< Minimal discharge.
   real(rp)     ::  theta_preissmann                   !< Implicit coefficient for the Preissmann scheme
   real(rp)     ::  alpha_eps                         !< Minimal friction coefficient.
   real(rp)     ::  beta_eps                          !< Minimal friction exponent.
   integer(ip)  ::  friction                          !< Activation of a Friction Law in Model.
   character(len=lchar)  :: K_model                   !< Choice of law for the Strickler coeff K

   integer(ip)  ::  c_manning                         !< Activation of Manning \f$K\f$ (if ==1) in the control vector 
!!\f$\mathbf{k}\f$. 
   integer(ip)  ::  c_bathy                           !< Activation of bathymetry \f$z_b\f$ (if ==1) in the control 
!!vector \f$\mathbf{k}\f$. 
   integer(ip)  ::  c_ic                              !< Activation of initiales conditions \f$S^0\f$ and \f$Q^0\f$ 
!! (if ==1) in the control vector \f$\mathbf{k}\f$. 
   integer(ip)  ::  c_hydrograph                      !< Activation of hydrograph \f$Q_{in}(t)\f$ in the control vector 
!! \f$\mathbf{k}\f$. 
!! - if ==1: Using of temporal form \f$Q_{in}(t^{i})\f$.
!! - if ==2: Using of Fourier series form \f$Q_{in}(t)=\frac{a_{0}}{2}+\sum_{n=1}^{N_{FS}}.
!! \left(a_{n}\cos(nt\frac{2\pi}{T})+b_{n}\sin(nt\frac{2\pi}{T})\right)\f$.

   integer(ip)  ::  c_ratcurve                        !< Activation of ratcurve \f$H_{out}(Q)\f$ in the control vector 
!!\f$\mathbf{k}\f$. 
!! - if ==1: Using of the tradional ratcurve \f$H_{out}=f(Q)\f$.
!! - if ==2: Using of the relation \f$H_{out}=\alpha Q ^{\beta}\f$.

   real(rp)     ::  alpha_lbound                      !< Lower bound for the Manning \f$\alpha\f$ \f$K=\alpha \dot h^{\beta}\f$.
   real(rp)     ::  alpha_ubound                      !< Upper bound for the Manning \f$\alpha\f$ \f$K=\alpha \dot h^{\beta}\f$.
   real(rp)     ::  beta_lbound                       !< Lower bound for the Manning \f$\beta\f$ \f$K=\alpha \dot h^{\beta}\f$.
   real(rp)     ::  beta_ubound                       !< Upper bound for the Manning \f$\beta\f$ \f$K=\alpha \dot h^{\beta}\f$.
   real(rp)     ::  bathy_lbound                      !< Lower bound for the bathymetry \f$z_b\f$.
   real(rp)     ::  bathy_ubound                      !< Upper bound for the bathymetry \f$z_b\f$.
   real(rp)     ::  bathy_delta                       !< Bounds interval around initial values for the bathymetry \f$z_b\f$.
   real(rp)     ::  hydrograph_lbound                 !< Lower bound for the hydrograph \f$Q_{in}(t)\f$.
   real(rp)     ::  hydrograph_ubound                 !< Upper bound for the hydrograph \f$Q_{in}(t)\f$.
   real(rp)     ::  alpha_ratcurve_lbound             !< Lower bound for the rating curve \f$\alpha\f$
   real(rp)     ::  alpha_ratcurve_ubound             !< Upper bound for the rating curve \f$\alpha\f$
   real(rp)     ::  beta_ratcurve_lbound              !< Lower bound for the rating curve \f$\alpha\f$
   real(rp)     ::  beta_ratcurve_ubound              !< Upper bound for the rating curve \f$\alpha\f$

   real(rp)     ::  eps_manning                       !< Value of \f$\epsilon\f$ in perturbation control vector 
!!\f$J(\mathbf{k}+\epsilon \delta \mathbf{k})\f$ for the Manning \f$K\f$.
   real(rp)     ::  eps_bathy                         !< Value of \f$\epsilon\f$ in perturbation control vector 
!!\f$J(\mathbf{k}+\epsilon \delta \mathbf{k})\f$ for the bathymetry \f$z_b\f$.
   real(rp)     ::  eps_ic                            !< Value of \f$\epsilon\f$ in perturbation control vector 
!!\f$J(\mathbf{k}+\epsilon \delta \mathbf{k})\f$ for the initiales conditions \f$S^0\f$ and \f$Q^0\f$.
   real(rp)     ::  eps_hydrograph                    !< Value of \f$\epsilon\f$ in perturbation control vector 
!!\f$J(\mathbf{k}+\epsilon \delta \mathbf{k})\f$ for the  hydrograph \f$Q_{in}(t)\f$.
   real(rp)     ::  eps_ratcurve                      !< Value of \f$\epsilon\f$ in perturbation control vector 
!!\f$J(\mathbf{k}+\epsilon \delta \mathbf{k})\f$ for the ratcurve \f$H_{out}(Q)\f$.

   character(len=lchar)  :: bathy_regul_type          !< Type of regularization for the bathymetry
   character(len=lchar)  :: strickler_regul_type      !< Type of regularization for the Strickler coefficient
   character(len=lchar)  :: hydro_regul_type          !< Type of regularization for the hydrogram
   character(len=lchar)  :: K_covariance              !< Type of regularization for K


   real(rp)     ::  regul_manning                     !< Weight of the Manning regularization term in the cost function.
   real(rp)     ::  regul_bathy                       !< Weight of the bathymetry regularization term in the 
! cost function.
   real(rp)     ::  regul_ic                          !< Weight of the initiales conditions regularization term in the 
! cost function.
   real(rp)     ::  regul_hydrograph, regul_hydrographlat                  !< Weight of the hydrograph regularization term in the 
! cost function.
   real(rp)     ::  regul_ratcurve                    !< Weight of the ratcurve regularization term in the
   real(rp)     ::  regul_gamma                      !< Factor for the computation of the iterative regularization alpha
   
   logical  ::  var_chg               !< if true, does the change of variables u = u_fg + Bdemi*v,
   logical :: norm_grad0
   ! where u_fg is the first guess, Bdemi is the square root of the background error cov matrix,
   ! u the model parameters and v the new variable
   
   integer(ip) :: run_status                          !< 0 is run is sucessful, negative otherwise

   integer(ip)  ::  fix_time_step_serie               !< Variable to fix the time step serie.

   character(len=lchar)  ::  bathymetry               !< Type of bathymetry model ('parametric', 'piecewise_constant', 'piecewise_linear')
   integer(ip)  ::  bathy_first, bathy_last, bathy_step
   real(rp)     ::  sigma_bathy, mu_bathy             !< Standard deviation and correlation length for the bathymetry.
   real(rp)     ::  sigma_alpha                       !< Standard deviation for the alpha manning.
   real(rp)     ::  sigma_beta                        !< Standard deviation for the beta manning.
   real(rp)     ::  mu_alpha,mu_beta                  !< correlation length for for the alpha manning and beta manning 
   real(rp)     ::  sigma_hydrograph, mu_hydrograph   !< Standard deviation and correlation length for the hydrograph.
   real(rp)     ::  sigma_hydrographlat, mu_hydrographlat   !< Standard deviation and correlation length for the hydrograph.
   
   
   real(rp)     ::  backwater_hmin, backwater_alpha
   real(rp)     ::  normal_depth_heps

   integer(ip)  ::  ite_period_alpha_reg_calc !< the minimization algo recomputes the regularization coeff alpha every ite_period_alpha_reg_calc iterations - if = 0 does not recompute alpha
   
   integer(ip)  ::  zb_cs_1, zb_cs_2
   
   ! BACKWARDS COMPATIBILITY
   real(rp) :: alpha, beta                             !< Constant in space Strikler terms
   character(len=lchar)  ::  regul_type               !< Type of regulation ('tikhonov_h0' only so far)
   
   
   integer :: debug_flag
   
   !===================================================================================================================!
   !  Input variables namelist (m_common + model specific upper ones)
   !===================================================================================================================!

   namelist/list_input/ &
      mesh_name,&
      crosssection_extrapolation,&
      remesh,&
      smooth,&
      addPointsW,&
      addPointsE,&
      post,&
      bc_W,&
      bc_E,&
      lat_inflow,&
      initialization, &
      backwater_hmin, & ! DEPRECATED ?
      backwater_alpha, & ! DEPRECATED ?
      normal_depth_heps, &
      bathymetry, &
      bathy_first, &
      bathy_last, &
      bathy_step, &
      w_exact,&
      ts,&
      dtw,&
      dtp,&
      dta,&
      spatial_scheme, &
      theta_preissmann, &
      dt,&
      adapt_dt,&
      cfl,&
      friction,&
      K_model,&
      alpha_ratcurve,&
      beta_ratcurve,&
      w_froude,&
      steady_state,&
      eps_q_steady_state,&
      eps_s_steady_state,&
      g,&
      heps, &
      qeps, &
      alpha_eps, &
      beta_eps,&
      Qinterface, &
      w_obs,&
      use_obs,&
      eps_min,&
      eps_morozov,&
      c_manning, &
      c_bathy, &
      c_ic, &
      c_hydrograph, &
      c_ratcurve, &
      

      zb_cs_1, &
      zb_cs_2, &
      
      alpha_lbound,&
      alpha_ubound,&
      beta_lbound,&
      beta_ubound,&
      bathy_lbound,&
      bathy_ubound,&
      bathy_delta,&
      hydrograph_lbound,&
      hydrograph_ubound,&
      alpha_ratcurve_lbound,&
      alpha_ratcurve_ubound,&
      beta_ratcurve_lbound,&
      beta_ratcurve_ubound,&

      eps_manning, &
      eps_bathy, &
      eps_ic, &
      eps_hydrograph, &
      eps_ratcurve, &

      regul_manning, &
      regul_bathy, &
      regul_ic, &
      regul_hydrograph, &
      regul_ratcurve, &
      var_chg, &
      norm_grad0, &

      strickler_regul_type,&
      bathy_regul_type, &
      hydro_regul_type, &
      K_covariance,&
      
      sigma_bathy, &
      mu_bathy, &
      sigma_alpha, &
      sigma_beta, &
      mu_alpha, &
      mu_beta, &
      sigma_hydrograph, &
      mu_hydrograph, &
      sigma_hydrographlat, &
      mu_hydrographlat, &

      ite_period_alpha_reg_calc, &
      regul_gamma, &
      
      ! BACKWARDS COMPATIBILITY
      alpha, &
      beta, &
      regul_type
      
CONTAINS


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Default values for Input variables namelist
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
   
   !> Default values for input variables namelist.
   !!
   !! \details This subroutine fixes a set of default values if users has not precise this values in the input.txt
   !! files. For example, these values are the time step, scheme, value of friction, \f$\alpha\f$, \f$\beta\f$,...
   SUBROUTINE Default_values

      mesh_name = 'mesh.geo'
      crosssection_extrapolation = "linear_builtin1"
      bc_W = 'Wall'
      bc_E = 'Wall'
      lat_inflow = '0'
      ts = 14400._rp
      dtw = 3600._rp
      dtp = 60._rp
      dta = 60._rp
      dt = 1._rp
      adapt_dt = 0
      cfl = 0.8_rp
      spatial_scheme = 'euler_first'
      theta_preissmann = 0.667
      g = 9.81_rp
      heps = 0.01_rp
      qeps = 0.1_rp
      alpha_eps = 0.1_rp 
      beta_eps = 0.1_rp
      friction = 1
      K_model = 'K(h)'
      alpha_ratcurve = 0._rp
      beta_ratcurve  = 0._rp
      w_obs = 0
      use_obs = 0
      w_froude = 1
      steady_state = 0
      eps_q_steady_state= 1e-5_rp
      eps_s_steady_state= 1e-5_rp

      c_manning =  0
      c_bathy =  0
      c_ic =  0
      c_hydrograph =  0
      c_ratcurve =  0

      alpha_lbound =  0.0
      alpha_ubound =  50.0
      beta_lbound =  minfm
      beta_ubound =  pinfm
      bathy_lbound =  minfm
      bathy_ubound =  minfm
      bathy_delta =  -minfm
      hydrograph_lbound =  0.0
      hydrograph_ubound =  10000.0
      alpha_ratcurve_lbound =  minfm
      alpha_ratcurve_ubound =  pinfm
      beta_ratcurve_lbound  =  minfm
      beta_ratcurve_ubound  =  pinfm


      eps_manning =  0.1_rp
      eps_bathy =  0.1_rp
      eps_ic =  0.1_rp
      eps_hydrograph  =  0.1_rp
      eps_ratcurve =  0.1_rp
      eps_min = 1e-6_rp
      eps_morozov = 1e-8_rp

      strickler_regul_type = 'bayes'
      regul_manning =  0._rp
      K_covariance= 'constant_K_covariance'
      
      bathy_regul_type = 'bayes'
      regul_bathy =  0._rp
      regul_gamma =  0._rp
      
      regul_ic =  0._rp

      hydro_regul_type = 'bayes'
      regul_hydrograph  =  0._rp
      
      regul_ratcurve    =  0._rp

      ite_period_alpha_reg_calc = 0_ip

      
      sigma_bathy = 0.1_rp
      mu_bathy = 1000.0_rp !1000.0_rp
      
      sigma_alpha = 0.1_rp
      sigma_beta = 0.1_rp
      mu_alpha = 1000.0_rp
      mu_beta = 1000.0_rp
      
      sigma_hydrograph = 0.1_rp
      mu_hydrograph = 3600.0_rp
      
      sigma_hydrographlat = 0.1_rp
      mu_hydrographlat = 3600.0_rp
      
      initialization    ='surface'
      bathymetry        ='parametric'
      
      var_chg = .true.
      norm_grad0 = .false.
      
      bathy_first =1
      bathy_last =-1
      bathy_step =1
      normal_depth_heps = 0.5_rp
      backwater_hmin  = -1.0_rp
      backwater_alpha = 1.1_rp
      Qinterface        = 0

      inquire( iolength = length_real ) tc

      max_nt_for_direct   =  100000000
      fix_time_step_serie  =  0

      ! BACKWARDS COMPATIBILITY
      alpha = -9999.0_rp
      beta = -9999.0_rp
      regul_type = ""
      
      debug_flag = 0
   

   END SUBROUTINE Default_values


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Allocation of Model unk
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Allocation of memory space for the unknowns of the model.
   !!
   !! \details This subroutine allocate space for the unknowns of the model (\f$h\f$,\f$S\f$ and \f$Q\f$).
   !! \f$S_g\f$ and \f$S_f\f$ are computed in this vector too. 
   !! \param[out] dof Unknowns of the model.
   !! \param[in] mesh Geometry of the model.
   SUBROUTINE alloc_dof( dof , mesh )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( msh ), intent(in )  ::  mesh
      type( unk ), intent(out)  ::  dof

      !================================================================================================================!
      !
      !================================================================================================================!

      allocate( dof%Q   ( mesh%ncs+4 ) )
      allocate( dof%S   ( mesh%ncs+4 ) )
      allocate( dof%h   ( mesh%ncs+4 ) )
      allocate( dof%sg  ( mesh%ncs+4 ) )
      allocate( dof%sf  ( mesh%ncs+4 ) )



      dof%Q    (:)  =  0._rp
      dof%S    (:)  =  0._rp
      dof%h    (:)  =  0._rp
      dof%Sg   (:)  =  0._rp
      dof%Sf   (:)  =  0._rp
   END SUBROUTINE alloc_dof


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Deallocation of Model unk
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Deallocation of memory space for the unknowns of the model.
   !!
   !! \details This subroutine deallocate space for the unknowns of the model (\f$h\f$,\f$S\f$ and \f$Q\f$).
   !! \f$S_g\f$ and \f$S_f\f$ are computed in this vector too. 
   !! \param[inout] dof Unknowns of the model.
   SUBROUTINE dealloc_dof( dof )

      implicit none

      !================================================================================================================!
      !  Interface Variables
      !================================================================================================================!

      type( unk ), intent(inout)  ::  dof

      !================================================================================================================!
      !
      !================================================================================================================!
      if ( allocated( dof%q    ) ) deallocate( dof%q    )
      if ( allocated( dof%s    ) ) deallocate( dof%s    )
      if ( allocated( dof%h    ) ) deallocate( dof%h    )
      if ( allocated( dof%sg   ) ) deallocate( dof%sg  )
      if ( allocated( dof%sf   ) ) deallocate( dof%sf  )

   END SUBROUTINE dealloc_dof


   !> Deallocation of memory space for the variables model.
   !!
   !! \details This subroutine deallocate space for the differents variables used in the model (transitional fluxes 
   !! for the model) and bathymetry.
   SUBROUTINE dealloc_model

      implicit none

      if ( allocated( bathy_cell ) ) deallocate( bathy_cell )
      if ( allocated( tflux1 ) ) deallocate( tflux1 )
      if ( allocated( tflux2 ) ) deallocate( tflux2 )

   END SUBROUTINE dealloc_model


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Allocation or Reallocate Stations Type
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
  
   !> Allocation or Reallocate Stations Type.
   !!
   !! \details Allocate memory for the creation of the observation station if the station_inout is not allocated. If
   !! the station_inout is already allocated, reallocate the memory of the observation station.
   !! \param[inout] station_inout Array of station (type station_obs)
   !! \param[in] new Number of new station
   SUBROUTINE alloc_or_realloc_station( station_inout , new )

      implicit none

      type( station_obs ), dimension(:), allocatable, intent(inout)  ::  station_inout

      integer(ip), intent(in)  ::  new

      integer(ip)  ::  old , iobs , pt

      type( station_obs ), dimension(:), allocatable  ::  station_tmp

      intrinsic move_alloc

      if ( .not. allocated( station_inout ) ) then

         allocate( station_inout( new ) )

         return

      end if

      old = size( station_inout )

      if     ( new == old ) then

         return

      else if ( new > old ) then

         allocate( station_tmp( new ) )

         do iobs = 1,old

            station_tmp( iobs )%dt      =  station_inout( iobs )%dt
            station_tmp( iobs )%weight  =  station_inout( iobs )%weight

            allocate( station_tmp( iobs )%pt( size(station_inout( iobs )%pt ) ) )

            do pt = 1,size( station_inout( iobs )%pt )

               station_tmp( iobs )%pt( pt )%indexi   =  station_inout( iobs )%pt( pt )%indexi
               station_tmp( iobs )%pt( pt )%coord  =  station_inout( iobs )%pt( pt )%coord

            end do

         end do

         call move_alloc( station_tmp , station_inout )

      else

         write(*,'(A50)')  'Wrong Station Dimension for Allocation'

      end if

   END SUBROUTINE alloc_or_realloc_station
   
   

   SUBROUTINE AddToList(list, element)

	      IMPLICIT NONE

	      integer :: n, nsize
	      integer, intent(in) :: element
	      integer, dimension(:), allocatable, intent(inout) :: list
	      integer, dimension(:), allocatable :: clist

	      if(allocated(list)) then
	      
		  nsize = size(list)
		  allocate(clist(nsize+1))
		  do n=1,nsize          
		  clist(n) = list(n)
		  end do
		  clist(nsize+1) = element

		  deallocate(list)
		  call move_alloc(clist, list)

	      else
		  allocate(list(1))
		  list(1) = element
	      end if


   END SUBROUTINE AddToList
   
   SUBROUTINE AddArrayToArray(list, element)

	      IMPLICIT NONE

	      integer :: n, m
	      integer, dimension(2) :: nsize
	      real(rp), dimension(:), intent(in) :: element
	      real(rp), dimension(:,:), allocatable, intent(inout) :: list
	      real(rp), dimension(:,:), allocatable :: clist    

	      if(allocated(list)) then
		  nsize = shape(list)
		  allocate(clist(nsize(1)+1,nsize(2)))

		  do n=1,nsize(1) 
		    do m=1,nsize(2)
		    clist(n,m) = list(n,m)
		    enddo
		  enddo

		  do m=1,nsize(2)
		  clist(nsize(1)+1,m) = element(m)
		  enddo
		  deallocate(list)
		  nsize = shape(clist)
		  allocate(list(nsize(1), nsize(2)))
		  list = clist


	      end if

   END SUBROUTINE AddArrayToArray
   


END MODULE m_model
