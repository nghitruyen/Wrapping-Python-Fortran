!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file read_write_obs.f90
!! \brief This file includes routines of creation of ouput observation file and cost function computation.


! #define WRITE_INFO_SUP


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Fill during simulation the Innovation Vector to compute at end the Cost Function
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Fill during simulation the Innovation Vector to compute at end the Cost Function.  
!!
!! \details This subroutine compute the innovation vector. The innovation vector corresponds to the difference between
!! observed data and computed data.
!!
!! \param[in]  dof Unknowns of the model.
SUBROUTINE calc_innovation( dof )

   USE m_common
   USE m_model
   USE m_obs

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   type( unk ), intent(in)  ::  dof

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   integer(ip)  ::  cell , searched_time , pt

   !CHANGE_COST s_mean -> h_mean
   !            dof%s  -> dof%s
   real(rp)  ::  h_mean,h_bathy_mean,q_mean

   !===================================================================================================================!
   !  Begin
   !===================================================================================================================!

   iobs=1

   do iobs = 1,size( station )
      
 
      searched_time  =  innovation( iobs )%ind_t
#ifdef DEBUG_L3
      print *, "station( iobs )%t( searched_time )=", iobs, searched_time, tc, station( iobs )%t( searched_time )
      read(*,*)
#endif
 
      if ( searched_time > innovation( iobs )%nb_dt ) cycle

 
      if ( tc > station( iobs )%t( searched_time ) - 0.1 * dt ) then
      
#ifdef DEBUG_L3
        print *, "passed!", tc, station( iobs )%t( searched_time )
        if (iobs == 1) read(*,*)
#endif

         h_mean = 0._rp
         h_bathy_mean = 0._rp
         q_mean = 0._rp

         do pt = 1,size( station( iobs )%pt )

            cell = station( iobs )%pt( pt )%indexi

            if ( cell < 0 ) cycle

            h_mean = h_mean + dof%h( cell ) 
            h_bathy_mean = h_bathy_mean + dof%h( cell ) + bathy_cell(cell)
            q_mean = q_mean + dof%q( cell) 

         end do

         
         h_mean = h_mean / real( size( station( iobs )%pt ) , 8 )
         h_bathy_mean = h_bathy_mean / real( size( station( iobs )%pt ) , 8 )
         q_mean=  q_mean /real(size(station(iobs)%pt),8)

         !innovation( iobs )%diff( searched_time )  =  (h_mean - station( iobs )%h( searched_time )) &
         !                                           + (q_mean - station( iobs )%q( searched_time ))
         !innovation( iobs )%diff( searched_time )  =  h_mean - station( iobs )%h_bathy( searched_time )
         !innovation(iobs)%diff(searched_time )  =  (q_mean - station( iobs )%q( searched_time ))+(

!          innovation( iobs )%diff( searched_time )  =  (h_mean - station( iobs )%h( searched_time ))
         if (station( iobs )%h_bathy( searched_time ) > -1e+12) then
            innovation( iobs )%diff( searched_time )  =  (h_bathy_mean - station( iobs )%h_bathy( searched_time ))
         
#ifdef DEBUG
            if (innovation( iobs )%diff( searched_time ) > 1e+12) then
               print *, "innovation !!", iobs, searched_time, h_bathy_mean, station( iobs )%h_bathy( searched_time )
               read(*,*)
            end if
#endif

         else

            innovation( iobs )%diff( searched_time )  =  0.0_rp
            
         end if

         innovation( iobs )%ind_t  =  innovation( iobs )%ind_t + 1

      end if

   end do

END SUBROUTINE calc_innovation
                                                                                                                 !<NOADJ

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Stations Output
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Stations Output 
!!
!! \details This subroutine is the main stations output subroutine. 
!!
!! \param[in] dof Unknowns of the model.
!! \param[in] mesh Mesh of the model.
SUBROUTINE write_stations( dof, mesh )

   USE m_common
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   type( unk ), intent(in)  ::  dof
   type( msh ), intent(in ) :: mesh

   !===================================================================================================================!
   !  Writing Stations Records in File
   !===================================================================================================================!
   
   
   if ( .not. allocated( station ) .or. w_obs /= 1 ) return
   
!    print *, "write_stations:", allocated( station ), w_obs
   call sub_write( 'gnuplot' ) ; return


   CONTAINS


      !> Stations Output in '.dat' format reading by python script.
      !!
      !! \details This subroutine writes the observation done from computation in the result file '/res/obs_station_XX'
      !! This observation are then used to the computation of the cost function.
      !!
      !! \param[in]  file_type  Type of the file ( not used).
      SUBROUTINE sub_write( file_type )

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         character(len=*), intent(in)  ::  file_type

         !=============================================================================================================!
         !  Local Variables
         !=============================================================================================================!

         character(len=lchar)  ::  file_name

         integer(ip)  ::  iobs , cell , pt,searched_time

         real(rp)  ::  h_mean , s_mean, q_mean, h_bathy_mean, w_mean, slope_mean

         real(rp) :: GetWFromH

         !************
         !    Temp 
         !************
         real(rp)  :: minumc, maxumc, meanumc 

         real(rp)  :: minupc, maxupc, meanupc

         real(rp)  :: minu, maxu, meanu

         real(rp)  :: minsg , maxsg , meansg   

         real(rp)  :: minsf , maxsf , meansf   

         real(rp)  :: temp , u , c

         !**************
         !   End temp
         !**************

         !=============================================================================================================!
         !  Begin Subroutine
         !=============================================================================================================!

         do iobs = 1,size( station )
            !==========================================================================================================!
            !  Testing if Simulation Time match with Observation Time Step
            !==========================================================================================================!
            
            !if ( .not. test_dt_just_after( station( iobs )%dt ) ) cycle

!             write(*,*) 'iobs' , iobs

            searched_time  =  station( iobs )%ind_t
!             write(*,*) 'searched_time' , searched_time, station( iobs )%nb_dt
!             write(*,*) 'tc' , tc, station( iobs )%dt_obs( searched_time ); read(*,*)
            
            if ( searched_time > station( iobs )%nb_dt ) cycle

            if ( tc >= station( iobs )%dt_obs( searched_time ) - 0.1 * dt ) then     
               !==========================================================================================================!
               !  Creating File Name
               !==========================================================================================================!
               if (iobs < 10000) then
                  write(file_name,'(A,"_",I4.4)') 'res/obs_station' , iobs
               else
                  write(file_name,'(A,"_",I5.5)') 'res/obs_station' , iobs
               end if

               file_name = file_name_ext( file_name , file_type )

               !==========================================================================================================!
               !
               !==========================================================================================================!

               if ( station( iobs )%pt(1)%indexi > 0 .and. all( is_file_open(:) /= file_name ) ) then

                  inquire( file = file_name , exist = file_exist(1) )

                  if ( .not. file_exist(1) ) then

                     open(10,file=file_name,status='replace',form='formatted')
            
                     write(10,'(A)') '#  time | h (depth) | S | Q | H (elevation) | w (surface width) | slope'

                  end if

                  close(10)

                  file_open_counter = file_open_counter + 1

                  is_file_open( file_open_counter ) = file_name

               end if

               !==========================================================================================================!
               !
               !==========================================================================================================!

               h_mean       = 0._rp
               s_mean       = 0._rp
               q_mean       = 0._rp
               h_bathy_mean = 0._rp
               w_mean       = 0._rp
               slope_mean   = 0._rp

               do pt = 1,size( station( iobs )%pt )

                  cell = station( iobs )%pt( pt )%indexi

                  if ( cell < 0 ) cycle

                  h_mean      = h_mean       + dof%h( cell )
                  s_mean      = s_mean       + dof%s( cell )
                  q_mean      = q_mean       + dof%q( cell )
                  h_bathy_mean= h_bathy_mean + dof%h( cell )+bathy_cell( cell )
                  w_mean      = w_mean       + GetWFromH(mesh, dof%h( cell ), cell)
                  if ( cell==3 ) then
                     slope_mean  = slope_mean + (dof%h( cell )+bathy_cell( cell ) - dof%h( cell+1 )-bathy_cell( cell+1 ))/&
                          mesh%crosssection(cell+1)%deltademi
                  else if ( cell == mesh%ncs+2) then
                     slope_mean  = slope_mean + (dof%h( cell-1 )+bathy_cell( cell-1 ) - dof%h( cell )-bathy_cell( cell ))/&
                      mesh%crosssection(cell)%deltademi
                  else
                     slope_mean  = slope_mean   + (dof%h( cell-1 )+bathy_cell( cell-1 ) - dof%h( cell+1 )-bathy_cell( cell+1 ))/&
                          (mesh%crosssection(cell)%deltademi+mesh%crosssection(cell+1)%deltademi)                                ! slope = (h_{n-1} - h_{n+1})/(2*dx)
                  end if
          
               end do

               if ( slope_mean < 0 ) then
                 ! print *, '/!\ Slope < 0 for station nb', iobs
               end if
               h_mean       = h_mean       / real( size( station( iobs )%pt ) , 8 )
               s_mean       = s_mean       / real( size( station( iobs )%pt ) , 8 )
               q_mean       = q_mean       / real( size( station( iobs )%pt ) , 8 )
               h_bathy_mean = h_bathy_mean / real( size( station( iobs )%pt ) , 8 )
               w_mean       = w_mean       / real( size( station( iobs )%pt ) , 8 )
               slope_mean   = slope_mean   / real( size( station( iobs )%pt ) , 8 )
               
               if ( station( iobs )%pt(1)%indexi > 0 ) then

                  open(10,file=file_name,status='old',position='append',form='formatted')

                  write(10,'(7ES23.15)') tc , h_mean , s_mean , q_mean, h_bathy_mean, w_mean, slope_mean

                  
                  close(10)

               end if
            

               !station( iobs )%ind_t= station( iobs )%ind_t
               station( iobs )%ind_t= station( iobs )%ind_t+1
         
            end if 
         end do


#ifdef WRITE_INFO_SUP
         !**************************************************************************************************************
         !******************                                Temporaire                                ******************
         !**************************************************************************************************************
         !=============================================================================================================!
         !  Write info sup 
         !=============================================================================================================!
         do  iobs = 1,size( station )
            searched_time  =  station( iobs )%ind_t

            if ( searched_time > station( iobs )%nb_dt ) cycle

            if ( tc >= station( iobs )%dt_obs( searched_time ) ) then     

               !==========================================================================================================!
               !  Creating File Name
               !==========================================================================================================!

               if (iobs < 10000) then
                  write(file_name,'(A,"_",I4.4)') 'res/obs_station_sup' , iobs
               else
                  write(file_name,'(A,"_",I5.5)') 'res/obs_station_sup' , iobs
               end if

               file_name = file_name_ext( file_name , file_type )

               !==========================================================================================================!
               !
               !==========================================================================================================!

               if ( station( iobs )%pt(1)%indexi > 0 .and. all( is_file_open(:) /= file_name ) ) then

                  inquire( file = file_name , exist = file_exist(1) )

                  if ( .not. file_exist(1) ) then

                     open(10,file=file_name,status='replace',form='formatted')
            
                     write(10,'(A)') '# time, minumc, maxumc, meanumc, minupc, maxupc, meanupc, ...'

                  end if

                  close(10)

                  file_open_counter = file_open_counter + 1

                  is_file_open( file_open_counter ) = file_name

               end if

               !==========================================================================================================!
               !
               !==========================================================================================================!


               cell  = station( iobs )%pt(1)%indexi
               u     = dof%q(cell)/dof%s(cell)
               c     = sqrt(g*dof%h(cell))

               minumc  = abs(u-c) 
               maxumc  = abs(u-c)
               meanumc = 0._rp

               minupc  = abs(u+c)  
               maxupc  = abs(u+c) 
               meanupc = 0._rp 

               minsg   = abs(dof%sg(cell))
               maxsg   = abs(dof%sg(cell)) 
               meansg  = 0._rp 

               minsf   = abs(dof%sf(cell))
               maxsf   = abs(dof%sf(cell)) 
               meansf  = 0._rp   


               minu    = abs(u) 
               maxu    = abs(u)
               meanu = 0._rp

               do pt = 1,size( station( iobs )%pt )

                  cell = station( iobs )%pt( pt )%indexi


                  u     = dof%q(cell)/dof%s(cell)
                  c     = sqrt(g*dof%h(cell))

                  if ( cell < 0 ) cycle

                  ! Computing min(|u-c|) , max(|u-c|) , mean(|u-c|)
                  temp=abs(u-c)
                  if (temp<minumc) then
                     minumc=temp
                  end if
                  if (temp>maxumc) then
                     maxumc=temp
                  end if
                  meanumc=meanumc+temp

                  ! Computing min(|u+c|) , max(|u+c|) , mean(|u+c|)
                  temp=abs(u+c)
                  if (temp<minupc) then
                     minupc=temp
                  end if
                  if (temp>maxupc) then
                     maxupc=temp
                  end if
                  meanupc=meanupc+temp

                  ! Computing min(|sg|) , max(|sg|) , mean(|sg|)
                  temp=abs(dof%sg(cell))
                  if (temp<minsg) then
                     minsg=temp
                  end if
                  if (temp>maxsg) then
                     maxsg=temp
                  end if
                  meansg=meansg+temp

                  ! Computing min(|sf|) , max(|sf|) , mean(|sf|)
                  temp=abs(dof%sf(cell))
                  if (temp<minsf) then
                     minsf=temp
                  end if
                  if (temp>maxsf) then
                     maxsf=temp
                  end if
                  meansf=meansf+ dof%sf(cell)+dof%sg(cell)


                  ! Computing min(|u|) , max(|u|) , mean(|u|)
                  temp=abs(u)
                  if (temp<minu) then
                     minu=temp
                  end if
                  if (temp>maxu) then
                     maxu=temp
                  end if
                  meanu=meanu+temp


               end do

               meanumc = meanumc/real( size( station( iobs )%pt ) , 8 )
               meanupc = meanupc/real( size( station( iobs )%pt ) , 8 )
               meansg  = meansg /real( size( station( iobs )%pt ) , 8 )
               meansf  = meansf /real( size( station( iobs )%pt ) , 8 )
               meanu   = meanu  /real( size( station( iobs )%pt ) , 8 )

               if ( station( iobs )%pt(1)%indexi > 0 ) then

                  open(10,file=file_name,status='old',position='append',form='formatted')

                  write(10,'(16ES23.15)') tc ,&
                                         minumc, maxumc, meanumc , & 
                                         minupc, maxupc, meanupc , &
                                         minsg , maxsg , meansg  , & 
                                         minsf , maxsf , meansf  , & 
                                         minu  , maxu  , meanu   
                  close(10)

               end if
            
               if (.not. use_obs == 1) station( iobs )%ind_t= station( iobs )%ind_t+1
!                station
         
            end if 
         

         end do
         !**************************************************************************************************************
         !******************                              Fin  Temporaire                             ******************
         !**************************************************************************************************************
#endif         

      END SUBROUTINE sub_write


END SUBROUTINE write_stations


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Stations Input
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Stations Input 
!!
!! \details This subroutine is the main stations input subroutine. 
!!
SUBROUTINE read_stations

   USE m_common
   USE m_mesh
   USE m_obs
   USE m_model

   implicit none

   !===================================================================================================================!
   !  Reading Stations Records in File
   !===================================================================================================================!

   call sub_read( 'gnuplot' ) ; return



   CONTAINS

      !> Stations input in '.dat' format reading by python script.
      !!
      !! \details This subroutine reads the observation done from computation in the result file '/res/obs_station_XX'
      !! This observation are then used to the computation of the cost function.
      !!
      !! \param[in]  file_type  Type of the file (not used).
      SUBROUTINE sub_read( file_type )

         !=============================================================================================================!
         !  Interface Variables
         !=============================================================================================================!

         character(len=*), intent(in)  ::  file_type

         !=============================================================================================================!
         !  Local Variables
         !=============================================================================================================!

         character(len=lchar)  ::  file_name

         integer(ip)  ::  iobs , nbdt_obs , dt_obs , icod

         !=============================================================================================================!
         !  Begin Subroutine
         !=============================================================================================================!

         iobs = 0

         do

            !==========================================================================================================!
            !
            !==========================================================================================================!

            iobs = iobs + 1
            
            if (iobs < 10000) then
            
               write(file_name,'(A,"_",I4.4)') 'obs/obs_station' , iobs
               
            else
            
               write(file_name,'(A,"_",I5.5)') 'obs/obs_station' , iobs
               
            end if

            file_name = file_name_ext( file_name , file_type )

            !==========================================================================================================!
            !
            !==========================================================================================================!

            inquire( file = file_name , exist = file_exist(1) )

            if ( .not. file_exist(1) ) then

               exit

            else if ( iobs > size( station ) ) then

               write(*, '(A50)')  'Mismatch between the number of files in obs directory and obs.txt file' 

            end if

            !if ( file_type /= 'bin' ) then


               !=======================================================================================================!
               !
               !=======================================================================================================!

               nbdt_obs = count_lines( file_name ) - 1
               allocate( station( iobs )%t      ( nbdt_obs ) )
               allocate( station( iobs )%h      ( nbdt_obs ) )
               allocate( station( iobs )%s      ( nbdt_obs ) )
               allocate( station( iobs )%q      ( nbdt_obs ) )
               allocate( station( iobs )%h_bathy( nbdt_obs ) )
               allocate( station( iobs )%w      ( nbdt_obs ) )
               allocate( station( iobs )%slope  ( nbdt_obs ) )

               !=======================================================================================================!
               !
               !=======================================================================================================!

               open(10,file=file_name,status='old',form='formatted')
               read(10,*)
               do dt_obs = 1,nbdt_obs
                  read(10,*) station( iobs )%t      ( dt_obs ) , &
                             station( iobs )%h      ( dt_obs ) , &
                             station( iobs )%s      ( dt_obs ) , &
                             station( iobs )%q      ( dt_obs ) , &
                             station( iobs )%h_bathy( dt_obs ) , &
                             station( iobs )%w      ( dt_obs ) , &
                             station( iobs )%slope  ( dt_obs ) 

               end do

               close(10)

         end do

      END SUBROUTINE sub_read


END SUBROUTINE read_stations                                                                                      !>NOADJ

