!#define PROFILING
!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file run_model_sw_mono.f90
!! \brief This file includes routines to run a shallow water simulation.


!> Main Routine to run a Shallow-Water simulation
!!
!! \details This subroutine launches the simulation and control iteration, if the end_time_loop is true, the
!! computation is stopped.
!!
!! \param[in]  mesh Mesh of the model.
!! \param[in]  dof0 Initial condition of the model.
!! \param[inout]  dof Unknowns of the model.
!! \param[out]  cost Value of the cost function.
SUBROUTINE run_model( mesh , dof0 , dof , cost )
  
   USE m_common
   USE m_linear_algebra
   USE m_mesh
   USE m_time_screen                                     !NOADJ
   USE m_numeric
   USE m_model
   USE m_obs

   implicit none
   
   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   type( msh ), intent(in   )  ::  mesh
   type( unk ), intent(inout)  ::  dof0
   type( unk ), intent(inout)  ::  dof

   real(rp), dimension(mesh%ncs+4 )  ::  sfterm  
   real(rp), dimension(mesh%ncs+4 )  ::  sgterm

   real(rp), intent(out)  ::  cost

   character(len=12) :: bathy_file_name

   !==============================================================================================!
   !  Local Variables
   !==============================================================================================!

   integer(ip)  ::  sub_nt
   
#ifdef PROFILING
   real :: start_profiling
   real :: end_profiling
#endif


   run_status = 0

   !==============================================================================================!
   !  Code that may duplicate some portion of Initial(), but necessary when performing a DA
   !         --> in that case, there are model parameters that depend on the control which must
   !             be re-initialized
   !==============================================================================================!
   
   !==============================================================================================!
   !  Change of variables (u = u_b + Bdemi*v, where u is the model input parameter)
   !==============================================================================================!

   if ( var_chg ) then
      call var_chg_2_var()
      if (run_status < 0) return
   end if
   
   !==============================================================================================!
   !  Update parameters which may depend on the control used in the DA process
   !==============================================================================================!

   ! Strickler coefficient parameters
   if (friction /= 0) then
      call calc_K_params_everywhere(mesh)
   end if
   ! DoF%q must match the upstream boundary condition
   if ( bc_W == 'discharg' ) then
      dof0%q(1) = bc%hyd%q(1) 
      dof0%q(2) = bc%hyd%q(1)
      dof0%q(3) = bc%hyd%q(1)
   end if
   ! Bathymetry
   call calc_bathymetry(mesh, dof0)
   if (run_status < 0) return
   
   !==============================================================================================!
   !  DoF Initialization (if the initialization depend on some potentially controlled parameters)
   !==============================================================================================!
   
   tc  =  tc0

   if (initialization == "backwater" .and. tc < dt) then

      call solve_backwater(mesh, dof0)
     
   else if (initialization == "standard_step" .and. tc < dt) then
   
      call standard_step(mesh, dof0, 1e-3_rp, 1000_ip)
   
   end if
   if (run_status < 0) return
   
   dof%q  =  dof0%q
   dof%s  =  dof0%s
   dof%h  =  dof0%h

   tc  =  tc0
   nt  =  nt0
   
                                                                                      !<NOADJ
         
   !==============================================================================================!
   !  Post-processing
   !==============================================================================================!
   call sw_post_treatment( dof , mesh )
   
                                                                                      !>NOADJ

   if ( use_obs == 1 ) innovation(:)%ind_t  =  1_ip

   !  Writing Initial Condition Output File
   call write_results( dof , mesh )    !NOADJ

   !===============================================================================================!
   !
   !  Run SW Model
   !
   !===============================================================================================!

   ! Initialize the cost
   cost  =  0._rp
   
   end_time_loop = .false.
   
#ifdef PROFILING
   call cpu_time(start_profiling) !NOADJ
#endif

   ! SW Model Loop Time
   do while( .not. end_time_loop )

      call sub_run_model
      if (run_status < 0) return

   end do

#ifdef PROFILING
   !<NOADJ
   call cpu_time(end_profiling)
   print *, "cpu_time:", end_profiling - start_profiling
   print *, "mesh%ncs=", mesh%ncs
   print *, "nt=", nt
   print *, "=>", (end_profiling - start_profiling) / (mesh%ncs * nt) * 1000, "us/dt/dx"
   !>NOADJ
#endif

   !===============================================================================================!
   !  Cost Function Calculation using Innovation Vector
   !===============================================================================================!
   !if (w_obs.eq.1) then 
   call calc_cost_function( cost , mesh )
   !end if

CONTAINS


   !> Lauching of one iteration of computation
   !!
   !! \details This subroutine launches one iteration of computation. Check if the stationnary is reach or not to 
   !! stop the computation.
   !!

   SUBROUTINE sub_run_model

      implicit none
       TYPE( unk )  ::  dof_temp!NOADJ

      real(rp)  ::  Ap,Bp,Aps,Bps!NOADJ
      sub_nt = 0
      

      !call SurfaceToHeight(mesh,dof)!NOADJ !TODO : Check
      do while ( .not. end_time_loop.and.sub_nt<max_nt_for_adjoint)

         !=============================================================================================================!
         !  Time Control
         !=============================================================================================================!
         
         call advance_time( dof , mesh )

         !=============================================================================================================!
         !  Time Stepping Performing
         !=============================================================================================================!
         
         

         !<NOADJ
         if (steady_state.eq.1) then
            if ( .not. test_dt_just_after( dtw ) .and. &
                       tc > zerom                .and. &
                       steady_state.eq.1         .and. &
                       abs( tc - ts ) > zerom  ) then 
               Ap=0
               else
                  call alloc_dof( dof_temp , mesh )
                  dof_temp%q( 1 : mesh%ncs+4 )  =  dof%q( 1 : mesh%ncs+4 )
                  dof_temp%s( 1 : mesh%ncs+4 )  =  dof%s( 1 : mesh%ncs+4 )
            endif         
         endif
                                                                            !>NOADJ
         select case(spatial_scheme)
            
            ! HLL scheme
         case ('euler_first')

               call euler_time_step_first(dof,mesh)

                                                          !<NOADJ
            case ('euler_first_b1')
               call euler_time_step_first_b1(dof,mesh)
                                                                              
            case ('euler_first_b2')
               call euler_time_step_first_b2(dof,mesh)

            case ('rk2_b1')
               call rk_time_step( dof , mesh )

            case ('rk2_b2')
               call rk_time_step( dof , mesh )

            case ('rk2_euler_first')
               call rk_time_step( dof , mesh )



                                                                  
            ! Low froude scheme
            case ('implicit_low_froude')
               call implicit_low_froude( dof , mesh )
                                                                          
            case ('explicit_low_froude')
               call explicit_low_froude( dof , mesh )

            case ('rk2_explicit_low_froude')
               call rk_time_step( dof , mesh )

            case ('explicit_low_froude_b1')
               call explicit_low_froude_b1( dof , mesh )

            case ('explicit_low_froude_b2')
               call explicit_low_froude_b2( dof , mesh )

            case ('rk2_explicit_low_froude_b1')
               call rk_time_step( dof , mesh ) 

                                                                                       !>NOADJ
            case ('rk2_explicit_low_froude_b2')
               call rk_time_step( dof , mesh ) 
                                                                                          !<NOADJ

            ! Preissman scheme
            case ('preissmann')
               call preissmann(dof,mesh)

            case ('preissmann_LPI')
               call preissmann_LPI(dof,mesh)

            case ('preissmann_double_sweep')
               call preissmann_double_sweep(dof,mesh) 

                                                                                       !>NOADJ
            case ('preissmann_double_sweep_LPI')
               call preissmann_double_sweep_LPI(dof,mesh)
                                                                                          !<NOADJ

                                                                                
!>NOADJ
            case default
               write (*,'(2(A50))'), 'Defaut scheme ' ,spatial_scheme
         end select
         if (run_status < 0) return


                                                                                       !<NOADJ
         if (steady_state.eq.1) then 
            !write (*,*) 'rrr'
            if ( .not. test_dt_just_after( dtw ) .and. &
                       tc > zerom                .and. &
                        
                       abs( tc - ts ) > zerom  ) then 
               Ap=0
               ApS=0
               else
                  Ap=0
                  ApS=0
                  do ie=3,mesh%ncs+2
                     Ap=Ap+mesh%crosssection(ie)%delta*abs(dof%q(ie)-dof_temp%q(ie))!**2
                     Bp=Bp+mesh%crosssection(ie)%delta*abs(dof%q(ie))!**2
                     ApS=ApS+mesh%crosssection(ie)%delta*abs(dof%S(ie)-dof_temp%S(ie))!**2
                     BpS=BpS+mesh%crosssection(ie)%delta*abs(dof%S(ie))!**2
                  end do
                  Ap =(sqrt(div_by_except_0(Ap ,Bp )))/dt
                  Aps=(sqrt(div_by_except_0(Aps,Bps)))/dt
                     write(*,'(A18)') , '* Steady state :  ' 
                     write(*,'(ES12.6)'),tc, dt
                     write(*,*) nt
                     write(*,'((A16),(E11.5))') ,'    epsilonQ  : ', Ap 
                     write(*,'((A16),(E11.5))') ,'    epsilonS  : ', Aps  
                  if ((Ap.le.eps_q_steady_state).and.(Aps.le.eps_s_steady_state))   then          !0.000000001   
                     call write_results_temp( dof , mesh )
                     end_time_loop=.true.
                     tc=ts
                     call write_results_temp( dof , mesh )
                  endif

               call dealloc_dof( dof_temp )
            endif
         endif 
                                                                                         !>NOADJ
         
         !=============================================================================================================!
         !  Post-processing
         !=============================================================================================================!
         call sw_post_treatment( dof , mesh )

         !=============================================================================================================!
         !  Writing Output Result File
         !=============================================================================================================!

         call write_results( dof , mesh )                                                                         !NOADJ

         !=============================================================================================================!
         !  Filling Innovation Vector
         !=============================================================================================================!
         
         if ( use_obs == 1 ) then

           call calc_innovation( dof )

         !else

         !   call update_cost_function( dof , cost )

         endif

         sub_nt = sub_nt + 1

      end do

    END SUBROUTINE sub_run_model    


END SUBROUTINE run_model


!> Calc the model parameters from the parameters used as control variables in the DA process
    !!
    !! \details computes u = u_b + B^{1/2}v, with u the model parameters and v the control
    !!
    SUBROUTINE var_chg_2_var()
      
      USE m_model
      USE m_common
      
      implicit none

         if ( c_manning == 1 ) then
            select case (K_model)
            case('K(h)')

              select case( K_covariance )
              case('constant_K_covariance')
               ! alpha
               do i=1,K_params%nb_diff_K_reachs
                  K_params%alpha(K_params%cs_start(i)) = alpha_K_fg(i)+Bdemi_K_alpha(i)*alpha_K_chg(i)
               end do
               ! beta
               do i=1,K_params%nb_diff_K_reachs
                  K_params%beta(K_params%cs_start(i)) = beta_K_fg(i)+Bdemi_K_beta(i)*beta_K_chg(i)
               end do

               case('K_gaussian_covariance')
               ! alpha
               do i=1,K_params%nb_diff_K_reachs
                  do j = 1, i
                     K_params%alpha(K_params%cs_start(i)) = alpha_K_fg(i)+Bdemi_K_alpha_m(i,j)*alpha_K_chg(j)
                  end do
               end do               
               ! beta
               do i=1,K_params%nb_diff_K_reachs
                  do j = 1, i
                     K_params%beta(K_params%cs_start(i)) = beta_K_fg(i)+Bdemi_K_beta_m(i,j)*beta_K_chg(j)
                  end do
               end do
               end select
           
            case default
               stop 9
            end select
         end if
         
         if ( c_bathy == 1 ) then
            
            do i = 1, nb_bathy_control_pts
               bathy_points(i) =  bathy_points_fg(i)
               do j = 1, i      
                  bathy_points(i) =  bathy_points(i) + Bdemi_bathy(i,j) * bathy_points_chg(j)
               end do
            end do
            
         else if ( c_bathy == 3 ) then
            select case( bathymetry )
         
            case('parametric')
               do i = 1, nb_bathy_control_pts
                  bathy_cell(bathy_first + i - 1) =  bathy_cell_fg(i)
                  do j = 1, i      
                      bathy_cell(bathy_first + i - 1) =  bathy_cell(bathy_first + i - 1) + &
                                                   Bdemi_bathy(i,j) * bathy_cell_chg(j)                    
                  end do                
               end do
            
            case default      
               print *, "[ ERROR ] iterative regularization cannot be applied on '" // trim(bathymetry) // "'"           
               stop
               
            end select
            
         else if ( c_bathy /= 0 ) then
                        
            print *, "[ ERROR ] iterative regularization can only be applied on c_bathy=3"
            stop

         end if
         
         if ( c_hydrograph == 1 ) then
            do i = 1, size( bc%hyd%q )
               bc%hyd%q(i) = qin_fg(i)
               do j = 1, i
                  bc%hyd%q(i) = bc%hyd%q(i)  + Bdemi_hydrograph(i,j) * qin_chg(j)
                  if (bc%hyd%q(i) < qeps) bc%hyd%q(i) = qeps
               end do
            end do
         end if
         
         
        if ( lat_inflow == '1' .and. c_hydrograph == 1 ) then

	  do k = 1, size( bc%hyd_lat%q(:,1) )!nb of lateral inflows
            do i = 1, size( bc%hyd_lat%q(1,:) )!nb of time step of lateral inflows
            !print*, k, i, bc%hyd_lat%q(k,i), qlat_fg(k,i)
               bc%hyd_lat%q(k,i) = qlat_fg(k,i)
               do j = 1, i
                  bc%hyd_lat%q(k,i) = bc%hyd_lat%q(k,i)  + Bdemi_hydrograph_lat(i,j,k) * qlat_chg(k,j) 
               end do
            end do
          enddo
          
       end if
      
    END SUBROUTINE var_chg_2_var
