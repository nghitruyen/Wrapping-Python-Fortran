!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_obs.f90
!! \brief This file includes m_obs module.
!! \details The file includes only m_obs module (see doc m_obs module).



!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module using Tapenade generated Output Files in /tap directory
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_obs.
!!
!! \details This module includes the definition of the innovation vector. Moreover, it is in this module that the 
!! subroutine which compute cost function are defined.
module m_obs

    use m_common
    use m_mesh
    implicit none
   
   
    type ObsStation
   
        !> Indices of cross-sections
        integer(ip), dimension(:), allocatable :: ics
        !> Observation counter (index of current time)
        integer(ip) :: iobs = 0
        !> Times
        real(rp), dimension(:), allocatable :: t
        !> Offset in observations/estimations arrays
        integer(ip) :: offset
        !> Observed values, sizes: dim1=2 (heights and widths), dim2=size(t)
        real(rp), dimension(:, :), allocatable :: obs
        !> Weights, sizes: dim1=2 (heights and widths), dim2=size(t)
        real(rp), dimension(:, :), allocatable :: w
   
    end type
    
    
    type Observations
   
        type(ObsStation), dimension(:), allocatable :: stations
        !> Observed values, sizes: dim1=2 (heights and widths), dim2=N (all stations & all times)
        real(rp), dimension(:, :), allocatable :: obs
        !> Weights, sizes: dim1=2 (heights and widths), dim2=N (all stations & all times)
        real(rp), dimension(:, :), allocatable :: w
        !> Estimated values, sizes: dim1=2 (heights and widths), dim2=N (all stations & all times)
        real(rp), dimension(:, :), allocatable :: est
   
    end type
    
    
    contains
#ifndef CPP_ADJ
    
    
    subroutine obsstation_initialise(station, ics, t, values)
        implicit none
        integer(ip), dimension(:), intent(in) :: ics
        real(rp), dimension(:), intent(in) :: t
        real(rp), dimension(:, :), intent(in) :: values
        type(ObsStation), intent(out) :: station
        
        ! Check sizes
        if (size(t) /= size(values, 2)) then
            call f90wrap_abort("shape(values, 2) must be equal to size(t)")
        end if
        if (size(values, 1) /= 2) then
            call f90wrap_abort("shape(values, 1) must be equal to 2 (heights and widths)")
        end if
        
        allocate(station%ics(size(ics)))
        station%ics(:) = ics(:)
        allocate(station%t(size(t)))
        station%t(:) = t(:)
        station%offset = -1
        allocate(station%obs(2, size(t)))
        station%obs(:, :) = values(:, :)
        
    end subroutine obsstation_initialise
    
    
    subroutine obsstation_finalise(station)
        implicit none
        type(ObsStation), intent(inout) :: station
        
        ! Check sizes
        if (allocated(station%ics)) deallocate(station%ics)
        if (allocated(station%t)) deallocate(station%t)
        if (allocated(station%obs)) deallocate(station%obs)
        
    end subroutine obsstation_finalise
    
    
    subroutine setup_station(station, ics, t, values)
        implicit none
        type(ObsStation), intent(inout) :: station
        integer(ip), dimension(:), intent(in) :: ics
        real(rp), dimension(:), intent(in) :: t
        real(rp), dimension(:, :), intent(in), optional :: values
        
        ! Check sizes
        if (present(values)) then
            if (size(t) /= size(values, 2)) then
                print *, "size(values) =", size(values, 1), size(values, 2)
                call f90wrap_abort("shape(values, 2) must be equal to size(t)")
            end if
            if (size(values, 1) /= 2) then
                call f90wrap_abort("shape(values, 1) must be equal to 2 (heights and widths)")
            end if
        end if
        
        if (allocated(station%ics)) deallocate(station%ics)
        if (allocated(station%t)) deallocate(station%t)
        if (allocated(station%obs)) deallocate(station%obs)
        
        allocate(station%ics(size(ics)))
        station%ics(:) = ics(:) + 1
        allocate(station%t(size(t)))
        station%t(:) = t(:)
        station%offset = -1
        if (present(values)) then
            allocate(station%obs(2, size(t)))
            station%obs(:, :) = values(:, :)
            allocate(station%w(2, size(t)))
            station%w(:, :) = 1.0
!             print *, "setup_stations:", ics, values
        end if
        
    end subroutine setup_station
    
    
    subroutine set_station_weights(station, weights)
        implicit none
        type(ObsStation), intent(inout) :: station
        real(rp), dimension(:, :), intent(in) :: weights
        
        ! Check sizes
        if (size(weights, 1) /= size(station%obs, 1)) then
            call f90wrap_abort("shape(weights, 1) must be equal to shape(station%values, 1)")
        end if
        if (size(weights, 2) /= size(station%obs, 2)) then
            call f90wrap_abort("shape(weights, 2) must be equal to shape(station%values, 2)")
        end if
        
        if (allocated(station%w)) deallocate(station%w)
        
        allocate(station%w(size(weights, 1), size(weights, 2)))
        station%w(:, :) = weights(:, :)
        
    end subroutine set_station_weights
    
    
    subroutine observations_initialise(obs, nstations)
        implicit none
        integer(ip), intent(in) :: nstations
        type(Observations), intent(out) :: obs
        
        allocate(obs%stations(nstations))
        
    end subroutine observations_initialise
    
    
    subroutine observations_finalise(obs)
        implicit none
        type(Observations), intent(inout) :: obs
        
        ! Check sizes
        if (allocated(obs%stations)) deallocate(obs%stations)
        if (allocated(obs%obs)) deallocate(obs%obs)
        if (allocated(obs%est)) deallocate(obs%est)
        
    end subroutine observations_finalise
    
    
    subroutine setup_observations_data(obs, ndata)
        implicit none
        type(Observations), intent(inout) :: obs
        integer(ip), intent(in) :: ndata
        
        if (allocated(obs%obs)) deallocate(obs%obs)
        if (allocated(obs%est)) deallocate(obs%est)
        allocate(obs%obs(2, ndata))
        allocate(obs%est(2, ndata))
        obs%obs(:, :) = -1e+99_rp
        obs%est(:, :) = -1e+99_rp
        
    end subroutine setup_observations_data
    
    
    subroutine all_observed(t, msh, obs)
        implicit none
        type(Mesh), intent(in) :: msh
        real(rp), dimension(:), intent(in) :: t
        type(Observations), intent(out) :: obs
        
        ! Index of cross-section
        integer(ip) :: ics
        ! Index of segment
        integer(ip) :: iseg
        ! Index of station
        integer(ip) :: ista
        ! Number of observations/estimations data
        integer(ip) :: ndata
        ! Number of stations
        integer(ip) :: nsta
        
        ! Compute number of stations (number of interior cross-sections)
        nsta = 0
        do iseg = 1, msh%nseg
            nsta = nsta + msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
        end do
        
        allocate(obs%stations(nsta))

        ! Create stations
        ista = 1
        do iseg = 1, msh%nseg
            do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
            
                ! Allocate arrays
                allocate(obs%stations(ista)%ics(1))
                allocate(obs%stations(ista)%t(size(t)))
                
                ! Set index of cross-section for current station
                obs%stations(ista)%ics(1) = ics
                
                ! Set times
                obs%stations(ista)%t(:) = t(:)
                
                ! Set offset
                obs%stations(ista)%offset = (ista - 1) * size(t)
                
                ! Set empty array for obs
                allocate(obs%stations(ista)%obs(0, 0))
                
                ista = ista + 1
            
            end do
        end do
        
        ! Initialise observations and estimations arrays
        ndata = nsta * size(t)
        allocate(obs%obs(2, ndata))
        allocate(obs%est(2, ndata))
        allocate(obs%w(2, ndata))
        obs%obs(:, :) = -1e+99_rp
        obs%est(:, :) = -1e+99_rp
        obs%w(:, :) = 1.0_rp
        
    end subroutine all_observed
    
    
    subroutine data_from_stations(obs, discharge_estimation)
        implicit none
        type(Observations), intent(inout) :: obs
        logical, intent(in), optional :: discharge_estimation
        
        logical :: use_weights
        ! Index of data
        integer(ip) :: idata
        ! Index of station
        integer(ip) :: ista
        ! Number of observations/estimations data
        integer(ip) :: ndata
        ! Number of stations
        integer(ip) :: nsta
        
        ! Count number of data and set offsets
        ndata = 0
        use_weights = .false.
        do ista = 1, size(obs%stations)
            obs%stations(ista)%offset = ndata
            ndata = ndata + size(obs%stations(ista)%obs, 2)
            if (allocated(obs%stations(ista)%w)) then
                use_weights = .true.
            end if
        end do
!         print *, "NDATA=", ndata
        
        ! Setup observations and estimations arrays
        if (allocated(obs%obs)) deallocate(obs%obs)
        if (allocated(obs%w)) deallocate(obs%w)
        if (allocated(obs%est)) deallocate(obs%est)
        
        allocate(obs%obs(2, ndata))
        allocate(obs%w(2, ndata))
        if (present(discharge_estimation)) then
            if (discharge_estimation) then
                allocate(obs%est(3, ndata))
            else
                allocate(obs%est(2, ndata))
            end if
        else
            allocate(obs%est(2, ndata))
        end if
!         allocate(obs%est(2, ndata))
        idata = 0
        do ista = 1, size(obs%stations)
!             print *, "STATION=", ista
            ndata = size(obs%stations(ista)%obs, 2)
            obs%obs(:, idata+1:idata+ndata) = obs%stations(ista)%obs(:, :)
            if (use_weights) then
                if (.not. allocated(obs%stations(ista)%w)) then
                    call abort_solver("Station has no weight set")
                end if
                obs%w(:, idata+1:idata+ndata) = obs%stations(ista)%w(:, :)
            else
                obs%w(:, idata+1:idata+ndata) = 1.0_rp
            end if
            idata = idata + size(obs%stations(ista)%obs, 2)
        end do
        obs%est(:, :) = -1e+99_rp
        
    end subroutine data_from_stations
!         
!     
!     subroutine get_all_observed_heights(obs, heights)
!         implicit none
!         type(Observations), intent(in) :: obs
!         real(rp), dimension(:), allocatable, intent(out) :: heights
!         
!         ! Iterator
!         integer(ip) :: i
!         ! Index of data
!         integer(ip) :: idata
!         ! Index of station
!         integer(ip) :: ista
!         ! Number of data
!         integer(ip) :: ndata
!         
!         ! Compute number of data
!         ndata = 0
!         do ista = 1, size(obs%stations)
!             ndata = ndata + size(obs%stations(ista)%t)
!         end do
! 
!         ! Create data array
!         allocate(heights(ndata))
!         idata = 1
!         do ista = 1, size(obs%stations)
!             do i = 1, size(obs%stations(ista)%t)
!                 heights(idata) = obs%stations(ista)%obs(1, i)
!                 idata = idata + 1
!             end do
!         end do
!         
!     end subroutine get_all_observed_heights
! 
!     
!     subroutine get_all_estimated_heights(obs, heights)
!         implicit none
!         type(Observations), intent(in) :: obs
!         real(rp), dimension(:), allocatable, intent(out) :: heights
!         
!         ! Iterator
!         integer(ip) :: i
!         ! Index of data
!         integer(ip) :: idata
!         ! Index of station
!         integer(ip) :: ista
!         ! Number of data
!         integer(ip) :: ndata
!         
!         ! Compute number of data
!         ndata = 0
!         do ista = 1, size(obs%stations)
!             ndata = ndata + size(obs%stations(ista)%t)
!         end do
! 
!         ! Create data array
!         allocate(heights(ndata))
!         idata = 1
!         do ista = 1, size(obs%stations)
!             do i = 1, size(obs%stations(ista)%t)
!                 heights(idata) = obs%stations(ista)%est(1, i)
!                 idata = idata + 1
!             end do
!         end do
!         
!     end subroutine get_all_estimated_heights
#endif   
    
    
    subroutine reset_observations_counters(obs)
        implicit none
        type(Observations), intent(inout) :: obs
        
        ! Index of station
        integer(ip) :: ista
        
        do ista = 1, size(obs%stations)
            obs%stations(ista)%iobs = 1
        end do
        
    end subroutine reset_observations_counters
    
    
    function cost_L2_heights(Hest, Hobs) result(cost)
        implicit none
        real(rp), dimension(:), intent(in) :: Hest
        real(rp), dimension(:), intent(in) :: Hobs
        real(rp) :: cost
        
        ! Index of observation
        integer(ip) :: iobs
        
        cost = 0.0
        do iobs = 1, size(Hest)
            if (Hobs(iobs) > -999.0) then
                cost = cost + (Hest(iobs) - Hobs(iobs))**2
            end if
        end do
!         cost = sqrt(cost**2)
        
    end function cost_L2_heights
    
    
    function cost_R2_heights(Hest, Hobs, wobs) result(cost)
        implicit none
        real(rp), dimension(:), intent(in) :: Hest
        real(rp), dimension(:), intent(in) :: Hobs
        real(rp), dimension(:), intent(in) :: wobs
        real(rp) :: cost
        
        ! Index of observation
        integer(ip) :: iobs
        
        cost = 0.0
        do iobs = 1, size(Hest)
            if (Hobs(iobs) > -999.0) then
                cost = cost + (wobs(iobs) * (Hest(iobs) - Hobs(iobs)))**2
            end if
        end do
!         cost = sqrt(cost**2)
        
    end function cost_R2_heights

end module m_obs
